# HG changeset patch
# Parent 9ca690835a5eff4af37effc64986d3352f7da20c

diff --git a/dom/media/PeerConnection.js b/dom/media/PeerConnection.js
--- a/dom/media/PeerConnection.js
+++ b/dom/media/PeerConnection.js
@@ -234,21 +234,24 @@ function RTCPeerConnection() {
   this._pc = null;
   this._observer = null;
   this._closed = false;
 
   this._onCreateOfferSuccess = null;
   this._onCreateOfferFailure = null;
   this._onCreateAnswerSuccess = null;
   this._onCreateAnswerFailure = null;
+  this._onIdentityAssertionSuccess = null;
 
   this._pendingType = null;
   this._localType = null;
   this._remoteType = null;
 
+  this._peerIdentity = {};
+
   /**
    * Everytime we get a request from content, we put it in the queue. If
    * there are no pending operations though, we will execute it immediately.
    * In PeerConnectionObserver, whenever we are notified that an operation
    * has finished, we will check the queue for the next operation and execute
    * if neccesary. The _pending flag indicates whether an operation is currently
    * in progress.
    */
@@ -286,20 +289,22 @@ RTCPeerConnection.prototype = {
     this.makeGetterSetterEH("onicecandidate");
     this.makeGetterSetterEH("onnegotiationneeded");
     this.makeGetterSetterEH("onsignalingstatechange");
     this.makeGetterSetterEH("onremovestream");
     this.makeGetterSetterEH("ondatachannel");
     this.makeGetterSetterEH("onconnection");
     this.makeGetterSetterEH("onclosedconnection");
     this.makeGetterSetterEH("oniceconnectionstatechange");
+    this.makeGetterSetterEH("onidentityresult");
 
     this._pc = Cc["@mozilla.org/peerconnection;1"].
              createInstance(Ci.IPeerConnection);
     this._observer = new PeerConnectionObserver(this);
+    this._idp = new PeerConnectionIDP(this);
     this._winID = this._win.QueryInterface(Ci.nsIInterfaceRequestor)
                            .getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
 
     // Add a reference to the PeerConnection to global list (before init).
     _globalPCList.addPC(this);
 
     // Nothing starts until ICE gathering completes.
     this._queueOrRun({
@@ -555,16 +560,24 @@ RTCPeerConnection.prototype = {
     }
     if (!onError) {
       this.deprecated("calling createOffer without failureCallback");
     }
     this._mustValidateConstraints(constraints, "createOffer passed invalid constraints");
     this._onCreateOfferSuccess = onSuccess;
     this._onCreateOfferFailure = onError;
 
+    this._onIdentityAssertionSuccess = function() {
+      //has onSuccess run?
+      this.reportWarning("calling onIdentityAssertionSuccess :)", null, 0);
+    }.bind(this);
+
+
+    // this._observer.onIdentityAssertionSuccess(); // run this guy when we have an assertion from the user
+
     this._queueOrRun({
       func: this._getPC().createOffer,
       args: [constraints],
       wait: true
     });
   },
 
   _createAnswer: function(onSuccess, onError, constraints, provisional) {
@@ -637,16 +650,46 @@ RTCPeerConnection.prototype = {
     this._queueOrRun({
       func: this._getPC().setLocalDescription,
       args: [type, desc.sdp],
       wait: true,
       type: desc.type
     });
   },
 
+  setIdentityProvider: function(provider, protocol, username) {
+    if(this.signalingState == "closed") {
+      this.reportError('setIdentityProvider failed. signalingState is closed.', null, 0);
+    }
+    else {
+      this.reportWarning('setIdentityProvider is not yet fully implemented.', null, 0);
+      this._idp.init(provider, protocol, username); //initialize the idp
+    }
+  },
+
+  getIdentityAssertion: function() {
+    if(this.signalingState == "closed") {
+      this.reportError('getIdentityAssertion failed. signalingState is closed.', null, 0);
+    }
+    else {
+      this.reportWarning('getIdentityAssertion is not yet implemented.', null, 0);
+      if(!this._idp.set) {
+        /// get key fingerprint
+        this.reportWarning('setIdentityProvider has not been called.', null, 0);
+        this._idp.init('login.persona.org', 'default', null); //default inititalization values
+        var assertion = this._idp.requestIdentityAssertion(null);
+        this.reportWarning("GOT ASSERTION: " + JSON.stringify(assertion), null, 0);
+      }
+      else {
+        var assertion = this._idp.requestIdentityAssertion(null);
+        this.reportWarning("GOT ASSERTION: " + JSON.stringify(assertion), null, 0);
+      }
+    }
+  },
+
   setRemoteDescription: function(desc, onSuccess, onError) {
     // TODO -- if we have two setRemoteDescriptions in the
     // queue, this code overwrites the callbacks for the first
     // one with the callbacks for the second one. See Bug 831759.
     this._onSetRemoteDescriptionSuccess = onSuccess;
     this._onSetRemoteDescriptionFailure = onError;
 
     let type;
@@ -740,16 +783,20 @@ RTCPeerConnection.prototype = {
     this.deprecated("localStreams");
     return this.getLocalStreams();
   },
   get remoteStreams() {
     this.deprecated("remoteStreams");
     return this.getRemoteStreams();
   },
 
+  get peerIdentity() {
+    return this._peerIdentity;
+  },
+
   get localDescription() {
     this._checkClosed();
     let sdp = this._getPC().localDescription;
     if (sdp.length == 0) {
       return null;
     }
     return new this._win.mozRTCSessionDescription({ type: this._localType,
                                                     sdp: sdp });
@@ -912,23 +959,30 @@ PeerConnectionObserver.prototype = {
         // A content script (user-provided) callback threw an error. We don't
         // want this to take down peerconnection, but we still want the user
         // to see it, so we catch it, report it, and move on.
         this._dompc.reportError(e.message, e.fileName, e.lineNumber);
       }
     }
   },
 
-  onCreateOfferSuccess: function(sdp) {
+  onIdentityAssertionSuccess: function(sdp) {
     this.callCB(this._dompc._onCreateOfferSuccess,
                 new this._dompc._win.mozRTCSessionDescription({ type: "offer",
                                                                 sdp: sdp }));
     this._dompc._executeNext();
   },
 
+  onCreateOfferSuccess: function(sdp) {
+    // getIdentityAssertion here and pass in the sdp
+    sdp = this._dompc._idp.requestIdentityAssertion(sdp);
+    // pass fingerprint to getIdentityAssertion
+    this.onIdentityAssertionSuccess(sdp);
+  },
+
   onCreateOfferError: function(code, message) {
     this.callCB(this._dompc._onCreateOfferFailure, new RTCError(code, message));
     this._dompc._executeNext();
   },
 
   onCreateAnswerSuccess: function(sdp) {
     this.callCB (this._dompc._onCreateAnswerSuccess,
                  new this._dompc._win.mozRTCSessionDescription({ type: "answer",
@@ -1047,15 +1101,75 @@ PeerConnectionObserver.prototype = {
   },
 
   notifyConnection: function() {
     this.dispatchEvent(new this._dompc._win.Event("connection"));
   },
 
   notifyClosedConnection: function() {
     this.dispatchEvent(new this._dompc._win.Event("closedconnection"));
+  },
+
+  notifyIdentityResult: function() {
+    this.dispatchEvent(new this._dompc._win.Event('identityresult'));
   }
 };
 
+function PeerConnectionIDP(pc) {
+  this._dompc = pc; // peer connection object
+  this.fallback_provider = 'login.persona.org'; // browser specific fallback idp (we will use Persona)
+  this.provider = null; // user specified idp domain (gmail.com/login.persona.org/yahoo.com)
+  this.protocol = null; // protocol to use ("default")
+  this.username = null; // "assertion" used to verify the identity
+  this.set = false; // true if the IDP has been initialized previously
+};
+PeerConnectionIDP.prototype = {
+  init: function(provider, protocol, username) {
+    // set the required values
+    this.set = true;
+    this.setIDP(provider, protocol, username);
+    this._dompc.reportWarning('IDP has been (re-)initialized.', null, 0);
+  },
+  requestIdentityAssertion: function(sdp) {
+    if(!sdp) {
+      //createOffer wasn't called to get here
+      return null; // throw an error?
+    }
+    // get the key fingerprint from the sdp and use it when getting an assertion
+    let pattern = /\na=fingerprint:\s*(\S+\s*\S*)/i;
+    let fingerprint = sdp.match(pattern)[1];
+
+    let crappy_crypto = fingerprint.replace(/\:/g,"");
+    let assertion = crappy_crypto + "example123identity@example.com" + crappy_crypto;
+    sdp += "a=identity:" + assertion;
+
+    // fake implementation
+    // In the future we will open an iframe and allow the user to login to their IDP.
+    //
+    // Instantiate a new IdP proxy and request an identity assertion.
+    // Here we are just making up an assertion
+    // let identity =  {
+    //                   //A domain name representing the identity provider.
+    //                   idp: this.getProvider(),
+    //                   // An RFC822-conformant [TODO: REF] representation
+    //                   // of the verified peer identity. This identity
+    //                   // will have been verified via the procedures
+    //                   // described in [RTCWEB-SECURITY-ARCH].
+    //                   name: this.username || "example@example.com" // example: the assertion from Persona
+    //                 };
+    // callback(identity); // return identity assertion in the callback (for some reason this wont work)
+    return sdp;
+  },
+  setIDP: function(provider, protocol, username) {
+    this.provider = provider;
+    this.protocol = protocol;
+    this.username = username;
+  },
+  getProvider: function() {
+    return this.provider || this.fallback_provider;
+  }
+};
+
+
 this.NSGetFactory = XPCOMUtils.generateNSGetFactory(
   [GlobalPCList, RTCIceCandidate, RTCSessionDescription, RTCPeerConnection,
    RTCPeerConnectionIceEvent, MediaStreamEvent, RTCDataChannelEvent]
 );
diff --git a/dom/media/PeerConnection.manifest b/dom/media/PeerConnection.manifest
--- a/dom/media/PeerConnection.manifest
+++ b/dom/media/PeerConnection.manifest
@@ -1,15 +1,17 @@
 component {9878b414-afaa-4176-a887-1e02b3b047c2} PeerConnection.js
 component {02b9970c-433d-4cc2-923d-f7028ac66073} PeerConnection.js
 component {1775081b-b62d-4954-8ffe-a067bbf508a7} PeerConnection.js
 component {7293e901-2be3-4c02-b4bd-cbef6fc24f78} PeerConnection.js
 component {b9cd25a7-9859-4f9e-8f84-ef5181ff36c0} PeerConnection.js
 component {a722a8a9-2290-4e99-a5ed-07b504292d08} PeerConnection.js
 component {d5ed7fbf-01a8-4b18-af6c-861cf2aac920} PeerConnection.js
+component {498df9b5-87dd-40e5-b717-9cab40b1f99b} PeerConnection.js
 
 contract @mozilla.org/dom/peerconnection;1 {9878b414-afaa-4176-a887-1e02b3b047c2}
 contract @mozilla.org/dom/rtcicecandidate;1 {02b9970c-433d-4cc2-923d-f7028ac66073}
 contract @mozilla.org/dom/rtcsessiondescription;1 {1775081b-b62d-4954-8ffe-a067bbf508a7}
+contract @mozilla.org/dom/rtcidentityassertion;1 {498df9b5-87dd-40e5-b717-9cab40b1f99b}
 contract @mozilla.org/dom/peerconnectionmanager;1 {7293e901-2be3-4c02-b4bd-cbef6fc24f78}
 contract @mozilla.org/dom/rtcpeerconnectioniceevent;1 {b9cd25a7-9859-4f9e-8f84-ef5181ff36c0}
 contract @mozilla.org/dom/mediastreamevent;1 {a722a8a9-2290-4e99-a5ed-07b504292d08}
 contract @mozilla.org/dom/datachannelevent;1 {d5ed7fbf-01a8-4b18-af6c-861cf2aac920}
diff --git a/dom/webidl/RTCIdentityAssertion.webidl b/dom/webidl/RTCIdentityAssertion.webidl
new file mode 100644
--- /dev/null
+++ b/dom/webidl/RTCIdentityAssertion.webidl
@@ -0,0 +1,12 @@
+dictionary RTCIdentityAssertionInit {
+  DOMString? idp = null;
+  DOMString? name = null;
+};
+
+[Pref="media.peerconnection.enabled",
+ JSImplementation="@mozilla.org/dom/rtcidentityassertion;1",
+ Constructor(optional RTCIdentityAssertionInit assertionInitDict)]
+interface RTCIdentityAssertion {
+  attribute DOMString? idp;
+  attribute DOMString? name;
+};
diff --git a/dom/webidl/RTCPeerConnection.webidl b/dom/webidl/RTCPeerConnection.webidl
--- a/dom/webidl/RTCPeerConnection.webidl
+++ b/dom/webidl/RTCPeerConnection.webidl
@@ -4,16 +4,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/.
  *
  * The origin of this IDL file is
  * http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCPeerConnection
  */
 
 callback RTCSessionDescriptionCallback = void (mozRTCSessionDescription sdp);
 callback RTCPeerConnectionErrorCallback = void (DOMString errorInformation);
+callback RTCIdentityResultCallback = void (RTCIdentityAssertion result);
 callback VoidFunction = void ();
 
 enum RTCSignalingState {
     "stable",
     "have-local-offer",
     "have-remote-offer",
     "have-local-pranswer",
     "have-remote-pranswer",
@@ -63,41 +64,49 @@ interface mozRTCPeerConnection : EventTa
                     RTCPeerConnectionErrorCallback? failureCallback, // for apprtc
                     optional object? constraints);
   void createAnswer (RTCSessionDescriptionCallback successCallback,
                      RTCPeerConnectionErrorCallback? failureCallback, // for apprtc
                      optional object? constraints);
   void setLocalDescription (mozRTCSessionDescription description,
                             optional VoidFunction successCallback,
                             optional RTCPeerConnectionErrorCallback failureCallback);
+  void setIdentityProvider (DOMString provider,
+                            optional DOMString protocol,
+                            optional DOMString username);
+  void getIdentityAssertion ();
   void setRemoteDescription (mozRTCSessionDescription description,
                              optional VoidFunction successCallback,
                              optional RTCPeerConnectionErrorCallback failureCallback);
   readonly attribute mozRTCSessionDescription? localDescription;
   readonly attribute mozRTCSessionDescription? remoteDescription;
   readonly attribute RTCSignalingState signalingState;
+
   void updateIce (optional RTCConfiguration configuration,
                   optional object? constraints);
   void addIceCandidate (mozRTCIceCandidate candidate,
                         optional VoidFunction successCallback,
                         optional RTCPeerConnectionErrorCallback failureCallback);
   readonly attribute RTCIceGatheringState iceGatheringState;
   readonly attribute RTCIceConnectionState iceConnectionState;
+
   sequence<MediaStream> getLocalStreams ();
   sequence<MediaStream> getRemoteStreams ();
   MediaStream? getStreamById (DOMString streamId);
   void addStream (MediaStream stream, optional object? constraints);
   void removeStream (MediaStream stream);
   void close ();
   attribute EventHandler onnegotiationneeded;
   attribute EventHandler onicecandidate;
   attribute EventHandler onsignalingstatechange;
   attribute EventHandler onaddstream;
   attribute EventHandler onremovestream;
   attribute EventHandler oniceconnectionstatechange;
+
+  readonly attribute RTCIdentityAssertion peerIdentity;
 };
 
 // Mozilla extensions.
 partial interface mozRTCPeerConnection {
   // Deprecated callbacks (use causes warning)
   attribute RTCPeerConnectionErrorCallback onicechange;
   attribute RTCPeerConnectionErrorCallback ongatheringchange;
 
@@ -107,9 +116,11 @@ partial interface mozRTCPeerConnection {
   readonly attribute DOMString readyState;
 
   // Data channel.
   RTCDataChannel createDataChannel (DOMString label,
                                     optional RTCDataChannelInit dataChannelDict);
   attribute EventHandler ondatachannel;
   attribute EventHandler onconnection;
   attribute EventHandler onclosedconnection;
+
+  attribute EventHandler onidentityresult;
 };
diff --git a/dom/webidl/WebIDL.mk b/dom/webidl/WebIDL.mk
--- a/dom/webidl/WebIDL.mk
+++ b/dom/webidl/WebIDL.mk
@@ -205,16 +205,17 @@ webidl_files = \
   Rect.webidl \
   RGBColor.webidl \
   RTCConfiguration.webidl \
   RTCDataChannelEvent.webidl \
   RTCIceCandidate.webidl \
   RTCPeerConnection.webidl \
   RTCPeerConnectionIceEvent.webidl \
   RTCSessionDescription.webidl \
+  RTCIdentityAssertion.webidl \
   Screen.webidl \
   ScriptProcessorNode.webidl \
   ScrollAreaEvent.webidl \
   SimpleGestureEvent.webidl \
   StyleSheet.webidl \
   SVGAElement.webidl \
   SVGAltGlyphElement.webidl \
   SVGAngle.webidl \
