# HG changeset patch
# Parent 57d30169ddd474792585b967f79d3e8a3202178c

diff --git a/dom/media/PeerConnection.js b/dom/media/PeerConnection.js
--- a/dom/media/PeerConnection.js
+++ b/dom/media/PeerConnection.js
@@ -235,16 +235,18 @@ function RTCPeerConnection() {
   this._observer = null;
   this._closed = false;
 
   this._onCreateOfferSuccess = null;
   this._onCreateOfferFailure = null;
   this._onCreateAnswerSuccess = null;
   this._onCreateAnswerFailure = null;
 
+  this._onidentityresult = null;
+
   this._pendingType = null;
   this._localType = null;
   this._remoteType = null;
 
   /**
    * Everytime we get a request from content, we put it in the queue. If
    * there are no pending operations though, we will execute it immediately.
    * In PeerConnectionObserver, whenever we are notified that an operation
@@ -286,16 +288,17 @@ RTCPeerConnection.prototype = {
     this.makeGetterSetterEH("onicecandidate");
     this.makeGetterSetterEH("onnegotiationneeded");
     this.makeGetterSetterEH("onsignalingstatechange");
     this.makeGetterSetterEH("onremovestream");
     this.makeGetterSetterEH("ondatachannel");
     this.makeGetterSetterEH("onconnection");
     this.makeGetterSetterEH("onclosedconnection");
     this.makeGetterSetterEH("oniceconnectionstatechange");
+    this.makeGetterSetterEH("onidentityresult");
 
     this._pc = Cc["@mozilla.org/peerconnection;1"].
              createInstance(Ci.IPeerConnection);
     this._observer = new PeerConnectionObserver(this);
     this._winID = this._win.QueryInterface(Ci.nsIInterfaceRequestor)
                            .getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
 
     // Add a reference to the PeerConnection to global list (before init).
@@ -529,27 +532,32 @@ RTCPeerConnection.prototype = {
     Object.defineProperty(this, name,
                           {
                             get:function()  { return this.getEH(name); },
                             set:function(h) { return this.setEH(name, h); }
                           });
   },
 
   get onicechange()       { return this._onicechange; },
+  get onidentityresult()       { return this._onidentityresult; },
   get ongatheringchange() { return this._ongatheringchange; },
 
   set onicechange(cb) {
     this.deprecated("onicechange");
     this._onicechange = cb;
   },
   set ongatheringchange(cb) {
     this.deprecated("ongatheringchange");
     this._ongatheringchange = cb;
   },
 
+  set onidentityresult(cb) {
+    this._onidentityresult = cb;
+  },
+
   deprecated: function(name) {
     this.reportWarning(name + " is deprecated!", null, 0);
   },
 
   createOffer: function(onSuccess, onError, constraints) {
     if (!constraints) {
       constraints = {};
     }
@@ -637,16 +645,30 @@ RTCPeerConnection.prototype = {
     this._queueOrRun({
       func: this._getPC().setLocalDescription,
       args: [type, desc.sdp],
       wait: true,
       type: desc.type
     });
   },
 
+  setIdentityProvider: function(provider, protocol, username) {
+    this.reportWarning('setIdentityProvider is not yet implemented.', null, 0);
+
+    // this._queueOrRun({
+    //   func: this._getPC().setIdentityProvider,
+    //   args: [provider, protocol, username],
+    //   wait: true
+    // });
+  },
+
+  getIdentityAssertion: function() {
+    this.reportWarning('getIdentityAssertion is not yet implemented.', null, 0);
+  },
+
   setRemoteDescription: function(desc, onSuccess, onError) {
     // TODO -- if we have two setRemoteDescriptions in the
     // queue, this code overwrites the callbacks for the first
     // one with the callbacks for the second one. See Bug 831759.
     this._onSetRemoteDescriptionSuccess = onSuccess;
     this._onSetRemoteDescriptionFailure = onError;
 
     let type;
diff --git a/dom/media/bridge/IPeerConnection.idl b/dom/media/bridge/IPeerConnection.idl
--- a/dom/media/bridge/IPeerConnection.idl
+++ b/dom/media/bridge/IPeerConnection.idl
@@ -112,16 +112,17 @@ interface IPeerConnection : nsISupports
   /* Must be called first. Observer events will be dispatched on the thread provided */
   [implicit_jscontext] void initialize(in IPeerConnectionObserver observer, in nsIDOMWindow window,
                   [optional] in jsval iceServers,
                   [optional] in nsIThread thread);
 
   /* JSEP calls */
   [implicit_jscontext] void createOffer(in jsval constraints);
   [implicit_jscontext] void createAnswer(in jsval constraints);
+  // void setIdentityProvider(in string provider, [optional] in string protocol, [optional] in string username);
   void setLocalDescription(in long action, in string sdp);
   void setRemoteDescription(in long action, in string sdp);
 
   /* Adds the stream created by GetUserMedia */
   void addStream(in nsIDOMMediaStream stream);
   void removeStream(in nsIDOMMediaStream stream);
   void closeStreams();
 
diff --git a/dom/webidl/RTCPeerConnection.webidl b/dom/webidl/RTCPeerConnection.webidl
--- a/dom/webidl/RTCPeerConnection.webidl
+++ b/dom/webidl/RTCPeerConnection.webidl
@@ -57,16 +57,20 @@ interface mozRTCPeerConnection : EventTa
                     RTCPeerConnectionErrorCallback? failureCallback, // for apprtc
                     optional object? constraints);
   void createAnswer (RTCSessionDescriptionCallback successCallback,
                      RTCPeerConnectionErrorCallback? failureCallback, // for apprtc
                      optional object? constraints);
   void setLocalDescription (mozRTCSessionDescription description,
                             optional VoidFunction successCallback,
                             optional RTCPeerConnectionErrorCallback failureCallback);
+  void setIdentityProvider (DOMString provider,
+                            optional DOMString protocol,
+                            optional DOMString username);
+  void getIdentityAssertion ();
   void setRemoteDescription (mozRTCSessionDescription description,
                              optional VoidFunction successCallback,
                              optional RTCPeerConnectionErrorCallback failureCallback);
   readonly attribute mozRTCSessionDescription? localDescription;
   readonly attribute mozRTCSessionDescription? remoteDescription;
   readonly attribute RTCSignalingState signalingState;
   void updateIce (optional RTCConfiguration configuration,
                   optional object? constraints);
@@ -82,16 +86,17 @@ interface mozRTCPeerConnection : EventTa
   void removeStream (MediaStream stream);
   void close ();
   attribute EventHandler onnegotiationneeded;
   attribute EventHandler onicecandidate;
   attribute EventHandler onsignalingstatechange;
   attribute EventHandler onaddstream;
   attribute EventHandler onremovestream;
   attribute EventHandler oniceconnectionstatechange;
+  attribute EventHandler onidentityresult;
 };
 
 // Mozilla extensions.
 partial interface mozRTCPeerConnection {
   // Deprecated callbacks (use causes warning)
   attribute RTCPeerConnectionErrorCallback onicechange;
   attribute RTCPeerConnectionErrorCallback ongatheringchange;
 
diff --git a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
--- a/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
+++ b/media/webrtc/signaling/src/peerconnection/PeerConnectionImpl.cpp
@@ -942,16 +942,24 @@ PeerConnectionImpl::ConvertConstraints(
         NS_ConvertUTF16toUTF8 stringVal(JS_GetStringCharsZ(aCx, optionNameString));
         aObj->setBooleanConstraint(stringVal.get(), JSVAL_TO_BOOLEAN(option), false);
       }
     }
   }
   return NS_OK;
 }
 
+// NS_IMETHODIMP
+// PeerConnectionImpl::SetIdentityProvider(const char* provider, const char* protocol, const char* username)
+// {
+//   PC_AUTO_ENTER_API_CALL(true);
+
+//   return NS_OK;
+// }
+
 NS_IMETHODIMP
 PeerConnectionImpl::CreateOffer(const JS::Value& aConstraints, JSContext* aCx)
 {
   PC_AUTO_ENTER_API_CALL(true);
 
   MediaConstraints cs;
   nsresult rv = ConvertConstraints(aConstraints, &cs, aCx);
   if (rv != NS_OK) {
