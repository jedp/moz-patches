# HG changeset patch
# Parent 7b8ed29c6bc0126f8f5f704ff279e3608ea2d75e
try: -b do -p all -u all -t none

diff --git a/b2g/chrome/content/identity.js b/b2g/chrome/content/identity.js
--- a/b2g/chrome/content/identity.js
+++ b/b2g/chrome/content/identity.js
@@ -16,24 +16,22 @@ Cu.import("resource://gre/modules/Servic
 XPCOMUtils.defineLazyServiceGetter(this, "cpmm",
                                    "@mozilla.org/childprocessmessagemanager;1",
                                    "nsIMessageSender");
 
 XPCOMUtils.defineLazyServiceGetter(this, "uuidgen",
                                    "@mozilla.org/uuid-generator;1",
                                    "nsIUUIDGenerator");
 
-XPCOMUtils.defineLazyModuleGetter(this, "Logger",
-                                  "resource://gre/modules/identity/LogUtils.jsm");
+XPCOMUtils.defineLazyGetter(this, "logger", function() {
+  Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+  return getLogger("Identity", "toolkit.identity.debug");
+});
 
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["injected identity.js"].concat(aMessageArgs));
-}
-
-log("\n\n======================= identity.js =======================\n\n");
+logger.log("\n\n======================= identity.js =======================\n\n");
 
 // This script may be injected more than once into an iframe.
 // Ensure we don't redefine contstants
 if (typeof kIdentityJSLoaded === 'undefined') {
   const kIdentityDelegateWatch = "identity-delegate-watch";
   const kIdentityDelegateRequest = "identity-delegate-request";
   const kIdentityDelegateLogout = "identity-delegate-logout";
   const kIdentityDelegateReady = "identity-delegate-ready";
@@ -73,36 +71,36 @@ function closeIdentityDialog() {
   sendAsyncMessage(kIdentityDelegateFinished);
 }
 
 /*
  * doInternalWatch - call the internal.watch api and relay the results
  * up to the controller.
  */
 function doInternalWatch() {
-  log("doInternalWatch:", options, isLoaded);
+  logger.log("doInternalWatch:", options, isLoaded);
   if (options && isLoaded) {
     let BrowserID = content.wrappedJSObject.BrowserID;
     BrowserID.internal.watch(function(aParams, aInternalParams) {
         identityCall(aParams);
         if (aParams.method === "ready") {
           closeIdentityDialog();
         }
       },
       JSON.stringify(options),
       function(...things) {
         // internal watch log callback
-        log("(watch) internal: ", things);
+        logger.log("(watch) internal: ", things);
       }
     );
   }
 }
 
 function doInternalRequest() {
-  log("doInternalRequest:", options && isLoaded);
+  logger.log("doInternalRequest:", options && isLoaded);
   if (options && isLoaded) {
     var stringifiedOptions = JSON.stringify(options);
     content.wrappedJSObject.BrowserID.internal.get(
       options.origin,
       function(assertion, internalParams) {
         internalParams = internalParams || {};
         if (assertion) {
           identityCall({
@@ -112,17 +110,17 @@ function doInternalRequest() {
         }
         closeIdentityDialog();
       },
       stringifiedOptions);
   }
 }
 
 function doInternalLogout(aOptions) {
-  log("doInternalLogout:", (options && isLoaded));
+  logger.log("doInternalLogout:", (options && isLoaded));
   if (options && isLoaded) {
     let BrowserID = content.wrappedJSObject.BrowserID;
     BrowserID.internal.logout(options.origin, function() {
       identityCall({method:'logout'});
       closeIdentityDialog();
     });
   }
 }
@@ -132,32 +130,32 @@ addEventListener("DOMContentLoaded", fun
     isLoaded = true;
      // bring da func
      if (func) func();
   });
 });
 
 // listen for request
 addMessageListener(kIdentityDelegateRequest, function(aMessage) {
-  log("injected identity.js received", kIdentityDelegateRequest);
+  logger.log("injected identity.js received", kIdentityDelegateRequest);
   options = aMessage.json;
   showUI = true;
   func = doInternalRequest;
   func();
 });
 
 // listen for watch
 addMessageListener(kIdentityDelegateWatch, function(aMessage) {
-  log("injected identity.js received", kIdentityDelegateWatch);
+  logger.log("injected identity.js received", kIdentityDelegateWatch);
   options = aMessage.json;
   showUI = false;
   func = doInternalWatch;
   func();
 });
 
 // listen for logout
 addMessageListener(kIdentityDelegateLogout, function(aMessage) {
-  log("injected identity.js received", kIdentityDelegateLogout);
+  logger.log("injected identity.js received", kIdentityDelegateLogout);
   options = aMessage.json;
   showUI = false;
   func = doInternalLogout;
   func();
 });
diff --git a/b2g/components/SignInToWebsite.jsm b/b2g/components/SignInToWebsite.jsm
--- a/b2g/components/SignInToWebsite.jsm
+++ b/b2g/components/SignInToWebsite.jsm
@@ -34,17 +34,17 @@
  * in its context.
  *
  * On the Relying Party's side, say a web page invokes
  * navigator.id.watch(), to register callbacks, and then
  * navigator.id.request() to request an assertion.  The navigator.id
  * calls are provided by nsDOMIdentity.  nsDOMIdentity messages down
  * to the privileged DOMIdentity code (using cpmm and ppmm message
  * managers).  DOMIdentity stores the state of Relying Party flows
- * using an Identity service (MinimalIdentity.jsm), and emits messages
+ * using an Identity service (IdentityService.jsm), and emits messages
  * requesting Persona functions (doWatch, doReady, doLogout).
  *
  * The Identity service sends these observer messages to the
  * Controller in this module, which in turn triggers content to open a
  * window to host the Persona js.  If user interaction is required,
  * content will open the trusty UI.  If user interaction is not required,
  * and we only need to get to Persona functions, content will open a
  * hidden iframe.  In either case, a window is opened into which the
@@ -74,20 +74,17 @@ this.EXPORTED_SYMBOLS = ["SignInToWebsit
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/identity/IdentityUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "IdentityService",
-                                  "resource://gre/modules/identity/MinimalIdentity.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "Logger",
-                                  "resource://gre/modules/identity/LogUtils.jsm");
+                                  "resource://gre/modules/identity/IdentityService.jsm");
 
 // JS shim that contains the callback functions that
 // live within the identity UI provisioning frame.
 const kIdentityShimFile = "chrome://browser/content/identity.js";
 
 // Type of MozChromeEvents to handle id dialogs.
 const kOpenIdentityDialog = "id-dialog-open";
 const kDoneIdentityDialog = "id-dialog-done";
@@ -97,19 +94,21 @@ const kCloseIdentityDialog = "id-dialog-
 const kIdentityDelegateWatch = "identity-delegate-watch";
 const kIdentityDelegateRequest = "identity-delegate-request";
 const kIdentityDelegateLogout = "identity-delegate-logout";
 const kIdentityDelegateFinished = "identity-delegate-finished";
 const kIdentityDelegateReady = "identity-delegate-ready";
 
 const kIdentityControllerDoMethod = "identity-controller-doMethod";
 
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["SignInToWebsiteController"].concat(aMessageArgs));
-}
+XPCOMUtils.defineLazyGetter(this, "logger", function() {
+  Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+  return getLogger("Identity", "toolkit.identity.debug");
+});
+
 
 /*
  * ContentInterface encapsulates the our content functions.  There are only two:
  *
  * getContent       - return the current content window
  * sendChromeEvent  - send a chromeEvent from the browser shell
  */
 let ContentInterface = {
@@ -143,29 +142,29 @@ Pipe.prototype = {
 
   observe: function Pipe_observe(aSubject, aTopic, aData) {
     let options = {};
     if (aSubject) {
       options = aSubject.wrappedJSObject;
     }
     switch (aTopic) {
       case "identity-child-process-shutdown":
-        log("pipe removing watchers by message manager");
+        logger.log("pipe removing watchers by message manager");
         this._removeWatchers(null, options.messageManager);
         break;
 
       case "identity-controller-unwatch":
-        log("unwatching", options.id);
+        logger.log("unwatching", options.id);
         this._removeWatchers(options.id, options.messageManager);
         break;
     }
   },
 
   _addWatcher: function Pipe__addWatcher(aId, aMm) {
-    log("Adding watcher with id", aId);
+    logger.log("Adding watcher with id", aId);
     for (let i = 0; i < this._watchers.length; ++i) {
       let watcher = this._watchers[i];
       if (this._watcher.id === aId) {
         watcher.count++;
         return;
       }
     }
     this._watchers.push({id: aId, count: 1, mm: aMm});
@@ -189,45 +188,45 @@ Pipe.prototype = {
           this._watchers.splice(index, 1);
         }
       } else {
         this._watchers.splice(index, 1);
       }
     }
 
     if (this._watchers.length === 0) {
-      log("No more watchers; clean up persona host iframe");
+      logger.log("No more watchers; clean up persona host iframe");
       let detail = {
         type: kCloseIdentityDialog
       };
-      log('telling content to close the dialog');
+      logger.log('telling content to close the dialog');
       // tell content to close the dialog
       ContentInterface.sendChromeEvent(detail);
     }
   },
 
   communicate: function(aRpOptions, aContentOptions, aMessageCallback) {
     let rpID = aRpOptions.id;
     let rpMM = aRpOptions.mm;
     if (rpMM) {
       this._addWatcher(rpID, rpMM);
     }
 
-    log("RP options:", aRpOptions, "\n  content options:", aContentOptions);
+    logger.log("RP options:", aRpOptions, "\n  content options:", aContentOptions);
 
     // This content variable is injected into the scope of
     // kIdentityShimFile, where it is used to access the BrowserID object
     // and its internal API.
     let content = ContentInterface.getContent();
     let mm = null;
     let uuid = getRandomId();
     let self = this;
 
     if (!content) {
-      log("ERROR: what the what? no content window?");
+      logger.log("ERROR: what the what? no content window?");
       // aErrorCb.onresult("NO_CONTENT_WINDOW");
       return;
     }
 
     function removeMessageListeners() {
       if (mm) {
         mm.removeMessageListener(kIdentityDelegateFinished, identityDelegateFinished);
         mm.removeMessageListener(kIdentityControllerDoMethod, aMessageCallback);
@@ -238,17 +237,17 @@ Pipe.prototype = {
       removeMessageListeners();
 
       let detail = {
         type: kDoneIdentityDialog,
         showUI: aContentOptions.showUI || false,
         id: kDoneIdentityDialog + "-" + uuid,
         requestId: aRpOptions.id
       };
-      log('received delegate finished; telling content to close the dialog');
+      logger.log('received delegate finished; telling content to close the dialog');
       ContentInterface.sendChromeEvent(detail);
       self._removeWatchers(rpID, rpMM);
     }
 
     content.addEventListener("mozContentEvent", function getAssertion(evt) {
       let msg = evt.detail;
       if (!msg.id.match(uuid)) {
         return;
@@ -266,19 +265,19 @@ Pipe.prototype = {
             // the callbacks in the content script.  This could be either the
             // visible popup that the user interacts with, or it could be an
             // invisible frame.
             let frame = evt.detail.frame;
             let frameLoader = frame.QueryInterface(Ci.nsIFrameLoaderOwner).frameLoader;
             mm = frameLoader.messageManager;
             try {
               mm.loadFrameScript(kIdentityShimFile, true);
-              log("Loaded shim " + kIdentityShimFile + "\n");
+              logger.log("Loaded shim " + kIdentityShimFile + "\n");
             } catch (e) {
-              log("Error loading ", kIdentityShimFile, " as a frame script: ", e);
+              logger.log("Error loading ", kIdentityShimFile, " as a frame script: ", e);
             }
 
             // There are two messages that the delegate can send back: a "do
             // method" event, and a "finished" event.  We pass the do-method
             // events straight to the caller for interpretation and handling.
             // If we receive a "finished" event, then the delegate is done, so
             // we shut down the pipe and clean up.
             mm.addMessageListener(kIdentityControllerDoMethod, aMessageCallback);
@@ -291,17 +290,17 @@ Pipe.prototype = {
         case kDoneIdentityDialog + '-' + uuid:
           // Received our assertion.  The message manager callbacks will handle
           // communicating back to the IDService.  All we have to do is remove
           // this listener.
           content.removeEventListener("mozContentEvent", getAssertion);
           break;
 
         default:
-          log("ERROR - Unexpected message: id=" + msg.id + ", type=" + msg.type + ", errorMsg=" + msg.errorMsg);
+          logger.log("ERROR - Unexpected message: id=" + msg.id + ", type=" + msg.type + ", errorMsg=" + msg.errorMsg);
           break;
       }
 
     });
 
     // Tell content to open the identity iframe or trusty popup. The parameter
     // showUI signals whether user interaction is needed.  If it is, content will
     // open a dialog; if not, a hidden iframe.  In each case, BrowserID is
@@ -343,17 +342,17 @@ this.SignInToWebsiteController = {
 
   uninit: function SignInToWebsiteController_uninit() {
     Services.obs.removeObserver(this, "identity-controller-watch");
     Services.obs.removeObserver(this, "identity-controller-request");
     Services.obs.removeObserver(this, "identity-controller-logout");
   },
 
   observe: function SignInToWebsiteController_observe(aSubject, aTopic, aData) {
-    log("observe: received", aTopic, "with", aData, "for", aSubject);
+    logger.log("observe: received", aTopic, "with", aData, "for", aSubject);
     let options = null;
     if (aSubject) {
       options = aSubject.wrappedJSObject;
     }
     switch (aTopic) {
       case "identity-controller-watch":
         this.doWatch(options);
         break;
@@ -397,17 +396,17 @@ this.SignInToWebsiteController = {
           IdentityService.doLogout(aRpId);
           break;
 
         case "cancel":
           IdentityService.doCancel(aRpId);
           break;
 
         default:
-          log("WARNING: wonky method call:", message.method);
+          logger.warning("wonky method call:", message.method);
           break;
       }
     };
   },
 
   doWatch: function SignInToWebsiteController_doWatch(aRpOptions) {
     // dom prevents watch from  being called twice
     let contentOptions = {
@@ -417,30 +416,30 @@ this.SignInToWebsiteController = {
     this.pipe.communicate(aRpOptions, contentOptions,
         this._makeDoMethodCallback(aRpOptions.id));
   },
 
   /**
    * The website is requesting login so the user must choose an identity to use.
    */
   doRequest: function SignInToWebsiteController_doRequest(aRpOptions) {
-    log("doRequest", aRpOptions);
+    logger.log("doRequest", aRpOptions);
     let contentOptions = {
       message: kIdentityDelegateRequest,
       showUI: true
     };
     this.pipe.communicate(aRpOptions, contentOptions,
         this._makeDoMethodCallback(aRpOptions.id));
   },
 
   /*
    *
    */
   doLogout: function SignInToWebsiteController_doLogout(aRpOptions) {
-    log("doLogout", aRpOptions);
+    logger.log("doLogout", aRpOptions);
     let contentOptions = {
       message: kIdentityDelegateLogout,
       showUI: false
     };
     this.pipe.communicate(aRpOptions, contentOptions,
         this._makeDoMethodCallback(aRpOptions.id));
   }
 
diff --git a/b2g/components/test/unit/head_identity.js b/b2g/components/test/unit/head_identity.js
--- a/b2g/components/test/unit/head_identity.js
+++ b/b2g/components/test/unit/head_identity.js
@@ -9,35 +9,30 @@ const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "MinimalIDService",
                                   "resource://gre/modules/identity/MinimalIdentity.jsm",
                                   "IdentityService");
 
-XPCOMUtils.defineLazyModuleGetter(this,
-                                  "Logger",
-                                  "resource://gre/modules/identity/LogUtils.jsm");
-
 XPCOMUtils.defineLazyServiceGetter(this,
                                    "uuidGenerator",
                                    "@mozilla.org/uuid-generator;1",
                                    "nsIUUIDGenerator");
 
 const TEST_URL = "https://myfavoriteflan.com";
 const TEST_USER = "uumellmahaye1969@hotmail.com";
 const TEST_PRIVKEY = "i-am-a-secret";
 const TEST_CERT = "i~like~pie";
 
-// The following are utility functions for Identity testing
-
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["test"].concat(aMessageArgs));
-}
+XPCOMUtils.defineLazyGetter(this, "logger", function() {
+  Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+  return getLogger("Identity", "toolkit.identity.debug");
+});
 
 function partial(fn) {
   let args = Array.prototype.slice.call(arguments, 1);
   return function() {
     return fn.apply(this, args.concat(Array.prototype.slice.call(arguments)));
   };
 }
 
diff --git a/b2g/components/test/unit/test_signintowebsite.js b/b2g/components/test/unit/test_signintowebsite.js
--- a/b2g/components/test/unit/test_signintowebsite.js
+++ b/b2g/components/test/unit/test_signintowebsite.js
@@ -1,31 +1,25 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests for b2g/components/SignInToWebsite.jsm
 
 "use strict";
 
-XPCOMUtils.defineLazyModuleGetter(this, "MinimalIDService",
-                                  "resource://gre/modules/identity/MinimalIdentity.jsm",
+XPCOMUtils.defineLazyModuleGetter(this, "IdentityService",
+                                  "resource://gre/modules/identity/IdentityService.jsm",
                                   "IdentityService");
 
 XPCOMUtils.defineLazyModuleGetter(this, "SignInToWebsiteController",
                                   "resource://gre/modules/SignInToWebsite.jsm",
                                   "SignInToWebsiteController");
 
-Cu.import("resource://gre/modules/identity/LogUtils.jsm");
-
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["test_signintowebsite"].concat(aMessageArgs));
-}
-
 function test_overall() {
-  do_check_neq(MinimalIDService, null);
+  do_check_neq(IdentityService, null);
   run_next_test();
 }
 
 function objectContains(object, subset) {
   let objectKeys = Object.keys(object);
   let subsetKeys = Object.keys(subset);
 
   // can't have fewer keys than the subset
@@ -106,17 +100,17 @@ function test_watch() {
     let mockedDoc = mockDoc({loggedInUser: null}, function(action, params) {
       do_check_eq(action, 'ready');
       controller.uninit();
       do_test_finished();
       run_next_test();
     });
 
     controller.init({pipe: mockReceivingPipe()});
-    MinimalIDService.RP.watch(mockedDoc, {});
+    IdentityService.RP.watch(mockedDoc, {});
   });
 }
 
 function test_request_login() {
   do_test_pending();
 
   setup_test_identity("flan@food.gov", TEST_CERT, function() {
     let controller = SignInToWebsiteController;
@@ -131,18 +125,18 @@ function test_request_login() {
         do_check_eq(params, TEST_CERT);
         controller.uninit();
         do_test_finished();
         run_next_test();
       }
     ));
 
     controller.init({pipe: mockReceivingPipe()});
-    MinimalIDService.RP.watch(mockedDoc, {});
-    MinimalIDService.RP.request(mockedDoc.id, {});
+    IdentityService.RP.watch(mockedDoc, {});
+    IdentityService.RP.request(mockedDoc.id, {});
   });
 }
 
 function test_request_logout() {
   do_test_pending();
 
   setup_test_identity("flan@food.gov", TEST_CERT, function() {
     let controller = SignInToWebsiteController;
@@ -157,18 +151,18 @@ function test_request_logout() {
         do_check_eq(params, undefined);
         controller.uninit();
         do_test_finished();
         run_next_test();
       }
     ));
 
     controller.init({pipe: mockReceivingPipe()});
-    MinimalIDService.RP.watch(mockedDoc, {});
-    MinimalIDService.RP.logout(mockedDoc.id, {});
+    IdentityService.RP.watch(mockedDoc, {});
+    IdentityService.RP.logout(mockedDoc.id, {});
   });
 }
 
 function test_request_login_logout() {
   do_test_pending();
 
   setup_test_identity("unagi@food.gov", TEST_CERT, function() {
     let controller = SignInToWebsiteController;
@@ -187,19 +181,19 @@ function test_request_login_logout() {
         do_check_eq(params, undefined);
         controller.uninit();
         do_test_finished();
         run_next_test();
       }
     ));
 
     controller.init({pipe: mockReceivingPipe()});
-    MinimalIDService.RP.watch(mockedDoc, {});
-    MinimalIDService.RP.request(mockedDoc.id, {});
-    MinimalIDService.RP.logout(mockedDoc.id, {});
+    IdentityService.RP.watch(mockedDoc, {});
+    IdentityService.RP.request(mockedDoc.id, {});
+    IdentityService.RP.logout(mockedDoc.id, {});
   });
 }
 
 function test_options_pass_through() {
   do_test_pending();
 
   // An meaningless structure for testing that RP messages preserve
   // objects and their parameters as they are passed back and forth.
@@ -218,32 +212,32 @@ function test_options_pass_through() {
 
   function pipeOtherEnd(rpOptions, gaiaOptions) {
     // Ensure that every time we receive a message, our mixed
     // random params are contained in that message
     do_check_true(objectContains(rpOptions, randomMixedParams));
 
     switch (gaiaOptions.message) {
       case "identity-delegate-watch":
-        MinimalIDService.RP.request(mockedDoc.id, {});
+        IdentityService.RP.request(mockedDoc.id, {});
         break;
       case "identity-delegate-request":
-        MinimalIDService.RP.logout(mockedDoc.id, {});
+        IdentityService.RP.logout(mockedDoc.id, {});
         break;
       case "identity-delegate-logout":
         do_test_finished();
         run_next_test();
         break;
     }
   }
 
   let controller = SignInToWebsiteController;
   controller.init({pipe: mockSendingPipe(pipeOtherEnd)});
 
-  MinimalIDService.RP.watch(mockedDoc, {});
+  IdentityService.RP.watch(mockedDoc, {});
 }
 
 let TESTS = [
   test_overall,
   test_mock_doc,
   test_object_contains,
 
   test_watch,
diff --git a/b2g/components/test/unit/xpcshell.ini b/b2g/components/test/unit/xpcshell.ini
--- a/b2g/components/test/unit/xpcshell.ini
+++ b/b2g/components/test/unit/xpcshell.ini
@@ -1,11 +1,7 @@
 [DEFAULT]
-head =
-tail =
+head = head_identity.js
+tail = 
 
 [test_bug793310.js]
+[test_signintowebsite.js]
 
-[test_signintowebsite.js]
-head = head_identity.js
-tail =
-
-
diff --git a/browser/base/content/browser-identity.js b/browser/base/content/browser-identity.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/browser-identity.js
@@ -0,0 +1,146 @@
+/* -*- Mode: js2; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
+/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// This JS shim contains the callbacks to fire DOMRequest events for
+// navigator.pay API within the payment processor's scope.
+
+'use strict';
+
+let { classes: Cc, interfaces: Ci, utils: Cu } = Components;
+Cu.import('resource://gre/modules/XPCOMUtils.jsm');
+
+XPCOMUtils.defineLazyGetter(this, "logger", function() {
+  Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+  return getLogger("Identity", "toolkit.identity.debug");
+});
+
+function IdentityShim() {
+  this.isLoaded = false;
+}
+
+IdentityShim.prototype = {
+  init: function IdentityShim_init() {
+    addMessageListener('identity-delegate-watch', this);
+    addMessageListener('identity-delegate-request', this);
+    addMessageListener('identity-delegate-logout', this);
+    sendAsyncMessage('identity-delegate-loaded');
+    logger.log('sent identity-delegate-loaded');
+    this.isLoaded = true;
+  },
+
+  uninit: function IdentityShim_uninit() {
+    if (this.isLoaded) {
+      removeMessageListener('identity-delegate-watch', this);
+      removeMessageListener('identity-delegate-request', this);
+      removeMessageListener('identity-delegate-logout', this);
+      sendAsyncMessage('identity-delegate-complete', null);
+      logger.log('sent identity-delegate-complete');
+      this.isLoaded = false;
+    }
+  },
+
+  receiveMessage: function IdentityShim_receiveMessage(aMessage) {
+    switch (aMessage.name) {
+      case 'identity-delegate-watch':
+        this.watch(aMessage.json);
+        break;
+      case 'identity-delegate-request':
+        this.request(aMessage.json);
+        break;
+      case 'identity-delegate-logout':
+        this.logout(aMessage.json);
+        break;
+      default:
+        //logger.error("received unexpected message:", aMessage.name);
+        break;
+    }
+  },
+
+  _identityDoMethod: function IdentityShim__identityDoMethod(message) {
+    sendAsyncMessage('identity-service-doMethod', message);
+  },
+
+  _close: function IdentityShim__close() {
+    this.uninit();
+  },
+
+  watch: function IdentityShim_watch(options) {
+    logger.log('doInternalWatch: isLoaded:', this.isLoaded, 'options:', options);
+    if (options) {
+      let BrowserID = content.wrappedJSObject.BrowserID;
+      let callback = function(aParams, aInternalParams) {
+        this._identityDoMethod(aParams);
+        if (aParams.method === 'ready') {
+          this._close();
+        }
+      }.bind(this);
+
+      BrowserID.internal.watch(
+        callback,
+        JSON.stringify(options),
+        function(...things) {
+          logger.log('internal watch returned:', things);
+        }
+      );
+    }
+  },
+
+  request: function IdentityShim_request(options) {
+    logger.log('doInternalRequest: isLoaded:', this.isLoaded, 'options:', options);
+    if (options) {
+      var stringifiedOptions = JSON.stringify(options);
+      let callback = function(assertion, internalParams) {
+        internalParams = internalParams || {};
+        if (assertion) {
+          logger.log("got assertion");
+          this._identityDoMethod({
+            method: 'login',
+            assertion: assertion,
+            _internal: options._internal,
+            _internalParams: internalParams});
+        }
+        this._close();
+      }.bind(this);
+
+      content.wrappedJSObject.BrowserID.internal.get(
+        options.origin,
+        callback,
+        stringifiedOptions
+      );
+    }
+  },
+
+  logout: function IdentityShim_logout(options) {
+    logger.log('doInternalLogout: isLoaded:', this.isLoaded, 'options:', options);
+    if (options) {
+      let BrowserID = content.wrappedJSObject.BrowserID;
+      let callback = function() {
+        this._identityDoMethod({method: 'logout', _internal: options._internal});
+        this._close();
+      }.bind(this);
+
+      BrowserID.internal.logout(options.origin, callback);
+    }
+  }
+};
+
+this.shim = null;
+
+addEventListener('DOMContentLoaded', function(e) {
+  content.addEventListener('load', function(e) {
+    logger.log('content loaded');
+    this.shim = new IdentityShim();
+    this.shim.init();
+  });
+});
+
+content.addEventListener('beforeunload', function(e) {
+  if (this.shim) {
+    this.shim.uninit();
+  }
+});
+
+
diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -262,36 +262,16 @@ panel[noactions] > richlistbox > richlis
 #urlbar[pageproxystate="invalid"] > #urlbar-icons > .urlbar-icon:not(#go-button),
 #urlbar[pageproxystate="valid"] > #urlbar-icons > #go-button,
 #urlbar[pageproxystate="invalid"][focused="true"] > #urlbar-go-button ~ toolbarbutton,
 #urlbar[pageproxystate="valid"] > #urlbar-go-button,
 #urlbar:not([focused="true"]) > #urlbar-go-button {
   visibility: collapse;
 }
 
-#urlbar[pageproxystate="invalid"] > #identity-box > #identity-icon-labels {
-  visibility: collapse;
-}
-
-#urlbar[pageproxystate="invalid"] > #identity-box {
-  pointer-events: none;
-}
-
-#identity-icon-labels {
-  max-width: 18em;
-}
-
-#identity-icon-country-label {
-  direction: ltr;
-}
-
-#identity-box.verifiedIdentity > #identity-icon-labels > #identity-icon-label {
-  -moz-margin-end: 0.25em !important;
-}
-
 #wrapper-search-container > #search-container > #searchbar > .searchbar-textbox > .autocomplete-textbox-container > .textbox-input-box > html|*.textbox-input {
   visibility: hidden;
 }
 
 /* ::::: Unified Back-/Forward Button ::::: */
 #back-button > .toolbarbutton-menu-dropmarker,
 #forward-button > .toolbarbutton-menu-dropmarker {
   display: none;
@@ -377,26 +357,16 @@ window[chromehidden~="toolbar"] toolbar:
 #historySwipeAnimationCurrentPage {
   background-image: -moz-element(#historySwipeAnimationCurrentPageSnapshot);
 }
 
 #historySwipeAnimationNextPage {
   background-image: -moz-element(#historySwipeAnimationNextPageSnapshot);
 }
 
-/* Identity UI */
-#identity-popup-content-box.unknownIdentity > #identity-popup-connectedToLabel ,
-#identity-popup-content-box.unknownIdentity > #identity-popup-runByLabel ,
-#identity-popup-content-box.unknownIdentity > #identity-popup-content-host ,
-#identity-popup-content-box.unknownIdentity > #identity-popup-content-owner ,
-#identity-popup-content-box.verifiedIdentity > #identity-popup-connectedToLabel2 ,
-#identity-popup-content-box.verifiedDomain > #identity-popup-connectedToLabel2 {
-  display: none;
-}
-
 /*  Full Screen UI */
 
 #fullscr-toggler {
   height: 1px;
   background: black;
 }
 
 #full-screen-warning-container {
diff --git a/browser/base/content/urlbarBindings.xml b/browser/base/content/urlbarBindings.xml
--- a/browser/base/content/urlbarBindings.xml
+++ b/browser/base/content/urlbarBindings.xml
@@ -1117,264 +1117,70 @@
       <method name="onDownloadEnded">
         <body><![CDATA[
           this.updateProgress();
         ]]></body>
       </method>
     </implementation>
   </binding>
 
-  <binding id="identity-request-notification" extends="chrome://global/content/bindings/notification.xml#popup-notification">
-    <content align="start">
+  <binding 
+    id="identity-request-notification" 
+    extends="chrome://global/content/bindings/notification.xml#popup-notification">
 
-      <xul:image class="popup-notification-icon"
-                 xbl:inherits="popupid,src=icon"/>
+    <content>
+      <panel id="persona-container" anonid="persona-container" flex="1" />
+    </content>
 
-      <xul:vbox flex="1">
-        <xul:vbox anonid="identity-deck">
-          <xul:vbox flex="1" pack="center"> <!-- 1: add an email -->
-            <html:input type="email" anonid="email" required="required" size="30"/>
-            <xul:description anonid="newidentitydesc"/>
-            <xul:spacer flex="1"/>
-            <xul:label class="text-link custom-link small-margin" anonid="chooseemail" hidden="true"/>
-          </xul:vbox>
-          <xul:vbox flex="1" hidden="true"> <!-- 2: choose an email -->
-            <xul:description anonid="chooseidentitydesc"/>
-            <xul:radiogroup anonid="identities">
-            </xul:radiogroup>
-            <xul:label class="text-link custom-link" anonid="newemail"/>
-          </xul:vbox>
-        </xul:vbox>
-        <xul:hbox class="popup-notification-button-container"
-                  pack="end" align="center">
-          <xul:label anonid="tos" class="text-link" hidden="true"/>
-          <xul:label anonid="privacypolicy" class="text-link" hidden="true"/>
-          <xul:spacer flex="1"/>
-          <xul:image anonid="throbber" src="chrome://browser/skin/tabbrowser/loading.png"
-                     style="visibility:hidden" width="16" height="16"/>
-          <xul:button anonid="button"
-                      type="menu-button"
-                      class="popup-notification-menubutton"
-                      xbl:inherits="oncommand=buttoncommand,label=buttonlabel,accesskey=buttonaccesskey">
-            <xul:menupopup anonid="menupopup"
-                           xbl:inherits="oncommand=menucommand">
-              <children/>
-              <xul:menuitem class="menuitem-iconic popup-notification-closeitem"
-                            label="&closeNotificationItem.label;"
-                            xbl:inherits="oncommand=closeitemcommand"/>
-            </xul:menupopup>
-          </xul:button>
-        </xul:hbox>
-      </xul:vbox>
-      <xul:vbox pack="start">
-        <xul:toolbarbutton anonid="closebutton"
-                           class="messageCloseButton popup-notification-closebutton tabbable"
-                           xbl:inherits="oncommand=closebuttoncommand"
-                           tooltiptext="&closeNotification.tooltip;"/>
-      </xul:vbox>
-    </content>
-    <implementation>
+    <implementation implements="nsIObserver, nsIDOMEventListener">
       <constructor><![CDATA[
-        // this.notification.options.identity is used to pass identity-specific info to the binding
-        let origin = this.identity.origin
+        dump(" ** in identity xul constructor\n");
+        this.complete = false;
 
-        // Populate text
-        this.emailField.placeholder = gNavigatorBundle.
-                                      getString("identity.newIdentity.email.placeholder");
-        this.newIdentityDesc.textContent = gNavigatorBundle.getFormattedString(
-                                             "identity.newIdentity.description", [origin]);
-        this.chooseIdentityDesc.textContent = gNavigatorBundle.getFormattedString(
-                                                "identity.chooseIdentity.description", [origin]);
+        // Mark outgoing messages with the id of the caller
+        this.messageSubject = Components.classes["@mozilla.org/supports-string;1"]
+          .createInstance(Components.interfaces.nsISupportsString);
+        this.messageSubject.data = this.notification.options.context.id;
 
-        // Show optional terms of service and privacy policy links
-        this._populateLink(this.identity.termsOfService, "tos", "identity.termsOfService");
-        this._populateLink(this.identity.privacyPolicy, "privacypolicy", "identity.privacyPolicy");
+        // adopt the iframe and display it in the panel
+        // XXX this does not work in FF3.6 or older
+        let personaIframe = this.notification.options.context.iframe;
+        let node = document.adoptNode(personaIframe);
+        let panel = document.getAnonymousElementByAttribute(this, "anonid", "persona-container");
+        panel.appendChild(node);
 
-        // Populate the list of identities to choose from. The origin is used to provide
-        // better suggestions.
-        let identities = this.SignInToWebsiteUX.getIdentitiesForSite(origin);
+        // The dimensions of the panel are modified dynamically by
+        // SignInToWebsite.jsm.
 
-        this._populateIdentityList(identities);
+        dump(" ** Persona host iframe attached to xul panel\n");
 
-        if (typeof this.step == "undefined") {
-          // First opening of this notification
-          // Show the add email pane (0) if there are no existing identities otherwise show the list
-          this.step = "result" in identities && identities.result.length ? 1 : 0;
-        } else {
-          // Already opened so restore previous state
-          if (this.identity.typedEmail) {
-            this.emailField.value = this.identity.typedEmail;
-          }
-          if (this.identity.selected) {
-            // If the user already chose an identity then update the UI to reflect that
-            this.onIdentitySelected();
-          }
-          // Update the view for the step
-          this.step = this.step;
-        }
+        // Listen to messages from SignInToWebsite.jsm
+        Services.obs.addObserver(this, "identity-delegate-ui-close", false);
 
-        // Fire notification with the chosen identity when main button is clicked
-        this.button.addEventListener("command", this._onButtonCommand.bind(this), true);
-
-        // Do the same if enter is pressed in the email field
-        this.emailField.addEventListener("keypress", function emailFieldKeypress(aEvent) {
-          if (aEvent.keyCode != aEvent.DOM_VK_RETURN)
-            return;
-          this._onButtonCommand(aEvent);
-        }.bind(this));
-
-        this.addEmailLink.value = gNavigatorBundle.getString("identity.newIdentity.label");
-        this.addEmailLink.accessKey = gNavigatorBundle.getString("identity.newIdentity.accessKey");
-        this.addEmailLink.addEventListener("click", function addEmailClick(evt) {
-          this.step = 0;
-        }.bind(this));
-
-        this.chooseEmailLink.value = gNavigatorBundle.getString("identity.chooseIdentity.label");
-        this.chooseEmailLink.hidden = !("result" in identities && identities.result.length);
-        this.chooseEmailLink.addEventListener("click", function chooseEmailClick(evt) {
-          this.step = 1;
-        }.bind(this));
-
-        this.emailField.addEventListener("blur", function onEmailBlur() {
-          this.identity.typedEmail = this.emailField.value;
-        }.bind(this));
+        // message back to SignInToWebsite that we've started
+        // and the flow with the given id can go ahead
+        // XXX we might not need this
+        Services.obs.notifyObservers(this.messageSubject, "identity-delegate-ui-open", null);
       ]]></constructor>
 
-      <field name="SignInToWebsiteUX" readonly="true">
-        let sitw = {};
-        Components.utils.import("resource:///modules/SignInToWebsite.jsm", sitw);
-        sitw.SignInToWebsiteUX;
-      </field>
+      <destructor><![CDATA[
+        if (!this.complete) {
+          Services.obs.notifyObservers(this.messageSubject, "identity-delegate-canceled", null);
+        }
+        Services.obs.removeObserver(this, "identity-delegate-ui-close", false);
+      ]]></destructor>
 
-      <field name="newIdentityDesc" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "newidentitydesc");
-      </field>
-
-      <field name="chooseIdentityDesc" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "chooseidentitydesc");
-      </field>
-
-      <field name="identityList" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "identities");
-      </field>
-
-      <field name="emailField" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "email");
-      </field>
-
-      <field name="addEmailLink" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "newemail");
-      </field>
-
-      <field name="chooseEmailLink" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "chooseemail");
-      </field>
-
-      <field name="throbber" readonly="true">
-        document.getAnonymousElementByAttribute(this, "anonid", "throbber");
-      </field>
-
-      <field name="identity" readonly="true">
-        this.notification.options.identity;
-      </field>
-
-      <!-- persist the state on the identity object so we can re-create the
-           notification state upon re-opening -->
-      <property name="step">
-        <getter>
-          return this.identity.step;
-        </getter>
-        <setter><![CDATA[
-          let deck = document.getAnonymousElementByAttribute(this, "anonid", "identity-deck");
-          for (let i = 0; i < deck.children.length; i++) {
-            deck.children[i].hidden = (val != i);
-          }
-          this.identity.step = val;
-          switch (val) {
-            case 0:
-              this.emailField.focus();
-              break;
-          }]]>
-        </setter>
-      </property>
-
-      <method name="onIdentitySelected">
+      <method name="observe">
+        <parameter name="aSubject"/>
+        <parameter name="aTopic"/>
+        <parameter name="aData"/>
         <body><![CDATA[
-          this.throbber.style.visibility = "visible";
-          this.button.disabled = true;
-          this.emailField.value = this.identity.selected
-          this.emailField.disabled = true;
-          this.identityList.disabled = true;
-        ]]></body>
-      </method>
-
-      <method name="_populateLink">
-        <parameter name="aURL"/>
-        <parameter name="aLinkId"/>
-        <parameter name="aStringId"/>
-        <body><![CDATA[
-          if (aURL) {
-            // Show optional link to aURL
-            let link = document.getAnonymousElementByAttribute(this, "anonid", aLinkId);
-            link.value = gNavigatorBundle.getString(aStringId);
-            link.href = aURL;
-            link.hidden = false;
-          }
-        ]]></body>
-      </method>
-
-      <method name="_populateIdentityList">
-        <parameter name="aIdentities"/>
-        <body><![CDATA[
-          let foundLastUsed = false;
-          let lastUsed = this.identity.selected || aIdentities.lastUsed;
-          for (let id in aIdentities.result) {
-            let label = aIdentities.result[id];
-            let opt = this.identityList.appendItem(label);
-            if (label == lastUsed) {
-              this.identityList.selectedItem = opt;
-              foundLastUsed = true;
-            }
-          }
-          if (!foundLastUsed) {
-            this.identityList.selectedIndex = -1;
-          }
-        ]]></body>
-      </method>
-
-      <method name="_onButtonCommand">
-        <parameter name="aEvent"/>
-        <body><![CDATA[
-          if (aEvent.target != aEvent.currentTarget)
-            return;
-          let chosenId;
-          switch (this.step) {
-            case 0:
-              aEvent.stopPropagation();
-              if (!this.emailField.validity.valid) {
-                this.emailField.focus();
-                return;
-              }
-              chosenId = this.emailField.value;
-              break;
-            case 1:
-              aEvent.stopPropagation();
-              let selectedItem = this.identityList.selectedItem
-              chosenId = selectedItem ? selectedItem.label : null;
-              if (!chosenId)
-                return;
-              break;
-            default:
-              throw new Error("Unknown case");
-              return;
-          }
-          // Actually select the identity
-          this.SignInToWebsiteUX.selectIdentity(this.identity.rpId, chosenId);
-          this.identity.selected = chosenId;
-          this.onIdentitySelected();
+          // The only message we observe is identity-delegate-ui-close
+          this.complete = true;
+          this.notification.remove();
         ]]></body>
       </method>
 
     </implementation>
   </binding>
 
   <binding id="center-item">
     <content align="center">
diff --git a/browser/base/jar.mn b/browser/base/jar.mn
--- a/browser/base/jar.mn
+++ b/browser/base/jar.mn
@@ -53,16 +53,17 @@ browser.jar:
         content/browser/abouthealthreport/abouthealth.css     (content/abouthealthreport/abouthealth.css)
 #endif
         content/browser/aboutRobots-icon.png          (content/aboutRobots-icon.png)
         content/browser/aboutRobots-widget-left.png   (content/aboutRobots-widget-left.png)
         content/browser/aboutSocialError.xhtml        (content/aboutSocialError.xhtml)
 *       content/browser/browser.css                   (content/browser.css)
 *       content/browser/browser.js                    (content/browser.js)
 *       content/browser/browser.xul                   (content/browser.xul)
+        content/browser/browser-identity.js           (content/browser-identity.js)
 *       content/browser/browser-tabPreviews.xml       (content/browser-tabPreviews.xml)
         content/browser/content.js                    (content/content.js)
         content/browser/newtab/newTab.xul             (content/newtab/newTab.xul)
 *       content/browser/newtab/newTab.js              (content/newtab/newTab.js)
         content/browser/newtab/newTab.css             (content/newtab/newTab.css)
         content/browser/newtab/preload.xhtml          (content/newtab/preload.xhtml)
 *       content/browser/pageinfo/pageInfo.xul         (content/pageinfo/pageInfo.xul)
         content/browser/pageinfo/pageInfo.js          (content/pageinfo/pageInfo.js)
diff --git a/browser/modules/SignInToWebsite.jsm b/browser/modules/SignInToWebsite.jsm
--- a/browser/modules/SignInToWebsite.jsm
+++ b/browser/modules/SignInToWebsite.jsm
@@ -1,247 +1,451 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-"use strict";
+'use strict';
 
-this.EXPORTED_SYMBOLS = ["SignInToWebsiteUX"];
+this.EXPORTED_SYMBOLS = ['SignInToWebsiteUX', 'HostFrame', 'Pipe'];
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import('resource://gre/modules/Services.jsm');
+Cu.import('resource://gre/modules/XPCOMUtils.jsm');
+Cu.import('resource://gre/modules/identity/IdentityUtils.jsm');
 
-XPCOMUtils.defineLazyModuleGetter(this, "IdentityService",
-                                  "resource://gre/modules/identity/Identity.jsm");
+const kInteractivePersonaIframe = 'https://picl.personatest.org/sign_in#NATIVE';
+const kHiddenPersonaIframe = 'https://picl.personatest.org/communication_iframe';
 
-XPCOMUtils.defineLazyModuleGetter(this, "Logger",
-                                  "resource://gre/modules/identity/LogUtils.jsm");
+const PANEL_MIN_HEIGHT = 440;
+const PANEL_MIN_WIDTH = 300;
 
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["SignInToWebsiteUX"].concat(aMessageArgs));
+XPCOMUtils.defineLazyModuleGetter(this, 'IdentityService',
+                                  'resource://gre/modules/identity/IdentityService.jsm');
+
+XPCOMUtils.defineLazyGetter(this, "logger", function() {
+  Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+  return getLogger("Identity", "toolkit.identity.debug");
+});
+
+/**
+ * Ripped off from the resize watcher in base/content/browser-social.js
+ */
+
+function sizePanelToContent(iframe) {
+  // FIXME: bug 764787: Maybe we can use nsIDOMWindowUtils.getRootBounds() here?
+  let doc = iframe.contentDocument;
+  if (!doc || !doc.body) {
+    return;
+  }
+  let body = doc.body;
+
+  // offsetHeight/Width don't include margins, so account for that.
+  let cs = doc.defaultView.getComputedStyle(body);
+  let computedHeight = parseInt(cs.marginTop) + body.offsetHeight + parseInt(cs.marginBottom);
+  let height = Math.max(computedHeight, PANEL_MIN_HEIGHT);
+  let computedWidth = parseInt(cs.marginLeft) + body.offsetWidth + parseInt(cs.marginRight);
+  let width = Math.max(computedWidth, PANEL_MIN_WIDTH);
+
+  // The panel can only resize vertically; otherwise, we would have to
+  // compensate for leftward or rightward shifts here
+  iframe.style.height = height + "px";
+  iframe.style.width = width + "px";
 }
 
-this.SignInToWebsiteUX = {
+function ResizeWatcher(iframe) {
+  this._mutationObserver = null;
+  this._iframe = iframe;
 
-  init: function SignInToWebsiteUX_init() {
+  this.start();
+}
 
-    /*
-     * bug 793906 - temporarily disabling desktop UI so we can
-     * focus on b2g without worrying about desktop as well
-     *
-    Services.obs.addObserver(this, "identity-request", false);
-    Services.obs.addObserver(this, "identity-auth", false);
-    Services.obs.addObserver(this, "identity-auth-complete", false);
-    Services.obs.addObserver(this, "identity-login-state-changed", false);
-     */
+ResizeWatcher.prototype = {
+  start: function ResizeWatcher_start() {
+    this.stop(); // just in case...
+    let doc = this._iframe.contentDocument;
+
+    this._mutationObserver = new this._iframe.contentWindow.MutationObserver(
+      function(mutations) {
+        sizePanelToContent(this._iframe);
+      }.bind(this));
+
+    // Observe anything that causes the size to change.
+    let config = {
+      attributes: true,
+      characterData: true,
+      childList: true,
+      subtree: true
+    };
+
+    this._mutationObserver.observe(doc, config);
+
+    // and since this may be setup after the load event has fired we do an
+    // initial resize now.
+    sizePanelToContent(this._iframe);
   },
 
-  uninit: function SignInToWebsiteUX_uninit() {
-    /*
-     * As above:
-     * bug 793906 - temporarily disabling desktop UI so we can
-     * focus on b2g without worrying about desktop as well
-     *
-    Services.obs.removeObserver(this, "identity-request");
-    Services.obs.removeObserver(this, "identity-auth");
-    Services.obs.removeObserver(this, "identity-auth-complete");
-    Services.obs.removeObserver(this, "identity-login-state-changed");
-     */
+  stop: function ResizeWatcher_stop() {
+    if (this._mutationObserver) {
+      try {
+        this._mutationObserver.disconnect();
+      } catch (ex) {
+        // may get "TypeError: can't access dead object" which seems strange,
+        // but doesn't seem to indicate a real problem, so ignore it...
+      }
+      this._mutationObserver = null;
+    }
+  }
+};
+
+/**
+ * Return the chrome window and <browser> for the given outer window ID.
+ */
+function getUIForWindowID(aWindowId) {
+  let someWindow = Services.wm.getMostRecentWindow('navigator:browser');
+  if (!someWindow) {
+    logger.error("no window");
+    return {};
+  }
+
+  let windowUtils = someWindow.QueryInterface(Ci.nsIInterfaceRequestor)
+                              .getInterface(Ci.nsIDOMWindowUtils);
+  let content = windowUtils.getOuterWindowWithId(aWindowId);
+
+  if (content) {
+    let browser = content.QueryInterface(Ci.nsIInterfaceRequestor)
+                         .getInterface(Ci.nsIWebNavigation)
+                         .QueryInterface(Ci.nsIDocShell).chromeEventHandler;
+    //let browser = someWindow.gBrowser;
+    let chromeWin = browser.ownerDocument.defaultView;
+
+    return {
+      content: content,
+      browser: browser,
+      chromeWin: chromeWin
+    };
+  }
+  logger.error("no content");
+
+  return {};
+}
+
+function requestUI(aContext) {
+  logger.log('requestUI for windowId', aContext.id);
+  let UI = getUIForWindowID(aContext.id);
+
+  // message is not shown in the UI but is required
+  let mainAction = {
+    label: UI.chromeWin.gNavigatorBundle.getString('identity.next.label'),
+    accessKey: UI.chromeWin.gNavigatorBundle.getString('identity.next.accessKey'),
+    callback: function() {} // required
+  };
+  let secondaryActions = [];
+  let options = {
+    context: aContext
+  };
+
+  UI.chromeWin.PopupNotifications.show(UI.browser,
+                                       'identity-request', aContext.id,
+                                       'identity-notification-icon', mainAction,
+                                       [], options);
+}
+
+this.HostFrame = function HostFrame() {
+  this._iframe = null;
+  this._resizeWatcher = null;
+}
+
+HostFrame.prototype = {
+  /*
+   * getIframe - adds iframe to aOptions
+   */
+  getIframe: function HostFrame_getIframe(aOptions, aCallback) {
+    if (this._gotIframe) {
+      logger.error("Can only get iframe once with HostFrame helper");
+      return;
+    }
+
+    this._createIframe(aOptions);
+    let subject = {
+      id: aOptions.id
+    }
+    if (typeof aCallback === 'function') {
+      aCallback();
+    } else {
+      logger.error("No callback was given to getIframe");
+    }
   },
 
-  observe: function SignInToWebsiteUX_observe(aSubject, aTopic, aData) {
-    log("observe: received", aTopic, "with", aData, "for", aSubject);
-    let options = null;
-    if (aSubject) {
-      options = aSubject.wrappedJSObject;
+  cleanUp: function HostFrame_cleanUp() {
+    if (this._resizeWatcher) {
+      this._resizeWatcher.stop();
     }
-    switch(aTopic) {
-      case "identity-request":
-        this.requestLogin(options);
+  },
+
+  _createIframe: function HostFrame_createIframe(aOptions) {
+    let hiddenDoc = Services.appShell.hiddenDOMWindow.document;
+    this._iframe = hiddenDoc.createElementNS('http://www.w3.org/1999/xhtml', 'iframe');
+
+    this._iframe.setAttribute('mozbrowser', true);
+    this._iframe.setAttribute('mozframetype', 'content');
+    this._iframe.setAttribute('type', 'content');
+    this._iframe.setAttribute('remote', true);
+    this._iframe.setAttribute('id', 'persona-host-frame');
+    this._iframe.setAttribute('src', aOptions.src);
+
+    // implement a dynamic resize watcher a la Social API
+    this._iframe.style.height = "440px";
+    this._iframe.style.width = "300px";
+
+    aOptions.iframe = this._iframe;
+
+    if (!!aOptions.showUI) {
+      // synchronous, so we can call _injectShim below with no race condition
+      requestUI(aOptions);
+      this._resizeWatcher = new ResizeWatcher(this._iframe);
+    } else {
+      hiddenDoc.documentElement.appendChild(this._iframe);
+    }
+    this._injectShim(this._iframe);
+  },
+
+  _injectShim: function HostFrame_injectShim(aIframe) {
+    let mm = aIframe.QueryInterface(Ci.nsIFrameLoaderOwner).frameLoader.messageManager;
+    logger.log("injecting browser-identity.js shim");
+    mm.loadFrameScript('chrome://browser/content/browser-identity.js', true);
+  }
+};
+
+this.Pipe = function Pipe(aOptions, aController) {
+  this.options = aOptions;
+  this.controller = aController;
+  this.mm = null;
+  this._closed = false;
+  return this;
+}
+
+Pipe.prototype = {
+  observe: function pipe_observe(aSubject, aTopic, aData) {
+    logger.log('pipe observed', aTopic);
+    switch (aTopic) {
+      case 'identity-delegate-canceled':
+        this._close();
+        this.controller.serviceDoMethod({method: 'cancel'}, this.options.id);
         break;
-      case "identity-auth":
-        this._openAuthenticationUI(aData, options);
-        break;
-      case "identity-auth-complete":
-        this._closeAuthenticationUI(aData);
-        break;
-      case "identity-login-state-changed":
-        let emailAddress = aData;
-        if (emailAddress) {
-          this._removeRequestUI(options);
-          this._showLoggedInUI(emailAddress, options);
-        } else {
-          this._removeLoggedInUI(options);
-        }
-        break;
+
       default:
-        Logger.reportError("SignInToWebsiteUX", "Unknown observer notification:", aTopic);
+        logger.error('pipe observed unexpected topic: ' + aTopic);
         break;
     }
   },
 
-  /**
-   * The website is requesting login so the user must choose an identity to use.
-   */
-  requestLogin: function SignInToWebsiteUX_requestLogin(aOptions) {
-    let windowID = aOptions.rpId;
-    log("requestLogin", aOptions);
-    let [chromeWin, browserEl] = this._getUIForWindowID(windowID);
+  _close: function pipe__delegateClose() {
+    this._closed = true;
+    Services.obs.removeObserver(this, 'identity-delegate-canceled');
+    if (this.mm) {
+      this.mm.removeMessageListener('identity-service-doMethod', this._serviceDoMethod);
+      this.mm.removeMessageListener('identity-delegate-complete', this._delegateComplete);
+      this.mm.removeMessageListener('identity-delegate-loaded', this._delegateLoaded);
+    }
+    let subject = Cc['@mozilla.org/supports-string;1'].createInstance(Ci.nsISupportsString);
+    subject.data = this.options.id;
+    Services.obs.notifyObservers(subject, 'identity-delegate-ui-close', null);
 
-    // message is not shown in the UI but is required
-    let message = aOptions.origin;
-    let mainAction = {
-      label: chromeWin.gNavigatorBundle.getString("identity.next.label"),
-      accessKey: chromeWin.gNavigatorBundle.getString("identity.next.accessKey"),
-      callback: function() {}, // required
-    };
-    let options = {
-      identity: {
-        origin: aOptions.origin,
-      },
-    };
-    let secondaryActions = [];
-
-    // add some extra properties to the notification to store some identity-related state
-    for (let opt in aOptions) {
-      options.identity[opt] = aOptions[opt];
+    if (typeof this.options.onComplete === 'function') {
+      this.options.onComplete();
     }
-    log("requestLogin: rpId: ", options.identity.rpId);
-
-    chromeWin.PopupNotifications.show(browserEl, "identity-request", message,
-                                      "identity-notification-icon", mainAction,
-                                      [], options);
   },
 
-  /**
-   * Get the list of possible identities to login to the given origin.
-   */
-  getIdentitiesForSite: function SignInToWebsiteUX_getIdentitiesForSite(aOrigin) {
-    return IdentityService.RP.getIdentitiesForSite(aOrigin);
+  _delegateLoaded: function pipe__delegateLoaded() {
+    this.mm.sendAsyncMessage(this.options.message, this.options.rpOptions);
+    // XXX maybe here ??
+    //this.resizer = new ResizeWatcher();
+    //this.resizer.start( ... );
   },
 
-  /**
-   * User chose a new or existing identity from the doorhanger after a request() call
-   */
-  selectIdentity: function SignInToWebsiteUX_selectIdentity(aRpId, aIdentity) {
-    log("selectIdentity: rpId: ", aRpId, " identity: ", aIdentity);
-    IdentityService.selectIdentity(aRpId, aIdentity);
+  _delegateComplete: function pipe__delegateComplete() {
+    this._close();
   },
 
-  // Private
+  _serviceDoMethod: function pipe__doMethod(aMethodOptions) {
+    let message = aMethodOptions.json;
+    if (typeof message === 'string') {
+      try {
+        message = JSON.parse(message);
+      } catch (err) {
+        logger.error('Bad json message: ' + message);
+        return;
+      }
+    }
+    this.controller.serviceDoMethod(message, this.options.id);
+  },
 
-  /**
-   * Return the chrome window and <browser> for the given outer window ID.
-   */
-  _getUIForWindowID: function(aWindowID) {
-    let someWindow = Services.wm.getMostRecentWindow("navigator:browser");
-    if (!someWindow) {
-      Logger.reportError("SignInToWebsiteUX", "no window");
-      return [null, null];
+  communicate: function pipe_communicate() {
+    if (this._closed) {
+      logger.error('Cannot communicate with persona frame; pipe already closed');
+      return;
+    }
+    Services.obs.addObserver(this, 'identity-delegate-canceled', false);
+
+    let frameLoader = this.options.iframe.QueryInterface(Ci.nsIFrameLoaderOwner).frameLoader;
+    if (frameLoader) {
+      this.mm = frameLoader.messageManager;
+      this.mm.addMessageListener('identity-service-doMethod', this._serviceDoMethod.bind(this));
+      this.mm.addMessageListener('identity-delegate-loaded', this._delegateLoaded.bind(this));
+      this.mm.addMessageListener('identity-delegate-complete', this._delegateComplete.bind(this));
+    } else {
+      logger.error('FrameLoader unavailable; Frame did not get attached properly?');
+    }
+  }
+};
+
+this.SignInToWebsiteUX = {
+  init: function SignInToWebsiteUX_init(pipeConstructor) {
+    this.PipeConstructor = pipeConstructor || Pipe;
+    this.contexts = {};
+    Services.obs.addObserver(this, 'identity-controller-watch', false);
+    Services.obs.addObserver(this, 'identity-controller-request', false);
+    Services.obs.addObserver(this, 'identity-controller-logout', false);
+    Services.obs.addObserver(this, 'identity-controller-canceled', false);
+  },
+
+  uninit: function SignInToWebsiteUX_uninit() {
+    Services.obs.removeObserver(this, 'identity-controller-watch');
+    Services.obs.removeObserver(this, 'identity-controller-request');
+    Services.obs.removeObserver(this, 'identity-controller-logout');
+    Services.obs.removeObserver(this, 'identity-controller-canceled');
+  },
+
+  observe: function SignInToWebsiteUX_observe(aSubject, aTopic, aData) {
+    logger.log('controller observed:', aTopic);
+    // XXX need to detect page unload of any of our flows
+    // XXX we get strings from xul, and objects from elsewhere
+    let rpOptions = {};
+    if (aSubject) {
+      if (aSubject.wrappedJSObject) {
+        rpOptions = aSubject.wrappedJSObject;
+      } else {
+        rpOptions = {id: aSubject.QueryInterface(Ci.nsISupportsString).data};
+      }
+    }
+    if (!rpOptions.id) {
+      logger.error('Got a message with no RP id');
+      return;
     }
 
-    let windowUtils = someWindow.QueryInterface(Ci.nsIInterfaceRequestor)
-                                .getInterface(Ci.nsIDOMWindowUtils);
-    let content = windowUtils.getOuterWindowWithId(aWindowID);
+    let rpId = rpOptions.id;
+    let UI = getUIForWindowID(rpId);
 
-    if (content) {
-      let browser = content.QueryInterface(Ci.nsIInterfaceRequestor)
-                           .getInterface(Ci.nsIWebNavigation)
-                           .QueryInterface(Ci.nsIDocShell).chromeEventHandler;
-      let chromeWin = browser.ownerDocument.defaultView;
-      return [chromeWin, browser];
+    let options = {
+      id: rpOptions.id,
+      rpOptions: rpOptions
+    };
+
+    switch (aTopic) {
+      case 'identity-controller-watch':
+        this.doWatch(options);
+        break;
+
+      case 'identity-controller-request':
+        this.doRequest(options);
+        break;
+
+      case 'identity-controller-logout':
+        this.doLogout(options);
+        break;
+
+      default:
+        logger.error('SignInToWebsiteUX', 'Unknown observer notification:', aTopic);
+        break;
     }
-    Logger.reportError("SignInToWebsiteUX", "no content");
-
-    return [null, null];
   },
 
-  /**
-   * Open UI with a content frame displaying aAuthURI so that the user can authenticate with their
-   * IDP.  Then tell Identity.jsm the identifier for the window so that it knows that the DOM API
-   * calls are for this authentication flow.
-   */
-  _openAuthenticationUI: function _openAuthenticationUI(aAuthURI, aContext) {
-    // Open a tab/window with aAuthURI with an identifier (aID) attached so that the DOM APIs know this is an auth. window.
-    let chromeWin = Services.wm.getMostRecentWindow('navigator:browser');
-    let features = "chrome=false,width=640,height=480,centerscreen,location=yes,resizable=yes,scrollbars=yes,status=yes";
-    log("aAuthURI: ", aAuthURI);
-    let authWin = Services.ww.openWindow(chromeWin, "about:blank", "", features, null);
-    let windowID = authWin.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
-    log("authWin outer id: ", windowID);
+  serviceDoMethod: function SignInToWebsiteUX_doMethod(aMessage, aId) {
+    logger.log('serviceDoMethod received:', aMessage);
+    switch (aMessage.method) {
+      case 'ready':
+        IdentityService.doReady(aId);
+        break;
 
-    let provId = aContext.provId;
-    // Tell the ID service about the id before loading the url
-    IdentityService.IDP.setAuthenticationFlow(windowID, provId);
+      case 'login':
+        if (aMessage._internalParams) {
+          IdentityService.doLogin(aId, aMessage.assertion, aMessage._internalParams);
+        } else {
+          IdentityService.doLogin(aId, aMessage.assertion);
+        }
+        break;
 
-    authWin.location = aAuthURI;
+      case 'logout':
+        IdentityService.doLogout(aId);
+        break;
+
+      case 'cancel':
+        IdentityService.doCancel(aId);
+        break;
+
+      default:
+        logger.error('Unknown identity method: ' + aMessage.method);
+        break;
+    }
   },
 
-  _closeAuthenticationUI: function _closeAuthenticationUI(aAuthId) {
-    log("_closeAuthenticationUI:", aAuthId);
-    let [chromeWin, browserEl] = this._getUIForWindowID(aAuthId);
-    if (chromeWin)
-      chromeWin.close();
-    else
-      Logger.reportError("SignInToWebsite", "Could not close window with ID", aAuthId);
+  cleanUp: function SignInToWebsiteUX_cleanUp(aId) {
+    let context = this.contexts[aId];
+    if (context) {
+      if (context.hostFrame) {
+        context.hostFrame.cleanUp();
+      }
+      if (context.iframe && context.iframe.parentNode) {
+        context.iframe.parentNode.removeChild(context.iframe);
+        delete context.iframe;
+      }
+      this.contexts[aId] = {};
+      delete this.contexts[aId];
+    }
   },
 
-  /**
-   * Show a doorhanger indicating the currently logged-in user.
-   */
-  _showLoggedInUI: function _showLoggedInUI(aIdentity, aContext) {
-    let windowID = aContext.rpId;
-    log("_showLoggedInUI for ", windowID);
-    let [chromeWin, browserEl] = this._getUIForWindowID(windowID);
+  delegate: function SignInToWebsiteUX_delegate(aOptions) {
+    let hostFrame = new HostFrame();
+    hostFrame.getIframe(aOptions, function() {
+      // iframe has been added to aOptions
 
-    let message = chromeWin.gNavigatorBundle.getFormattedString("identity.loggedIn.description",
-                                                          [aIdentity]);
-    let mainAction = {
-      label: chromeWin.gNavigatorBundle.getString("identity.loggedIn.signOut.label"),
-      accessKey: chromeWin.gNavigatorBundle.getString("identity.loggedIn.signOut.accessKey"),
-      callback: function() {
-        log("sign out callback fired");
-        IdentityService.RP.logout(windowID);
-      },
-    };
-    let secondaryActions = [];
-    let options = {
-      dismissed: true,
-    };
-    let loggedInNot = chromeWin.PopupNotifications.show(browserEl, "identity-logged-in", message,
-                                                  "identity-notification-icon", mainAction,
-                                                  secondaryActions, options);
-    loggedInNot.rpId = windowID;
+      // callback for the pipe when flow is complete
+      aOptions.onComplete = function pipe_onComplete() {
+        logger.log("pipe clean up now");
+        this.cleanUp(aOptions.id);
+      }.bind(this);
+
+      // store context and communicate with pipe
+      this.contexts[aOptions.id] = aOptions;
+      this.contexts[aOptions.id].hostFrame = hostFrame;
+
+      let pipe = new this.PipeConstructor(aOptions, this);
+      pipe.communicate();
+    }.bind(this));
   },
 
-  /**
-   * Remove the doorhanger indicating the currently logged-in user.
-   */
-  _removeLoggedInUI: function _removeLoggedInUI(aContext) {
-    let windowID = aContext.rpId;
-    log("_removeLoggedInUI for ", windowID);
-    if (!windowID)
-      throw "_removeLoggedInUI: Invalid RP ID";
-    let [chromeWin, browserEl] = this._getUIForWindowID(windowID);
-
-    let loggedInNot = chromeWin.PopupNotifications.getNotification("identity-logged-in", browserEl);
-    if (loggedInNot)
-      chromeWin.PopupNotifications.remove(loggedInNot);
+  doWatch: function SignInToWebsiteUX_doWatch(aOptions) {
+    aOptions.message = 'identity-delegate-watch';
+    aOptions.src = kHiddenPersonaIframe;
+    aOptions.showUI = false;
+    logger.log("options:", aOptions);
+    this.delegate(aOptions);
   },
 
-  /**
-   * Remove the doorhanger indicating the currently logged-in user.
-   */
-  _removeRequestUI: function _removeRequestUI(aContext) {
-    let windowID = aContext.rpId;
-    log("_removeRequestUI for ", windowID);
-    let [chromeWin, browserEl] = this._getUIForWindowID(windowID);
-
-    let requestNot = chromeWin.PopupNotifications.getNotification("identity-request", browserEl);
-    if (requestNot)
-      chromeWin.PopupNotifications.remove(requestNot);
+  doRequest: function SignInToWebsiteUX_doRequest(aOptions) {
+    aOptions.message = 'identity-delegate-request';
+    aOptions.src = kInteractivePersonaIframe;
+    aOptions.showUI = true;
+    logger.log("options:", aOptions);
+    this.delegate(aOptions);
   },
 
+  doLogout: function SignInToWebsiteUX_doLogout(aOptions) {
+    aOptions.message = 'identity-delegate-logout';
+    aOptions.src = kHiddenPersonaIframe;
+    aOptions.showUI = false;
+    logger.log("options:", aOptions);
+    this.delegate(aOptions);
+  }
 };
diff --git a/browser/modules/test/Makefile.in b/browser/modules/test/Makefile.in
--- a/browser/modules/test/Makefile.in
+++ b/browser/modules/test/Makefile.in
@@ -8,21 +8,21 @@ srcdir		= @srcdir@
 VPATH		= @srcdir@
 relativesrcdir  = @relativesrcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 include $(topsrcdir)/config/rules.mk
 
 _BROWSER_FILES = \
-                 browser_NetworkPrioritizer.js \
-                 # bug 793906 - temporarily disabling desktop UI while working on b2g
-                 # browser_SignInToWebsite.js \
-                 $(NULL)
+	browser_NetworkPrioritizer.js \
+	browser_SignInToWebsite.js \
+	mock_personaIframe.html \
+	$(NULL)
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),windows)
 _BROWSER_FILES += \
-                 browser_taskbar_preview.js \
-                 $(NULL)
+	browser_taskbar_preview.js \
+	$(NULL)
 endif
 
 libs::	$(_BROWSER_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/browser/$(relativesrcdir)
diff --git a/browser/modules/test/browser_SignInToWebsite.js b/browser/modules/test/browser_SignInToWebsite.js
--- a/browser/modules/test/browser_SignInToWebsite.js
+++ b/browser/modules/test/browser_SignInToWebsite.js
@@ -1,549 +1,215 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
+/**
+ * TO TEST:
+ * - SignInToWebsiteUX receives/sends the right signals
+ * - delegation through UI communication pipe works
+ * - HostFrame hosts frames
+ * - getUIForWindowID
+ * - ResizeWatcher responds to window mutations
+ */
+
 "use strict";
 
-/**
- * TO TEST:
- * - test state saved on doorhanger dismissal
- * - links to switch steps
- * - TOS and PP link clicks
- * - identityList is populated correctly
- */
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cu = Components.utils;
 
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+
+// Print identity debug messages to console
 Services.prefs.setBoolPref("toolkit.identity.debug", true);
 
 XPCOMUtils.defineLazyModuleGetter(this, "IdentityService",
-                                  "resource://gre/modules/identity/Identity.jsm");
+                                  "resource://gre/modules/identity/IdentityService.jsm",
+                                  "IdentityService");
+
+let sitw = {};
+Cu.import("resource:///modules/SignInToWebsite.jsm", sitw);
+let HostFrame = sitw.HostFrame;
+let Pipe = sitw.Pipe;
+
+XPCOMUtils.defineLazyServiceGetter(this,
+                                   "uuidGenerator",
+                                   "@mozilla.org/uuid-generator;1",
+                                   "nsIUUIDGenerator");
 
 const TEST_ORIGIN = "https://example.com";
 const TEST_EMAIL = "user@example.com";
 
-let gTestIndex = 0;
-let outerWinId = gBrowser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
-                         .getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
+//let outerWinId = gBrowser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
+//                         .getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
 
-function NotificationBase(aNotId) {
-  this.id = aNotId;
-}
-NotificationBase.prototype = {
-  message: TEST_ORIGIN,
-  mainAction: {
-    label: "",
-    callback: function() {
-      this.mainActionClicked = true;
-    }.bind(this),
-  },
-  secondaryActions: [],
-  options: {
-    "identity": {
-      origin: TEST_ORIGIN,
-      rpId: outerWinId,
-    },
-  },
-};
 
 let tests = [
   {
-    name: "test_request_required_typed",
+    what: "the IdentityService exports are available",
+    run: function run_testSmoke() {
+      ok(IdentityService !== null);
+      ok(typeof HostFrame === 'function');
+      runNextTest();
+    }
+  },
 
-    run: function() {
-      setupRPFlow();
-      this.notifyOptions = {
-        rpId: outerWinId,
-        origin: TEST_ORIGIN,
+  {
+    what: "we can mock a document",
+    run: function run_test_mockedDoc() {
+      let mockedDoc = mockDoc(null, TEST_ORIGIN, function(action, params) {
+        ok(action === 'cancel');
+        runNextTest();
+      });
+
+      mockedDoc.doCancel();
+    }
+  },
+
+  {
+    what: "we can host an iframe with HostFrame",
+    run: function run_testHostFrame() {
+      let options = {
+        src: "chrome://browser/browser/modules/test/mock_personaIframe.html",
       };
-      this.notifyObj = new NotificationBase("identity-request");
-      Services.obs.notifyObservers({wrappedJSObject: this.notifyOptions},
-                                   "identity-request", null);
-    },
+      let hostFrame = new HostFrame();
+      hostFrame.getIframe(options, function() {
+        ok(options.iframe !== null);
+        ok(options.iframe.src === options.src);
+        runNextTest();
+      });
+    }
+  },
 
-    onShown: function(popup) {
-      checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
+  {
+    what: "we can delegate the persona watch() method",
+    run: function run_testWatch() {
+      makePipeDelegate('identity-delegate-watch', function doMethodCallback(options, id) {
+        ok(options.method === 'ready');
+        runNextTest();
+      });
+    }
+  },
 
-      // Check identity popup state
-      let state = notification.identity;
-      ok(!state.typedEmail, "Nothing should be typed yet");
-      ok(!state.selected, "Identity should not be selected yet");
-      ok(!state.termsOfService, "No TOS specified");
-      ok(!state.privacyPolicy, "No PP specified");
-      is(state.step, 0, "Step should be persisted with default value");
-      is(state.rpId, outerWinId, "Check rpId");
-      is(state.origin, TEST_ORIGIN, "Check origin");
+  {
+    what: "we can delegate the persona request() method",
+    run: function run_testRequest() {
+      makePipeDelegate('identity-delegate-request', function doMethodCallback(options, id) {
+        ok(options.method === 'login');
+        ok(options.assertion === "I love your shoes!");
+        runNextTest();
+      });
+    }
+  },
 
-      is(notification.step, 0, "Should be on the new email step");
-      is(notification.chooseEmailLink.hidden, true, "Identity list is empty so link to list view should be hidden");
-      is(notification.addEmailLink.parentElement.hidden, true, "We are already on the email input step so choose email pane should be hidden");
-      is(notification.emailField.value, "", "Email field should default to empty on a new notification");
-      let notifDoc = notification.ownerDocument;
-      ok(notifDoc.getAnonymousElementByAttribute(notification, "anonid", "tos").hidden,
-         "TOS link should be hidden");
-      ok(notifDoc.getAnonymousElementByAttribute(notification, "anonid", "privacypolicy").hidden,
-         "PP link should be hidden");
-
-      // Try to continue with a missing email address
-      triggerMainCommand(popup);
-      is(notification.throbber.style.visibility, "hidden", "is throbber visible");
-      ok(!notification.button.disabled, "Button should not be disabled");
-      is(window.gIdentitySelected, null, "Check no identity selected");
-
-      // Fill in an invalid email address and try again
-      notification.emailField.value = "foo";
-      triggerMainCommand(popup);
-      is(notification.throbber.style.visibility, "hidden", "is throbber visible");
-      ok(!notification.button.disabled, "Button should not be disabled");
-      is(window.gIdentitySelected, null, "Check no identity selected");
-
-      // Fill in an email address and try again
-      notification.emailField.value = TEST_EMAIL;
-      triggerMainCommand(popup);
-      is(window.gIdentitySelected.rpId, outerWinId, "Check identity selected rpId");
-      is(window.gIdentitySelected.identity, TEST_EMAIL, "Check identity selected email");
-      is(notification.identity.selected, TEST_EMAIL, "Check persisted email");
-      is(notification.throbber.style.visibility, "visible", "is throbber visible");
-      ok(notification.button.disabled, "Button should be disabled");
-      ok(notification.emailField.disabled, "Email field should be disabled");
-      ok(notification.identityList.disabled, "Identity list should be disabled");
-
-      PopupNotifications.getNotification("identity-request").remove();
-    },
-
-    onHidden: function(popup) { },
-  },
   {
-    name: "test_request_optional",
-
-    run: function() {
-      this.notifyOptions = {
-        rpId: outerWinId,
-        origin: TEST_ORIGIN,
-        privacyPolicy: TEST_ORIGIN + "/pp.txt",
-        termsOfService: TEST_ORIGIN + "/tos.tzt",
-      };
-      this.notifyObj = new NotificationBase("identity-request");
-      Services.obs.notifyObservers({ wrappedJSObject: this.notifyOptions },
-                                   "identity-request", null);
-    },
-
-    onShown: function(popup) {
-      checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
-
-      // Check identity popup state
-      let state = notification.identity;
-      ok(!state.typedEmail, "Nothing should be typed yet");
-      ok(!state.selected, "Identity should not be selected yet");
-      is(state.termsOfService, this.notifyOptions.termsOfService, "Check TOS URL");
-      is(state.privacyPolicy, this.notifyOptions.privacyPolicy, "Check PP URL");
-      is(state.step, 0, "Step should be persisted with default value");
-      is(state.rpId, outerWinId, "Check rpId");
-      is(state.origin, TEST_ORIGIN, "Check origin");
-
-      is(notification.step, 0, "Should be on the new email step");
-      is(notification.chooseEmailLink.hidden, true, "Identity list is empty so link to list view should be hidden");
-      is(notification.addEmailLink.parentElement.hidden, true, "We are already on the email input step so choose email pane should be hidden");
-      is(notification.emailField.value, "", "Email field should default to empty on a new notification");
-      let notifDoc = notification.ownerDocument;
-      let tosLink = notifDoc.getAnonymousElementByAttribute(notification, "anonid", "tos");
-      ok(!tosLink.hidden, "TOS link should be visible");
-      is(tosLink.href, this.notifyOptions.termsOfService, "Check TOS link URL");
-      let ppLink = notifDoc.getAnonymousElementByAttribute(notification, "anonid", "privacypolicy");
-      ok(!ppLink.hidden, "PP link should be visible");
-      is(ppLink.href, this.notifyOptions.privacyPolicy, "Check PP link URL");
-
-      // Try to continue with a missing email address
-      triggerMainCommand(popup);
-      is(notification.throbber.style.visibility, "hidden", "is throbber visible");
-      ok(!notification.button.disabled, "Button should not be disabled");
-      is(window.gIdentitySelected, null, "Check no identity selected");
-
-      // Fill in an invalid email address and try again
-      notification.emailField.value = "foo";
-      triggerMainCommand(popup);
-      is(notification.throbber.style.visibility, "hidden", "is throbber visible");
-      ok(!notification.button.disabled, "Button should not be disabled");
-      is(window.gIdentitySelected, null, "Check no identity selected");
-
-      // Fill in an email address and try again
-      notification.emailField.value = TEST_EMAIL;
-      triggerMainCommand(popup);
-      is(window.gIdentitySelected.rpId, outerWinId, "Check identity selected rpId");
-      is(window.gIdentitySelected.identity, TEST_EMAIL, "Check identity selected email");
-      is(notification.identity.selected, TEST_EMAIL, "Check persisted email");
-      is(notification.throbber.style.visibility, "visible", "is throbber visible");
-      ok(notification.button.disabled, "Button should be disabled");
-      ok(notification.emailField.disabled, "Email field should be disabled");
-      ok(notification.identityList.disabled, "Identity list should be disabled");
-
-      PopupNotifications.getNotification("identity-request").remove();
-    },
-
-    onHidden: function(popup) {},
-  },
-  {
-    name: "test_login_state_changed",
-    run: function () {
-      this.notifyOptions = {
-        rpId: outerWinId,
-      };
-      this.notifyObj = new NotificationBase("identity-logged-in");
-      this.notifyObj.message = "Signed in as: user@example.com";
-      this.notifyObj.mainAction.label = "Sign Out";
-      this.notifyObj.mainAction.accessKey = "O";
-      Services.obs.notifyObservers({ wrappedJSObject: this.notifyOptions },
-                                   "identity-login-state-changed", TEST_EMAIL);
-      executeSoon(function() {
-        PopupNotifications.getNotification("identity-logged-in").anchorElement.click();
+    what: "we can delegate the persona logout() method",
+    run: function run_testLogout() {
+      makePipeDelegate('identity-delegate-logout', function doMethodCallback(options, id) {
+        ok(options.method === 'logout');
+        runNextTest();
       });
-    },
-
-    onShown: function(popup) {
-      checkPopup(popup, this.notifyObj);
-
-      // Fire the notification that the user is no longer logged-in to close the UI.
-      Services.obs.notifyObservers({ wrappedJSObject: this.notifyOptions },
-                                   "identity-login-state-changed", null);
-    },
-
-    onHidden: function(popup) {},
-  },
-  {
-    name: "test_login_state_changed_logout",
-    run: function () {
-      this.notifyOptions = {
-        rpId: outerWinId,
-      };
-      this.notifyObj = new NotificationBase("identity-logged-in");
-      this.notifyObj.message = "Signed in as: user@example.com";
-      this.notifyObj.mainAction.label = "Sign Out";
-      this.notifyObj.mainAction.accessKey = "O";
-      Services.obs.notifyObservers({ wrappedJSObject: this.notifyOptions },
-                                   "identity-login-state-changed", TEST_EMAIL);
-      executeSoon(function() {
-        PopupNotifications.getNotification("identity-logged-in").anchorElement.click();
-      });
-    },
-
-    onShown: function(popup) {
-      checkPopup(popup, this.notifyObj);
-
-      // This time trigger the Sign Out button and make sure the UI goes away.
-      triggerMainCommand(popup);
-    },
-
-    onHidden: function(popup) {},
-  },
+    }
+  }
 ];
 
-function test_auth() {
-  let notifyOptions = {
-    provId: outerWinId,
-    origin: TEST_ORIGIN,
+// Exercise the Pipe, HostFrame, and browser-identity.js shim.
+// Mocks the functionality of SignInToWebsite's delegate() method.  
+// Here, we delegatebrowserid method calls up to an iframe that 
+// mocks the persona internal_api calls.  
+function makePipeDelegate(aMessage, aCallback) {
+  let controller = mockController(aCallback);
+  let options = {
+    id: 42,
+    message: aMessage,
+    src: "http://example.org/browser/browser/modules/test/mock_personaIframe.html",
+    rpOptions: {
+      origin: TEST_ORIGIN
+    }
   };
 
-  Services.obs.addObserver(function() {
-    // prepare to send auth-complete and close the window
-    let winCloseObs = new WindowObserver(function(closedWin) {
-      info("closed window");
-      finish();
-    }, "domwindowclosed");
-    Services.ww.registerNotification(winCloseObs);
-    Services.obs.notifyObservers(null, "identity-auth-complete", IdentityService.IDP.authenticationFlowSet.authId);
-
-  }, "test-identity-auth-window", false);
-
-  let winObs = new WindowObserver(function(authWin) {
-    ok(authWin, "Authentication window opened");
-    ok(authWin.contentWindow.location);
-  });
-
-  Services.ww.registerNotification(winObs);
-
-  Services.obs.notifyObservers({ wrappedJSObject: notifyOptions },
-                               "identity-auth", TEST_ORIGIN + "/auth");
-}
-
-function test() {
-  waitForExplicitFinish();
-
-  registerCleanupFunction(cleanUp);
-
-  let sitw = {};
-  Components.utils.import("resource:///modules/SignInToWebsite.jsm", sitw);
-
-  ok(sitw.SignInToWebsiteUX, "SignInToWebsiteUX object exists");
-
-  // Replace implementation of ID Service functions for testing
-  window.selectIdentity = sitw.SignInToWebsiteUX.selectIdentity;
-  sitw.SignInToWebsiteUX.selectIdentity = function(aRpId, aIdentity) {
-    info("Identity selected: " + aIdentity);
-    window.gIdentitySelected = {rpId: aRpId, identity: aIdentity};
-  };
-
-  window.setAuthenticationFlow = IdentityService.IDP.setAuthenticationFlow;
-  IdentityService.IDP.setAuthenticationFlow = function(aAuthId, aProvId) {
-    info("setAuthenticationFlow: " + aAuthId + " : " + aProvId);
-    this.authenticationFlowSet = { authId: aAuthId, provId: aProvId };
-    Services.obs.notifyObservers(null, "test-identity-auth-window", aAuthId);
-  };
-
-  runNextTest();
-}
-
-// Cleanup between tests
-function resetState() {
-  delete window.gIdentitySelected;
-  delete IdentityService.IDP.authenticationFlowSet;
-  IdentityService.reset();
-}
-
-// Cleanup after all tests
-function cleanUp() {
-  info("cleanup");
-  resetState();
-
-  for (let topic in gActiveObservers)
-    Services.obs.removeObserver(gActiveObservers[topic], topic);
-  for (let eventName in gActiveListeners)
-    PopupNotifications.panel.removeEventListener(eventName, gActiveListeners[eventName], false);
-  delete IdentityService.RP._rpFlows[outerWinId];
-
-  // Put the JSM functions back to how they were
-  IdentityService.IDP.setAuthenticationFlow = window.setAuthenticationFlow;
-  delete window.setAuthenticationFlow;
-
-  let sitw = {};
-  Components.utils.import("resource:///modules/SignInToWebsite.jsm", sitw);
-  sitw.SignInToWebsiteUX.selectIdentity = window.selectIdentity;
-  delete window.selectIdentity;
-
-  Services.prefs.clearUserPref("toolkit.identity.debug");
-}
-
-let gActiveListeners = {};
-let gActiveObservers = {};
-let gShownState = {};
-
-function runNextTest() {
-  let nextTest = tests[gTestIndex];
-
-  function goNext() {
-    resetState();
-    if (++gTestIndex == tests.length)
-      executeSoon(test_auth);
-    else
-      executeSoon(runNextTest);
+  function gotIframe() {
+    options.onComplete = function() {};
+    let pipe = new Pipe(options, controller);
+    pipe.communicate();
   }
 
-  function addObserver(topic) {
-    function observer() {
-      Services.obs.removeObserver(observer, "PopupNotifications-" + topic);
-      delete gActiveObservers["PopupNotifications-" + topic];
-
-      info("[Test #" + gTestIndex + "] observer for " + topic + " called");
-      nextTest[topic]();
-      goNext();
-    }
-    Services.obs.addObserver(observer, "PopupNotifications-" + topic, false);
-    gActiveObservers["PopupNotifications-" + topic] = observer;
-  }
-
-  if (nextTest.backgroundShow) {
-    addObserver("backgroundShow");
-  } else if (nextTest.updateNotShowing) {
-    addObserver("updateNotShowing");
-  } else {
-    doOnPopupEvent("popupshowing", function () {
-      info("[Test #" + gTestIndex + "] popup showing");
-    });
-    doOnPopupEvent("popupshown", function () {
-      gShownState[gTestIndex] = true;
-      info("[Test #" + gTestIndex + "] popup shown");
-      nextTest.onShown(this);
-    });
-
-    // We allow multiple onHidden functions to be defined in an array.  They're
-    // called in the order they appear.
-    let onHiddenArray = nextTest.onHidden instanceof Array ?
-                        nextTest.onHidden :
-                        [nextTest.onHidden];
-    doOnPopupEvent("popuphidden", function () {
-      if (!gShownState[gTestIndex]) {
-        // TODO: needed?
-        info("Popup from test " + gTestIndex + " was hidden before its popupshown fired");
-      }
-
-      let onHidden = onHiddenArray.shift();
-      info("[Test #" + gTestIndex + "] popup hidden (" + onHiddenArray.length + " hides remaining)");
-      executeSoon(function () {
-        onHidden.call(nextTest, this);
-        if (!onHiddenArray.length)
-          goNext();
-      }.bind(this));
-    }, onHiddenArray.length);
-    info("[Test #" + gTestIndex + "] added listeners; panel state: " + PopupNotifications.isPanelOpen);
-  }
-
-  info("[Test #" + gTestIndex + "] running test");
-  nextTest.run();
-}
-
-function doOnPopupEvent(eventName, callback, numExpected) {
-  gActiveListeners[eventName] = function (event) {
-    if (event.target != PopupNotifications.panel)
-      return;
-    if (typeof(numExpected) === "number")
-      numExpected--;
-    if (!numExpected) {
-      PopupNotifications.panel.removeEventListener(eventName, gActiveListeners[eventName], false);
-      delete gActiveListeners[eventName];
-    }
-
-    callback.call(PopupNotifications.panel);
-  };
-  PopupNotifications.panel.addEventListener(eventName, gActiveListeners[eventName], false);
-}
-
-function checkPopup(popup, notificationObj) {
-  info("[Test #" + gTestIndex + "] checking popup");
-
-  let notifications = popup.childNodes;
-  is(notifications.length, 1, "only one notification displayed");
-  let notification = notifications[0];
-  let icon = document.getAnonymousElementByAttribute(notification, "class", "popup-notification-icon");
-  is(notification.getAttribute("label"), notificationObj.message, "message matches");
-  is(notification.id, notificationObj.id + "-notification", "id matches");
-  if (notificationObj.id != "identity-request" && notificationObj.mainAction) {
-    is(notification.getAttribute("buttonlabel"), notificationObj.mainAction.label, "main action label matches");
-    is(notification.getAttribute("buttonaccesskey"), notificationObj.mainAction.accessKey, "main action accesskey matches");
-  }
-  let actualSecondaryActions = notification.childNodes;
-  let secondaryActions = notificationObj.secondaryActions || [];
-  let actualSecondaryActionsCount = actualSecondaryActions.length;
-  if (secondaryActions.length) {
-    let lastChild = actualSecondaryActions.item(actualSecondaryActions.length - 1);
-    is(lastChild.tagName, "menuseparator", "menuseparator exists");
-    actualSecondaryActionsCount--;
-  }
-  is(actualSecondaryActionsCount, secondaryActions.length, actualSecondaryActions.length + " secondary actions");
-  secondaryActions.forEach(function (a, i) {
-    is(actualSecondaryActions[i].getAttribute("label"), a.label, "label for secondary action " + i + " matches");
-    is(actualSecondaryActions[i].getAttribute("accesskey"), a.accessKey, "accessKey for secondary action " + i + " matches");
-  });
-}
-
-function triggerMainCommand(popup) {
-  info("[Test #" + gTestIndex + "] triggering main command");
-  let notifications = popup.childNodes;
-  ok(notifications.length > 0, "at least one notification displayed");
-  let notification = notifications[0];
-
-  // 20, 10 so that the inner button is hit
-  EventUtils.synthesizeMouse(notification.button, 20, 10, {});
-}
-
-function triggerSecondaryCommand(popup, index) {
-  info("[Test #" + gTestIndex + "] triggering secondary command");
-  let notifications = popup.childNodes;
-  ok(notifications.length > 0, "at least one notification displayed");
-  let notification = notifications[0];
-
-  notification.button.focus();
-
-  popup.addEventListener("popupshown", function () {
-    popup.removeEventListener("popupshown", arguments.callee, false);
-
-    // Press down until the desired command is selected
-    for (let i = 0; i <= index; i++)
-      EventUtils.synthesizeKey("VK_DOWN", {});
-
-    // Activate
-    EventUtils.synthesizeKey("VK_ENTER", {});
-  }, false);
-
-  // One down event to open the popup
-  EventUtils.synthesizeKey("VK_DOWN", { altKey: (navigator.platform.indexOf("Mac") == -1) });
-}
-
-function dismissNotification(popup) {
-  info("[Test #" + gTestIndex + "] dismissing notification");
-  executeSoon(function () {
-    EventUtils.synthesizeKey("VK_ESCAPE", {});
-  });
+  let hostFrame = new HostFrame();
+  hostFrame.getIframe(options, gotIframe);
 }
 
 function partial(fn) {
   let args = Array.prototype.slice.call(arguments, 1);
   return function() {
     return fn.apply(this, args.concat(Array.prototype.slice.call(arguments)));
   };
 }
 
 // create a mock "doc" object, which the Identity Service
 // uses as a pointer back into the doc object
-function mock_doc(aIdentity, aOrigin, aDoFunc) {
+function mockDoc(aIdentity, aOrigin, aDoFunc) {
   let mockedDoc = {};
-  mockedDoc.id = outerWinId;
-  mockedDoc.loggedInEmail = aIdentity;
+  mockedDoc.id = uuidGenerator.generateUUID().toString();
+  mockedDoc.loggedInUser = aIdentity;
   mockedDoc.origin = aOrigin;
   mockedDoc['do'] = aDoFunc;
   mockedDoc.doReady = partial(aDoFunc, 'ready');
   mockedDoc.doLogin = partial(aDoFunc, 'login');
   mockedDoc.doLogout = partial(aDoFunc, 'logout');
   mockedDoc.doError = partial(aDoFunc, 'error');
   mockedDoc.doCancel = partial(aDoFunc, 'cancel');
-  mockedDoc.doCoffee = partial(aDoFunc, 'coffee');
 
   return mockedDoc;
 }
 
-// takes a list of functions and returns a function that
-// when called the first time, calls the first func,
-// then the next time the second, etc.
-function call_sequentially() {
-  let numCalls = 0;
-  let funcs = arguments;
-
-  return function() {
-    if (!funcs[numCalls]) {
-      let argString = Array.prototype.slice.call(arguments).join(",");
-      ok(false, "Too many calls: " + argString);
-      return;
-    }
-    funcs[numCalls].apply(funcs[numCalls], arguments);
-    numCalls += 1;
+// create a mock controller for use with a Pipe.
+function mockController(aDoMethodFunc) {
+  let mockedController = {};
+  mockedController.serviceDoMethod = function mockController_doMethod(aOptions, aId) {
+    aDoMethodFunc(aOptions, aId)
   };
+  return mockedController;
 }
 
-function setupRPFlow(aIdentity) {
-  IdentityService.RP.watch(mock_doc(aIdentity, TEST_ORIGIN, call_sequentially(
-    function(action, params) {
-      is(action, "ready", "1st callback");
-      is(params, null);
-    },
-    function(action, params) {
-      is(action, "logout", "2nd callback");
-      is(params, null);
-    },
-    function(action, params) {
-      is(action, "ready", "3rd callback");
-      is(params, null);
+// mimicking callback funtionality for ease of testing
+// this observer auto-removes itself after the observe function
+// is called, so this is meant to observe only ONE event.
+function makeObserver(aObserveTopic, aObserveFunc) {
+  let observer = {
+    // nsISupports provides type management in C++
+    // nsIObserver is to be an observer
+    QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports, Ci.nsIObserver]),
+
+    observe: function (aSubject, aTopic, aData) {
+      if (aTopic == aObserveTopic) {
+        aObserveFunc(aSubject, aTopic, aData);
+        Services.obs.removeObserver(observer, aObserveTopic);
+      }
     }
-  )));
+  };
+
+  Services.obs.addObserver(observer, aObserveTopic, false);
 }
 
-function WindowObserver(aCallback, aObserveTopic = "domwindowopened") {
-  this.observe = function(aSubject, aTopic, aData) {
-    if (aTopic != aObserveTopic) {
-      return;
-    }
-    info(aObserveTopic);
-    Services.ww.unregisterNotification(this);
+registerCleanupFunction(function cleanup() {
+  // nothing to clean up
+});
 
-    SimpleTest.executeSoon(function() {
-      let domWin = aSubject.QueryInterface(Ci.nsIDOMWindow);
-      aCallback(domWin);
-    });
-  };
+let testNum = 0;
+
+function runNextTest() {
+  if (tests.length) {
+    testNum += 1;
+    let test = tests.shift();
+    info("[Test #" + testNum + "] Show that " + test.what);
+    waitForFocus(test.run);
+  } else {
+    finish();
+  }
+};
+
+function test() {
+  waitForExplicitFinish();
+
+  runNextTest();
 }
+
diff --git a/browser/modules/test/mock_personaIframe.html b/browser/modules/test/mock_personaIframe.html
new file mode 100644
--- /dev/null
+++ b/browser/modules/test/mock_personaIframe.html
@@ -0,0 +1,34 @@
+<html>
+  <head>
+    <meta charset="utf-8" />
+    <title>Mock Persona IFrame</title>
+  </head>
+  <body>
+
+    <div>
+      Mock Persona IFrame
+    </div>
+
+    <script language="javascript">
+      window.onload = function() {
+        window.BrowserID = { internal: {} };
+        var internal = BrowserID.internal;
+
+        internal.watch = function internal_watch(callback, options, logger) {
+          callback({method: 'ready'});
+        };
+
+        internal.get = function internal_get(origin, callback, options) {
+          var assertion = "I love your shoes!";
+          callback(assertion);
+        };
+
+        internal.logout = function internal_logout(origin, callback) {
+          callback({method: 'logout'});
+        };
+      };
+    </script>
+
+  </body>
+</html>
+
diff --git a/browser/modules/test/unit/head_identity.js b/browser/modules/test/unit/head_identity.js
new file mode 100644
--- /dev/null
+++ b/browser/modules/test/unit/head_identity.js
@@ -0,0 +1,112 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cu = Components.utils;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+
+// Print identity debug messages to console
+Services.prefs.setBoolPref("toolkit.identity.debug", true);
+
+XPCOMUtils.defineLazyModuleGetter(this, "IdentityService",
+                                  "resource://gre/modules/identity/IdentityService.jsm");
+
+XPCOMUtils.defineLazyServiceGetter(this,
+                                   "uuidGenerator",
+                                   "@mozilla.org/uuid-generator;1",
+                                   "nsIUUIDGenerator");
+
+XPCOMUtils.defineLazyGetter(this, "logger", function() {
+  Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+  return getLogger("Identity", "toolkit.identity.debug");
+});
+
+const TEST_ORIGIN = "https://example.com";
+const TEST_EMAIL = "user@example.com";
+
+//let outerWinId = gBrowser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
+//                         .getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
+
+function partial(fn) {
+  let args = Array.prototype.slice.call(arguments, 1);
+  return function() {
+    return fn.apply(this, args.concat(Array.prototype.slice.call(arguments)));
+  };
+}
+
+// create a mock "doc" object, which the Identity Service
+// uses as a pointer back into the doc object
+function mockDoc(aIdentity, aOrigin, aDoFunc) {
+  let mockedDoc = {};
+  mockedDoc.id = uuidGenerator.generateUUID().toString();
+  mockedDoc.loggedInUser = aIdentity;
+  mockedDoc.origin = aOrigin;
+  mockedDoc['do'] = aDoFunc;
+  mockedDoc.doReady = partial(aDoFunc, 'ready');
+  mockedDoc.doLogin = partial(aDoFunc, 'login');
+  mockedDoc.doLogout = partial(aDoFunc, 'logout');
+  mockedDoc.doError = partial(aDoFunc, 'error');
+  mockedDoc.doCancel = partial(aDoFunc, 'cancel');
+  mockedDoc.doCoffee = partial(aDoFunc, 'coffee');
+
+  return mockedDoc;
+}
+
+function mockController(aDoMethodFunc) {
+  logger.log("got mock controller");
+  let mockedController = {};
+  mockedController.serviceDoMethod = function mockController_doMethod(aOptions, aId) {
+    logger.log("do method:", aOptions.method);
+    aDoMethodFunc(aOptions, aId)
+  };
+}
+
+function getHostFrame() {
+  logger.log();
+
+  //let hwin = Cc["@mozilla.org/appshell/appShellService;1"]
+  //             .getService(Ci.nsIAppShellService).hiddenDOMWindow;
+  let hwin = Services.appShell.hiddenDOMWindow;
+
+  let doc = hwin.document;
+  let iframe = doc.createElementNS('http://www.w3.org/1999/xhtml', 'iframe');
+  logger.log("got iframe", iframe);
+
+  iframe.setAttribute('mozbrowser', true);
+  iframe.setAttribute('mozframetype', 'content');
+  iframe.setAttribute('type', 'content');
+  iframe.setAttribute('id', 'persona-host-iframe');
+  iframe.setAttribute('src', '');
+
+  let mm = iframe.QueryInterface(Ci.nsIFrameLoaderOwner).frameLoader.messageManager;
+  mm.loadFrameScript('chrome://browser/content/browser-identity.js', true);
+
+  logger.log("returning iframe");
+  return iframe;
+}
+
+// mimicking callback funtionality for ease of testing
+// this observer auto-removes itself after the observe function
+// is called, so this is meant to observe only ONE event.
+function makeObserver(aObserveTopic, aObserveFunc) {
+  let observer = {
+    // nsISupports provides type management in C++
+    // nsIObserver is to be an observer
+    QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports, Ci.nsIObserver]),
+
+    observe: function (aSubject, aTopic, aData) {
+      if (aTopic == aObserveTopic) {
+        aObserveFunc(aSubject, aTopic, aData);
+        Services.obs.removeObserver(observer, aObserveTopic);
+      }
+    }
+  };
+
+  Services.obs.addObserver(observer, aObserveTopic, false);
+}
+
diff --git a/browser/modules/test/browser_SignInToWebsite.js b/browser/modules/test/unit/test_SignInToWebsite.js
copy from browser/modules/test/browser_SignInToWebsite.js
copy to browser/modules/test/unit/test_SignInToWebsite.js
--- a/browser/modules/test/browser_SignInToWebsite.js
+++ b/browser/modules/test/unit/test_SignInToWebsite.js
@@ -1,549 +1,66 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
+/**
+ * TO TEST:
+ * - SignInToWebsiteUX receives/sends the right signals
+ * - delegation through UI communication pipe works
+ * - HostFrame hosts frames
+ * - getUIForWindowID
+ * - ResizeWatcher responds to window mutations
+ */
+
+
 "use strict";
 
-/**
- * TO TEST:
- * - test state saved on doorhanger dismissal
- * - links to switch steps
- * - TOS and PP link clicks
- * - identityList is populated correctly
- */
+function makePipeDelegate(message) {
+  let mockedController = mockController();
+  let iframe = getHostFrame();
+  let options = {
+    iframe: iframe,
+    message: message,
+    onComplete: function pipe_onComplete() {
+      do_test_finished();
+      run_next_test();
+    }
+  };
+  let pipe = new Pipe(options, mockedController);
+  pipe.communicate();
+}
 
-Services.prefs.setBoolPref("toolkit.identity.debug", true);
+function test_smoke() {
+  do_check_neq(IdentityService, null);
+  run_next_test();
+}
 
-XPCOMUtils.defineLazyModuleGetter(this, "IdentityService",
-                                  "resource://gre/modules/identity/Identity.jsm");
+function test_mockDoc() {
+  do_test_pending();
+  let mockedDoc = mockDoc(null, TEST_ORIGIN, function(action, params) {
+    do_check_eq(action, 'coffee');
+    do_test_finished();
+    run_next_test();
+  });
 
-const TEST_ORIGIN = "https://example.com";
-const TEST_EMAIL = "user@example.com";
+  mockedDoc.doCoffee();
+  // XXX todo: get me a danish
+}
 
-let gTestIndex = 0;
-let outerWinId = gBrowser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
-                         .getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
+function test_watch() {
+  makePipeDelegate('navigator-delegate-watch');
+}
 
-function NotificationBase(aNotId) {
-  this.id = aNotId;
-}
-NotificationBase.prototype = {
-  message: TEST_ORIGIN,
-  mainAction: {
-    label: "",
-    callback: function() {
-      this.mainActionClicked = true;
-    }.bind(this),
-  },
-  secondaryActions: [],
-  options: {
-    "identity": {
-      origin: TEST_ORIGIN,
-      rpId: outerWinId,
-    },
-  },
-};
 
-let tests = [
-  {
-    name: "test_request_required_typed",
-
-    run: function() {
-      setupRPFlow();
-      this.notifyOptions = {
-        rpId: outerWinId,
-        origin: TEST_ORIGIN,
-      };
-      this.notifyObj = new NotificationBase("identity-request");
-      Services.obs.notifyObservers({wrappedJSObject: this.notifyOptions},
-                                   "identity-request", null);
-    },
-
-    onShown: function(popup) {
-      checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
-
-      // Check identity popup state
-      let state = notification.identity;
-      ok(!state.typedEmail, "Nothing should be typed yet");
-      ok(!state.selected, "Identity should not be selected yet");
-      ok(!state.termsOfService, "No TOS specified");
-      ok(!state.privacyPolicy, "No PP specified");
-      is(state.step, 0, "Step should be persisted with default value");
-      is(state.rpId, outerWinId, "Check rpId");
-      is(state.origin, TEST_ORIGIN, "Check origin");
-
-      is(notification.step, 0, "Should be on the new email step");
-      is(notification.chooseEmailLink.hidden, true, "Identity list is empty so link to list view should be hidden");
-      is(notification.addEmailLink.parentElement.hidden, true, "We are already on the email input step so choose email pane should be hidden");
-      is(notification.emailField.value, "", "Email field should default to empty on a new notification");
-      let notifDoc = notification.ownerDocument;
-      ok(notifDoc.getAnonymousElementByAttribute(notification, "anonid", "tos").hidden,
-         "TOS link should be hidden");
-      ok(notifDoc.getAnonymousElementByAttribute(notification, "anonid", "privacypolicy").hidden,
-         "PP link should be hidden");
-
-      // Try to continue with a missing email address
-      triggerMainCommand(popup);
-      is(notification.throbber.style.visibility, "hidden", "is throbber visible");
-      ok(!notification.button.disabled, "Button should not be disabled");
-      is(window.gIdentitySelected, null, "Check no identity selected");
-
-      // Fill in an invalid email address and try again
-      notification.emailField.value = "foo";
-      triggerMainCommand(popup);
-      is(notification.throbber.style.visibility, "hidden", "is throbber visible");
-      ok(!notification.button.disabled, "Button should not be disabled");
-      is(window.gIdentitySelected, null, "Check no identity selected");
-
-      // Fill in an email address and try again
-      notification.emailField.value = TEST_EMAIL;
-      triggerMainCommand(popup);
-      is(window.gIdentitySelected.rpId, outerWinId, "Check identity selected rpId");
-      is(window.gIdentitySelected.identity, TEST_EMAIL, "Check identity selected email");
-      is(notification.identity.selected, TEST_EMAIL, "Check persisted email");
-      is(notification.throbber.style.visibility, "visible", "is throbber visible");
-      ok(notification.button.disabled, "Button should be disabled");
-      ok(notification.emailField.disabled, "Email field should be disabled");
-      ok(notification.identityList.disabled, "Identity list should be disabled");
-
-      PopupNotifications.getNotification("identity-request").remove();
-    },
-
-    onHidden: function(popup) { },
-  },
-  {
-    name: "test_request_optional",
-
-    run: function() {
-      this.notifyOptions = {
-        rpId: outerWinId,
-        origin: TEST_ORIGIN,
-        privacyPolicy: TEST_ORIGIN + "/pp.txt",
-        termsOfService: TEST_ORIGIN + "/tos.tzt",
-      };
-      this.notifyObj = new NotificationBase("identity-request");
-      Services.obs.notifyObservers({ wrappedJSObject: this.notifyOptions },
-                                   "identity-request", null);
-    },
-
-    onShown: function(popup) {
-      checkPopup(popup, this.notifyObj);
-      let notification = popup.childNodes[0];
-
-      // Check identity popup state
-      let state = notification.identity;
-      ok(!state.typedEmail, "Nothing should be typed yet");
-      ok(!state.selected, "Identity should not be selected yet");
-      is(state.termsOfService, this.notifyOptions.termsOfService, "Check TOS URL");
-      is(state.privacyPolicy, this.notifyOptions.privacyPolicy, "Check PP URL");
-      is(state.step, 0, "Step should be persisted with default value");
-      is(state.rpId, outerWinId, "Check rpId");
-      is(state.origin, TEST_ORIGIN, "Check origin");
-
-      is(notification.step, 0, "Should be on the new email step");
-      is(notification.chooseEmailLink.hidden, true, "Identity list is empty so link to list view should be hidden");
-      is(notification.addEmailLink.parentElement.hidden, true, "We are already on the email input step so choose email pane should be hidden");
-      is(notification.emailField.value, "", "Email field should default to empty on a new notification");
-      let notifDoc = notification.ownerDocument;
-      let tosLink = notifDoc.getAnonymousElementByAttribute(notification, "anonid", "tos");
-      ok(!tosLink.hidden, "TOS link should be visible");
-      is(tosLink.href, this.notifyOptions.termsOfService, "Check TOS link URL");
-      let ppLink = notifDoc.getAnonymousElementByAttribute(notification, "anonid", "privacypolicy");
-      ok(!ppLink.hidden, "PP link should be visible");
-      is(ppLink.href, this.notifyOptions.privacyPolicy, "Check PP link URL");
-
-      // Try to continue with a missing email address
-      triggerMainCommand(popup);
-      is(notification.throbber.style.visibility, "hidden", "is throbber visible");
-      ok(!notification.button.disabled, "Button should not be disabled");
-      is(window.gIdentitySelected, null, "Check no identity selected");
-
-      // Fill in an invalid email address and try again
-      notification.emailField.value = "foo";
-      triggerMainCommand(popup);
-      is(notification.throbber.style.visibility, "hidden", "is throbber visible");
-      ok(!notification.button.disabled, "Button should not be disabled");
-      is(window.gIdentitySelected, null, "Check no identity selected");
-
-      // Fill in an email address and try again
-      notification.emailField.value = TEST_EMAIL;
-      triggerMainCommand(popup);
-      is(window.gIdentitySelected.rpId, outerWinId, "Check identity selected rpId");
-      is(window.gIdentitySelected.identity, TEST_EMAIL, "Check identity selected email");
-      is(notification.identity.selected, TEST_EMAIL, "Check persisted email");
-      is(notification.throbber.style.visibility, "visible", "is throbber visible");
-      ok(notification.button.disabled, "Button should be disabled");
-      ok(notification.emailField.disabled, "Email field should be disabled");
-      ok(notification.identityList.disabled, "Identity list should be disabled");
-
-      PopupNotifications.getNotification("identity-request").remove();
-    },
-
-    onHidden: function(popup) {},
-  },
-  {
-    name: "test_login_state_changed",
-    run: function () {
-      this.notifyOptions = {
-        rpId: outerWinId,
-      };
-      this.notifyObj = new NotificationBase("identity-logged-in");
-      this.notifyObj.message = "Signed in as: user@example.com";
-      this.notifyObj.mainAction.label = "Sign Out";
-      this.notifyObj.mainAction.accessKey = "O";
-      Services.obs.notifyObservers({ wrappedJSObject: this.notifyOptions },
-                                   "identity-login-state-changed", TEST_EMAIL);
-      executeSoon(function() {
-        PopupNotifications.getNotification("identity-logged-in").anchorElement.click();
-      });
-    },
-
-    onShown: function(popup) {
-      checkPopup(popup, this.notifyObj);
-
-      // Fire the notification that the user is no longer logged-in to close the UI.
-      Services.obs.notifyObservers({ wrappedJSObject: this.notifyOptions },
-                                   "identity-login-state-changed", null);
-    },
-
-    onHidden: function(popup) {},
-  },
-  {
-    name: "test_login_state_changed_logout",
-    run: function () {
-      this.notifyOptions = {
-        rpId: outerWinId,
-      };
-      this.notifyObj = new NotificationBase("identity-logged-in");
-      this.notifyObj.message = "Signed in as: user@example.com";
-      this.notifyObj.mainAction.label = "Sign Out";
-      this.notifyObj.mainAction.accessKey = "O";
-      Services.obs.notifyObservers({ wrappedJSObject: this.notifyOptions },
-                                   "identity-login-state-changed", TEST_EMAIL);
-      executeSoon(function() {
-        PopupNotifications.getNotification("identity-logged-in").anchorElement.click();
-      });
-    },
-
-    onShown: function(popup) {
-      checkPopup(popup, this.notifyObj);
-
-      // This time trigger the Sign Out button and make sure the UI goes away.
-      triggerMainCommand(popup);
-    },
-
-    onHidden: function(popup) {},
-  },
+let TESTS = [
+  test_smoke,
+  test_mockDoc,
+  test_watch,
+  //test_HostFrame,
+  //test_getUIForWindowID,
+  //test_ResizeWatcher
 ];
 
-function test_auth() {
-  let notifyOptions = {
-    provId: outerWinId,
-    origin: TEST_ORIGIN,
-  };
+TESTS.forEach(add_test);
 
-  Services.obs.addObserver(function() {
-    // prepare to send auth-complete and close the window
-    let winCloseObs = new WindowObserver(function(closedWin) {
-      info("closed window");
-      finish();
-    }, "domwindowclosed");
-    Services.ww.registerNotification(winCloseObs);
-    Services.obs.notifyObservers(null, "identity-auth-complete", IdentityService.IDP.authenticationFlowSet.authId);
-
-  }, "test-identity-auth-window", false);
-
-  let winObs = new WindowObserver(function(authWin) {
-    ok(authWin, "Authentication window opened");
-    ok(authWin.contentWindow.location);
-  });
-
-  Services.ww.registerNotification(winObs);
-
-  Services.obs.notifyObservers({ wrappedJSObject: notifyOptions },
-                               "identity-auth", TEST_ORIGIN + "/auth");
+function run_test() {
+  run_next_test();
 }
-
-function test() {
-  waitForExplicitFinish();
-
-  registerCleanupFunction(cleanUp);
-
-  let sitw = {};
-  Components.utils.import("resource:///modules/SignInToWebsite.jsm", sitw);
-
-  ok(sitw.SignInToWebsiteUX, "SignInToWebsiteUX object exists");
-
-  // Replace implementation of ID Service functions for testing
-  window.selectIdentity = sitw.SignInToWebsiteUX.selectIdentity;
-  sitw.SignInToWebsiteUX.selectIdentity = function(aRpId, aIdentity) {
-    info("Identity selected: " + aIdentity);
-    window.gIdentitySelected = {rpId: aRpId, identity: aIdentity};
-  };
-
-  window.setAuthenticationFlow = IdentityService.IDP.setAuthenticationFlow;
-  IdentityService.IDP.setAuthenticationFlow = function(aAuthId, aProvId) {
-    info("setAuthenticationFlow: " + aAuthId + " : " + aProvId);
-    this.authenticationFlowSet = { authId: aAuthId, provId: aProvId };
-    Services.obs.notifyObservers(null, "test-identity-auth-window", aAuthId);
-  };
-
-  runNextTest();
-}
-
-// Cleanup between tests
-function resetState() {
-  delete window.gIdentitySelected;
-  delete IdentityService.IDP.authenticationFlowSet;
-  IdentityService.reset();
-}
-
-// Cleanup after all tests
-function cleanUp() {
-  info("cleanup");
-  resetState();
-
-  for (let topic in gActiveObservers)
-    Services.obs.removeObserver(gActiveObservers[topic], topic);
-  for (let eventName in gActiveListeners)
-    PopupNotifications.panel.removeEventListener(eventName, gActiveListeners[eventName], false);
-  delete IdentityService.RP._rpFlows[outerWinId];
-
-  // Put the JSM functions back to how they were
-  IdentityService.IDP.setAuthenticationFlow = window.setAuthenticationFlow;
-  delete window.setAuthenticationFlow;
-
-  let sitw = {};
-  Components.utils.import("resource:///modules/SignInToWebsite.jsm", sitw);
-  sitw.SignInToWebsiteUX.selectIdentity = window.selectIdentity;
-  delete window.selectIdentity;
-
-  Services.prefs.clearUserPref("toolkit.identity.debug");
-}
-
-let gActiveListeners = {};
-let gActiveObservers = {};
-let gShownState = {};
-
-function runNextTest() {
-  let nextTest = tests[gTestIndex];
-
-  function goNext() {
-    resetState();
-    if (++gTestIndex == tests.length)
-      executeSoon(test_auth);
-    else
-      executeSoon(runNextTest);
-  }
-
-  function addObserver(topic) {
-    function observer() {
-      Services.obs.removeObserver(observer, "PopupNotifications-" + topic);
-      delete gActiveObservers["PopupNotifications-" + topic];
-
-      info("[Test #" + gTestIndex + "] observer for " + topic + " called");
-      nextTest[topic]();
-      goNext();
-    }
-    Services.obs.addObserver(observer, "PopupNotifications-" + topic, false);
-    gActiveObservers["PopupNotifications-" + topic] = observer;
-  }
-
-  if (nextTest.backgroundShow) {
-    addObserver("backgroundShow");
-  } else if (nextTest.updateNotShowing) {
-    addObserver("updateNotShowing");
-  } else {
-    doOnPopupEvent("popupshowing", function () {
-      info("[Test #" + gTestIndex + "] popup showing");
-    });
-    doOnPopupEvent("popupshown", function () {
-      gShownState[gTestIndex] = true;
-      info("[Test #" + gTestIndex + "] popup shown");
-      nextTest.onShown(this);
-    });
-
-    // We allow multiple onHidden functions to be defined in an array.  They're
-    // called in the order they appear.
-    let onHiddenArray = nextTest.onHidden instanceof Array ?
-                        nextTest.onHidden :
-                        [nextTest.onHidden];
-    doOnPopupEvent("popuphidden", function () {
-      if (!gShownState[gTestIndex]) {
-        // TODO: needed?
-        info("Popup from test " + gTestIndex + " was hidden before its popupshown fired");
-      }
-
-      let onHidden = onHiddenArray.shift();
-      info("[Test #" + gTestIndex + "] popup hidden (" + onHiddenArray.length + " hides remaining)");
-      executeSoon(function () {
-        onHidden.call(nextTest, this);
-        if (!onHiddenArray.length)
-          goNext();
-      }.bind(this));
-    }, onHiddenArray.length);
-    info("[Test #" + gTestIndex + "] added listeners; panel state: " + PopupNotifications.isPanelOpen);
-  }
-
-  info("[Test #" + gTestIndex + "] running test");
-  nextTest.run();
-}
-
-function doOnPopupEvent(eventName, callback, numExpected) {
-  gActiveListeners[eventName] = function (event) {
-    if (event.target != PopupNotifications.panel)
-      return;
-    if (typeof(numExpected) === "number")
-      numExpected--;
-    if (!numExpected) {
-      PopupNotifications.panel.removeEventListener(eventName, gActiveListeners[eventName], false);
-      delete gActiveListeners[eventName];
-    }
-
-    callback.call(PopupNotifications.panel);
-  };
-  PopupNotifications.panel.addEventListener(eventName, gActiveListeners[eventName], false);
-}
-
-function checkPopup(popup, notificationObj) {
-  info("[Test #" + gTestIndex + "] checking popup");
-
-  let notifications = popup.childNodes;
-  is(notifications.length, 1, "only one notification displayed");
-  let notification = notifications[0];
-  let icon = document.getAnonymousElementByAttribute(notification, "class", "popup-notification-icon");
-  is(notification.getAttribute("label"), notificationObj.message, "message matches");
-  is(notification.id, notificationObj.id + "-notification", "id matches");
-  if (notificationObj.id != "identity-request" && notificationObj.mainAction) {
-    is(notification.getAttribute("buttonlabel"), notificationObj.mainAction.label, "main action label matches");
-    is(notification.getAttribute("buttonaccesskey"), notificationObj.mainAction.accessKey, "main action accesskey matches");
-  }
-  let actualSecondaryActions = notification.childNodes;
-  let secondaryActions = notificationObj.secondaryActions || [];
-  let actualSecondaryActionsCount = actualSecondaryActions.length;
-  if (secondaryActions.length) {
-    let lastChild = actualSecondaryActions.item(actualSecondaryActions.length - 1);
-    is(lastChild.tagName, "menuseparator", "menuseparator exists");
-    actualSecondaryActionsCount--;
-  }
-  is(actualSecondaryActionsCount, secondaryActions.length, actualSecondaryActions.length + " secondary actions");
-  secondaryActions.forEach(function (a, i) {
-    is(actualSecondaryActions[i].getAttribute("label"), a.label, "label for secondary action " + i + " matches");
-    is(actualSecondaryActions[i].getAttribute("accesskey"), a.accessKey, "accessKey for secondary action " + i + " matches");
-  });
-}
-
-function triggerMainCommand(popup) {
-  info("[Test #" + gTestIndex + "] triggering main command");
-  let notifications = popup.childNodes;
-  ok(notifications.length > 0, "at least one notification displayed");
-  let notification = notifications[0];
-
-  // 20, 10 so that the inner button is hit
-  EventUtils.synthesizeMouse(notification.button, 20, 10, {});
-}
-
-function triggerSecondaryCommand(popup, index) {
-  info("[Test #" + gTestIndex + "] triggering secondary command");
-  let notifications = popup.childNodes;
-  ok(notifications.length > 0, "at least one notification displayed");
-  let notification = notifications[0];
-
-  notification.button.focus();
-
-  popup.addEventListener("popupshown", function () {
-    popup.removeEventListener("popupshown", arguments.callee, false);
-
-    // Press down until the desired command is selected
-    for (let i = 0; i <= index; i++)
-      EventUtils.synthesizeKey("VK_DOWN", {});
-
-    // Activate
-    EventUtils.synthesizeKey("VK_ENTER", {});
-  }, false);
-
-  // One down event to open the popup
-  EventUtils.synthesizeKey("VK_DOWN", { altKey: (navigator.platform.indexOf("Mac") == -1) });
-}
-
-function dismissNotification(popup) {
-  info("[Test #" + gTestIndex + "] dismissing notification");
-  executeSoon(function () {
-    EventUtils.synthesizeKey("VK_ESCAPE", {});
-  });
-}
-
-function partial(fn) {
-  let args = Array.prototype.slice.call(arguments, 1);
-  return function() {
-    return fn.apply(this, args.concat(Array.prototype.slice.call(arguments)));
-  };
-}
-
-// create a mock "doc" object, which the Identity Service
-// uses as a pointer back into the doc object
-function mock_doc(aIdentity, aOrigin, aDoFunc) {
-  let mockedDoc = {};
-  mockedDoc.id = outerWinId;
-  mockedDoc.loggedInEmail = aIdentity;
-  mockedDoc.origin = aOrigin;
-  mockedDoc['do'] = aDoFunc;
-  mockedDoc.doReady = partial(aDoFunc, 'ready');
-  mockedDoc.doLogin = partial(aDoFunc, 'login');
-  mockedDoc.doLogout = partial(aDoFunc, 'logout');
-  mockedDoc.doError = partial(aDoFunc, 'error');
-  mockedDoc.doCancel = partial(aDoFunc, 'cancel');
-  mockedDoc.doCoffee = partial(aDoFunc, 'coffee');
-
-  return mockedDoc;
-}
-
-// takes a list of functions and returns a function that
-// when called the first time, calls the first func,
-// then the next time the second, etc.
-function call_sequentially() {
-  let numCalls = 0;
-  let funcs = arguments;
-
-  return function() {
-    if (!funcs[numCalls]) {
-      let argString = Array.prototype.slice.call(arguments).join(",");
-      ok(false, "Too many calls: " + argString);
-      return;
-    }
-    funcs[numCalls].apply(funcs[numCalls], arguments);
-    numCalls += 1;
-  };
-}
-
-function setupRPFlow(aIdentity) {
-  IdentityService.RP.watch(mock_doc(aIdentity, TEST_ORIGIN, call_sequentially(
-    function(action, params) {
-      is(action, "ready", "1st callback");
-      is(params, null);
-    },
-    function(action, params) {
-      is(action, "logout", "2nd callback");
-      is(params, null);
-    },
-    function(action, params) {
-      is(action, "ready", "3rd callback");
-      is(params, null);
-    }
-  )));
-}
-
-function WindowObserver(aCallback, aObserveTopic = "domwindowopened") {
-  this.observe = function(aSubject, aTopic, aData) {
-    if (aTopic != aObserveTopic) {
-      return;
-    }
-    info(aObserveTopic);
-    Services.ww.unregisterNotification(this);
-
-    SimpleTest.executeSoon(function() {
-      let domWin = aSubject.QueryInterface(Ci.nsIDOMWindow);
-      aCallback(domWin);
-    });
-  };
-}
diff --git a/browser/modules/test/unit/xpcshell.ini b/browser/modules/test/unit/xpcshell.ini
new file mode 100644
--- /dev/null
+++ b/browser/modules/test/unit/xpcshell.ini
@@ -0,0 +1,6 @@
+[DEFAULT]
+head = head_identity.js
+tail = 
+
+[test_SignInToWebsite.js]
+
diff --git a/dom/identity/DOMIdentity.jsm b/dom/identity/DOMIdentity.jsm
--- a/dom/identity/DOMIdentity.jsm
+++ b/dom/identity/DOMIdentity.jsm
@@ -9,33 +9,26 @@ const {classes: Cc, interfaces: Ci, util
 // This is the parent process corresponding to nsDOMIdentity.
 this.EXPORTED_SYMBOLS = ["DOMIdentity"];
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/identity/IdentityUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "IdentityService",
-#ifdef MOZ_B2G_VERSION
-                                  "resource://gre/modules/identity/MinimalIdentity.jsm");
-#else
-                                  "resource://gre/modules/identity/Identity.jsm");
-#endif
-
-XPCOMUtils.defineLazyModuleGetter(this,
-                                  "Logger",
-                                  "resource://gre/modules/identity/LogUtils.jsm");
+                                  "resource://gre/modules/identity/IdentityService.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "ppmm",
                                    "@mozilla.org/parentprocessmessagemanager;1",
                                    "nsIMessageListenerManager");
 
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["DOMIdentity"].concat(aMessageArgs));
-}
+XPCOMUtils.defineLazyGetter(this, "logger", function() {
+  Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+  return getLogger("Identity", "toolkit.identity.debug");
+});
 
 function IDDOMMessage(aOptions) {
   objectCopy(aOptions, this);
 }
 
 function IDPProvisioningContext(aID, aOrigin, aTargetMM) {
   this._id = aID;
   this._origin = aOrigin;
@@ -50,24 +43,24 @@ IDPProvisioningContext.prototype = {
     let message = new IDDOMMessage({id: this.id});
     message.identity = aID;
     message.certDuration = aCertDuration;
     this._mm.sendAsyncMessage("Identity:IDP:CallBeginProvisioningCallback",
                               message);
   },
 
   doGenKeyPairCallback: function IDPPC_doGenKeyPairCallback(aPublicKey) {
-    log("doGenKeyPairCallback");
+    logger.log("doGenKeyPairCallback");
     let message = new IDDOMMessage({id: this.id});
     message.publicKey = aPublicKey;
     this._mm.sendAsyncMessage("Identity:IDP:CallGenKeyPairCallback", message);
   },
 
   doError: function(msg) {
-    log("Provisioning ERROR: " + msg);
+    logger.warning(msg);
   }
 };
 
 function IDPAuthenticationContext(aID, aOrigin, aTargetMM) {
   this._id = aID;
   this._origin = aOrigin;
   this._mm = aTargetMM;
 }
@@ -79,61 +72,63 @@ IDPAuthenticationContext.prototype = {
   doBeginAuthenticationCallback: function IDPAC_doBeginAuthCB(aIdentity) {
     let message = new IDDOMMessage({id: this.id});
     message.identity = aIdentity;
     this._mm.sendAsyncMessage("Identity:IDP:CallBeginAuthenticationCallback",
                               message);
   },
 
   doError: function IDPAC_doError(msg) {
-    log("Authentication ERROR: " + msg);
+    logger.warning(msg);
   }
 };
 
 function RPWatchContext(aOptions, aTargetMM) {
   objectCopy(aOptions, this);
 
   // id and origin are required
   if (! (this.id && this.origin)) {
-    throw new Error("id and origin are required for RP watch context");
+    let err = "id and origin are required for RP watch context";
+    logger.error(err);
+    throw new Error(err);
   }
 
   // default for no loggedInUser is undefined, not null
   this.loggedInUser = aOptions.loggedInUser;
 
   // Maybe internal
   this._internal = aOptions._internal;
 
   this._mm = aTargetMM;
 }
 
 RPWatchContext.prototype = {
   doLogin: function RPWatchContext_onlogin(aAssertion, aMaybeInternalParams) {
-    log("doLogin: " + this.id);
+    logger.log("login id: " + this.id);
     let message = new IDDOMMessage({id: this.id, assertion: aAssertion});
     if (aMaybeInternalParams) {
       message._internalParams = aMaybeInternalParams;
     }
     this._mm.sendAsyncMessage("Identity:RP:Watch:OnLogin", message);
   },
 
   doLogout: function RPWatchContext_onlogout() {
-    log("doLogout: " + this.id);
+    logger.log("logout id: " + this.id);
     let message = new IDDOMMessage({id: this.id});
     this._mm.sendAsyncMessage("Identity:RP:Watch:OnLogout", message);
   },
 
   doReady: function RPWatchContext_onready() {
-    log("doReady: " + this.id);
+    logger.log("ready id: " + this.id);
     let message = new IDDOMMessage({id: this.id});
     this._mm.sendAsyncMessage("Identity:RP:Watch:OnReady", message);
   },
 
   doCancel: function RPWatchContext_oncancel() {
-    log("doCancel: " + this.id);
+    logger.log("cancel id: " + this.id);
     let message = new IDDOMMessage({id: this.id});
     this._mm.sendAsyncMessage("Identity:RP:Watch:OnCancel", message);
   },
 
   doError: function RPWatchContext_onerror(aMessage) {
     log("doError: " + aMessage);
   }
 };
@@ -142,16 +137,18 @@ this.DOMIdentity = {
   // nsIMessageListener
   receiveMessage: function DOMIdentity_receiveMessage(aMessage) {
     let msg = aMessage.json;
 
     // Target is the frame message manager that called us and is
     // used to send replies back to the proper window.
     let targetMM = aMessage.target;
 
+    logger.log("received:", aMessage.name);
+
     switch (aMessage.name) {
       // RP
       case "Identity:RP:Watch":
         this._watch(msg, targetMM);
         break;
       case "Identity:RP:Unwatch":
         this._unwatch(msg, targetMM);
         break;
@@ -212,16 +209,17 @@ this.DOMIdentity = {
              "Identity:RP:Unwatch",
              "child-process-shutdown"],
 
   // Private.
   _init: function DOMIdentity__init() {
     Services.ww.registerNotification(this);
     Services.obs.addObserver(this, "xpcom-shutdown", false);
     this._subscribeListeners();
+    logger.log("DOM identity service initialized");
   },
 
   _subscribeListeners: function DOMIdentity__subscribeListeners() {
     if (!ppmm) return;
     for (let message of this.messages) {
       ppmm.addMessageListener(message, this);
     }
   },
@@ -229,26 +227,28 @@ this.DOMIdentity = {
   _unsubscribeListeners: function DOMIdentity__unsubscribeListeners() {
     for (let message of this.messages) {
       ppmm.removeMessageListener(message, this);
     }
     ppmm = null;
   },
 
   _resetFrameState: function(aContext) {
-    log("_resetFrameState: ", aContext.id);
+    logger.log("_resetFrameState: ", aContext.id);
     if (!aContext._mm) {
-      throw new Error("ERROR: Trying to reset an invalid context");
+      let err = "Trying to reset an invalid context";
+      logger.error(err);
+      throw new Error(err);
     }
     let message = new IDDOMMessage({id: aContext.id});
     aContext._mm.sendAsyncMessage("Identity:ResetState", message);
   },
 
   _watch: function DOMIdentity__watch(message, targetMM) {
-    log("DOMIdentity__watch: " + message.id);
+    logger.log("DOMIdentity__watch: " + message.id);
     // Pass an object with the watch members to Identity.jsm so it can call the
     // callbacks.
     let context = new RPWatchContext(message, targetMM);
     IdentityService.RP.watch(context);
   },
 
   _unwatch: function DOMIdentity_unwatch(message, targetMM) {
     IdentityService.RP.unwatch(message.id, targetMM);
diff --git a/dom/identity/nsDOMIdentity.js b/dom/identity/nsDOMIdentity.js
--- a/dom/identity/nsDOMIdentity.js
+++ b/dom/identity/nsDOMIdentity.js
@@ -18,22 +18,28 @@ const PREF_SYNTHETIC_EVENTS_OK = "dom.id
 const MAX_STRING_LENGTH = 2048;
 // Maximum number of times navigator.id.request can be called for a document
 const MAX_RP_CALLS = 100;
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/identity/IdentityUtils.jsm");
 
+XPCOMUtils.defineLazyGetter(this, "logger", function() {
+  Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+  return getLogger("Identity", "toolkit.identity.debug");
+});
+
 // This is the child process corresponding to nsIDOMIdentity
 XPCOMUtils.defineLazyServiceGetter(this, "cpmm",
                                    "@mozilla.org/childprocessmessagemanager;1",
                                    "nsIMessageSender");
 
 function nsDOMIdentity(aIdentityInternal) {
+  logger.log("nsDOMIdentity constructor");
   this._identityInternal = aIdentityInternal;
 }
 nsDOMIdentity.prototype = {
   __exposedProps__: {
     // Relying Party (RP)
     watch: 'r',
     request: 'r',
     logout: 'r',
@@ -60,22 +66,27 @@ nsDOMIdentity.prototype = {
     return true;
   },
 
   /**
    * Relying Party (RP) APIs
    */
 
   watch: function nsDOMIdentity_watch(aOptions) {
+    logger.log(aOptions);
     if (this._rpWatcher) {
-      throw new Error("navigator.id.watch was already called");
+      let err = "navigator.id.watch was already called";
+      logger.warning(err);
+      throw new Error(err);
     }
 
     if (!aOptions || typeof(aOptions) !== "object") {
-      throw new Error("options argument to watch is required");
+      let err = "options argument to watch is required";
+      logger.warning(err);
+      throw new Error(err);
     }
 
     // Check for required callbacks
     let requiredCallbacks = ["onlogin", "onlogout"];
     for (let cbName of requiredCallbacks) {
       if ((!(cbName in aOptions))
           || typeof(aOptions[cbName]) !== "function") {
            throw new Error(cbName + " callback is required.");
@@ -84,16 +95,17 @@ nsDOMIdentity.prototype = {
 
     // Optional callback "onready"
     if (aOptions["onready"]
         && typeof(aOptions['onready']) !== "function") {
       throw new Error("onready must be a function");
     }
 
     let message = this.DOMIdentityMessage(aOptions);
+    logger.log(message);
 
     // loggedInUser vs loggedInEmail
     // https://developer.mozilla.org/en-US/docs/DOM/navigator.id.watch
     // This parameter, loggedInUser, was renamed from loggedInEmail in early
     // September, 2012. Both names will continue to work for the time being,
     // but code should be changed to use loggedInUser instead.
     checkRenamed(aOptions, "loggedInEmail", "loggedInUser");
     message["loggedInUser"] = aOptions["loggedInUser"];
@@ -108,44 +120,47 @@ nsDOMIdentity.prototype = {
       // See HTMLInputElement::IsValidEmailAddress
       if (aOptions["loggedInUser"].indexOf("@") == -1
           || aOptions["loggedInUser"].length > MAX_STRING_LENGTH) {
         throw new Error("loggedInUser is not valid");
       }
       // Set loggedInUser in this block that "undefined" doesn't get through.
       message.loggedInUser = aOptions.loggedInUser;
     }
-    this._log("loggedInUser: " + message.loggedInUser);
+    logger.log("loggedInUser: " + message.loggedInUser);
 
     this._rpWatcher = aOptions;
     this._identityInternal._mm.sendAsyncMessage("Identity:RP:Watch", message);
   },
 
   request: function nsDOMIdentity_request(aOptions) {
+    aOptions = aOptions || {};
+
     let util = this._window.QueryInterface(Ci.nsIInterfaceRequestor)
                            .getInterface(Ci.nsIDOMWindowUtils);
 
     // The only time we permit calling of request() outside of a user
     // input handler is when we are handling the (deprecated) get() or
     // getVerifiedEmail() calls, which make use of an RP context
     // marked as _internal.
     if (this.nativeEventsRequired && !util.isHandlingUserInput && !aOptions._internal) {
-      this._log("request: rejecting non-native event");
+      logger.error("request: rejecting non-native event");
       return;
     }
 
     // Has the caller called watch() before this?
     if (!this._rpWatcher) {
       throw new Error("navigator.id.request called before navigator.id.watch");
     }
     if (this._rpCalls > MAX_RP_CALLS) {
       throw new Error("navigator.id.request called too many times");
     }
 
     let message = this.DOMIdentityMessage(aOptions);
+    logger.log(message);
 
     if (aOptions) {
       // Optional string properties
       let optionalStringProps = ["privacyPolicy", "termsOfService"];
       for (let propName of optionalStringProps) {
         if (!aOptions[propName] || aOptions[propName] === "undefined")
           continue;
         if (typeof(aOptions[propName]) !== "string") {
@@ -166,16 +181,17 @@ nsDOMIdentity.prototype = {
       }
     }
 
     this._rpCalls++;
     this._identityInternal._mm.sendAsyncMessage("Identity:RP:Request", message);
   },
 
   logout: function nsDOMIdentity_logout() {
+    logger.log("logout");
     if (!this._rpWatcher) {
       throw new Error("navigator.id.logout called before navigator.id.watch");
     }
     if (this._rpCalls > MAX_RP_CALLS) {
       throw new Error("navigator.id.logout called too many times");
     }
 
     this._rpCalls++;
@@ -238,72 +254,72 @@ nsDOMIdentity.prototype = {
       onlogout: function get_onlogout() {},
       onready: function get_onready() {
         self.request(opts);
       }
     });
   },
 
   getVerifiedEmail: function nsDOMIdentity_getVerifiedEmail(aCallback) {
-    Cu.reportError("WARNING: getVerifiedEmail has been deprecated");
+    error("WARNING: getVerifiedEmail has been deprecated");
     this.get(aCallback, {});
   },
 
   /**
    *  Identity Provider (IDP) Provisioning APIs
    */
 
   beginProvisioning: function nsDOMIdentity_beginProvisioning(aCallback) {
-    this._log("beginProvisioning");
+    logger.log("beginProvisioning");
     if (this._beginProvisioningCallback) {
       throw new Error("navigator.id.beginProvisioning already called.");
     }
     if (!aCallback || typeof(aCallback) !== "function") {
       throw new Error("beginProvisioning callback is required.");
     }
 
     this._beginProvisioningCallback = aCallback;
     this._identityInternal._mm.sendAsyncMessage("Identity:IDP:BeginProvisioning",
                                                 this.DOMIdentityMessage());
   },
 
   genKeyPair: function nsDOMIdentity_genKeyPair(aCallback) {
-    this._log("genKeyPair");
+    logger.log("genKeyPair");
     if (!this._beginProvisioningCallback) {
       throw new Error("navigator.id.genKeyPair called outside of provisioning");
     }
     if (this._genKeyPairCallback) {
       throw new Error("navigator.id.genKeyPair already called.");
     }
     if (!aCallback || typeof(aCallback) !== "function") {
       throw new Error("genKeyPair callback is required.");
     }
 
     this._genKeyPairCallback = aCallback;
     this._identityInternal._mm.sendAsyncMessage("Identity:IDP:GenKeyPair",
                                                 this.DOMIdentityMessage());
   },
 
   registerCertificate: function nsDOMIdentity_registerCertificate(aCertificate) {
-    this._log("registerCertificate");
+    logger.log("registerCertificate");
     if (!this._genKeyPairCallback) {
       throw new Error("navigator.id.registerCertificate called outside of provisioning");
     }
     if (this._provisioningEnded) {
       throw new Error("Provisioning already ended");
     }
     this._provisioningEnded = true;
 
     let message = this.DOMIdentityMessage();
     message.cert = aCertificate;
     this._identityInternal._mm.sendAsyncMessage("Identity:IDP:RegisterCertificate", message);
   },
 
   raiseProvisioningFailure: function nsDOMIdentity_raiseProvisioningFailure(aReason) {
-    this._log("raiseProvisioningFailure '" + aReason + "'");
+    logger.log("raiseProvisioningFailure '" + aReason + "'");
     if (this._provisioningEnded) {
       throw new Error("Provisioning already ended");
     }
     if (!aReason || typeof(aReason) != "string") {
       throw new Error("raiseProvisioningFailure reason is required");
     }
     this._provisioningEnded = true;
 
@@ -312,17 +328,17 @@ nsDOMIdentity.prototype = {
     this._identityInternal._mm.sendAsyncMessage("Identity:IDP:ProvisioningFailure", message);
   },
 
   /**
    *  Identity Provider (IDP) Authentication APIs
    */
 
   beginAuthentication: function nsDOMIdentity_beginAuthentication(aCallback) {
-    this._log("beginAuthentication");
+    logger.log("beginAuthentication");
     if (this._beginAuthenticationCallback) {
       throw new Error("navigator.id.beginAuthentication already called.");
     }
     if (typeof(aCallback) !== "function") {
       throw new Error("beginAuthentication callback is required.");
     }
     if (!aCallback || typeof(aCallback) !== "function") {
       throw new Error("beginAuthentication callback is required.");
@@ -400,54 +416,54 @@ nsDOMIdentity.prototype = {
           return;
         }
         this._initializeState();
         Services.obs.notifyObservers(null, "identity-DOM-state-reset", this._id);
         break;
       case "Identity:RP:Watch:OnLogin":
         // Do we have a watcher?
         if (!this._rpWatcher) {
-          this._log("WARNING: Received OnLogin message, but there is no RP watcher");
+          logger.warning("Received OnLogin message, but there is no RP watcher");
           return;
         }
 
         if (this._rpWatcher.onlogin) {
           if (this._rpWatcher._internal) {
             this._rpWatcher.onlogin(msg.assertion, msg._internalParams);
           } else {
             this._rpWatcher.onlogin(msg.assertion);
           }
         }
         break;
       case "Identity:RP:Watch:OnLogout":
         // Do we have a watcher?
         if (!this._rpWatcher) {
-          this._log("WARNING: Received OnLogout message, but there is no RP watcher");
+          logger.warning("Received OnLogout message, but there is no RP watcher");
           return;
         }
 
         if (this._rpWatcher.onlogout) {
           this._rpWatcher.onlogout();
         }
         break;
       case "Identity:RP:Watch:OnReady":
         // Do we have a watcher?
         if (!this._rpWatcher) {
-          this._log("WARNING: Received OnReady message, but there is no RP watcher");
+          logger.warning("Received OnReady message, but there is no RP watcher");
           return;
         }
 
         if (this._rpWatcher.onready) {
           this._rpWatcher.onready();
         }
         break;
       case "Identity:RP:Watch:OnCancel":
         // Do we have a watcher?
         if (!this._rpWatcher) {
-          this._log("WARNING: Received OnCancel message, but there is no RP watcher");
+          logger.warning("Received OnCancel message, but there is no RP watcher");
           return;
         }
 
         if (this._onCancelRequestCallback) {
           this._onCancelRequestCallback();
         }
         break;
       case "Identity:IDP:CallBeginProvisioningCallback":
@@ -457,20 +473,16 @@ nsDOMIdentity.prototype = {
         this._callGenKeyPairCallback(msg);
         break;
       case "Identity:IDP:CallBeginAuthenticationCallback":
         this._callBeginAuthenticationCallback(msg);
         break;
     }
   },
 
-  _log: function nsDOMIdentity__log(msg) {
-    this._identityInternal._log(msg);
-  },
-
   _callGenKeyPairCallback: function nsDOMIdentity__callGenKeyPairCallback(message) {
     // create a pubkey object that works
     let chrome_pubkey = JSON.parse(message.publicKey);
 
     // bunch of stuff to create a proper object in window context
     function genPropDesc(value) {
       return {
         enumerable: true, configurable: true, writable: true, value: value
@@ -520,17 +532,17 @@ nsDOMIdentity.prototype = {
 
     // window origin
     message.origin = this._origin;
 
     return message;
   },
 
   uninit: function DOMIdentity_uninit() {
-    this._log("nsDOMIdentity uninit()");
+    logger.log("unwatch", this._id);
     this._identityInternal._mm.sendAsyncMessage(
       "Identity:RP:Unwatch",
       { id: this._id }
     );
   }
 
 };
 
@@ -593,17 +605,17 @@ nsDOMIdentityInternal.prototype = {
 
     this._identity._init(aWindow);
 
     let util = aWindow.QueryInterface(Ci.nsIInterfaceRequestor)
                       .getInterface(Ci.nsIDOMWindowUtils);
     this._id = util.outerWindowID;
     this._innerWindowID = util.currentInnerWindowID;
 
-    this._log("init was called from " + aWindow.document.location);
+    logger.log("init was called from", aWindow.document.location);
 
     this._mm = cpmm;
 
     // Setup listeners for messages from parent process.
     this._messages = [
       "Identity:ResetState",
       "Identity:RP:Watch:OnLogin",
       "Identity:RP:Watch:OnLogout",
@@ -618,24 +630,16 @@ nsDOMIdentityInternal.prototype = {
     }, this);
 
     // Setup observers so we can remove message listeners.
     Services.obs.addObserver(this, "inner-window-destroyed", false);
 
     return this._identity;
   },
 
-  // Private.
-  _log: function nsDOMIdentityInternal__log(msg) {
-    if (!this._debug) {
-      return;
-    }
-    dump("nsDOMIdentity (" + this._id + "): " + msg + "\n");
-  },
-
   // Component setup.
   classID: Components.ID("{210853d9-2c97-4669-9761-b1ab9cbf57ef}"),
 
   QueryInterface: XPCOMUtils.generateQI(
     [Ci.nsIDOMGlobalPropertyInitializer, Ci.nsIMessageListener]
   ),
 
   classInfo: XPCOMUtils.generateCI({
diff --git a/dom/identity/tests/Makefile.in b/dom/identity/tests/Makefile.in
new file mode 100644
--- /dev/null
+++ b/dom/identity/tests/Makefile.in
@@ -0,0 +1,20 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this file,
+# You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DEPTH            = @DEPTH@
+topsrcdir        = @top_srcdir@
+srcdir           = @srcdir@
+VPATH            = @srcdir@
+
+relativesrcdir   = @relativesrcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MOCHITEST_FILES = \
+  head_identity.js \
+  test_rp.html \
+  $(NULL)
+
+include $(topsrcdir)/config/rules.mk
+
diff --git a/dom/identity/tests/head_identity.js b/dom/identity/tests/head_identity.js
new file mode 100644
--- /dev/null
+++ b/dom/identity/tests/head_identity.js
@@ -0,0 +1,132 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+const Cc = SpecialPowers.Cc;
+const Ci = SpecialPowers.Ci;
+const Cu = SpecialPowers.Cu;
+
+const Services = Cu.import("resource://gre/modules/Services.jsm").Services;
+const XPCOMUtils = Cu.import('resource://gre/modules/XPCOMUtils.jsm').XPCOMUtils;
+
+SpecialPowers.setBoolPref("toolkit.identity.debug", true);
+SpecialPowers.setBoolPref("dom.identity.enabled", true);
+SpecialPowers.setBoolPref("dom.identity.syntheticEventsOk", true);
+
+const DOMIdentity = Cu.import("resource://gre/modules/DOMIdentity.jsm")
+                      .DOMIdentity;
+
+let util = SpecialPowers.getDOMWindowUtils(window);
+let outerWinId = util.outerWindowID;
+
+const getLogger = Cu.import("resource://gre/modules/identity/LogUtils.jsm").getLogger;
+const logger = getLogger("Identity DOM test", "toolkit.identity.debug");
+
+const identity = navigator.id || navigator.mozId;
+
+const MOCK_INCLUDEJS = "http://example.org/browser/browser/modules/test/mock_personaIframe.html";
+const MOCK_IFRAME = "http://example.org/browser/browser/modules/test/mock_personaIframe.html";
+const MOCK_DIALOG = "http://example.org/browser/browser/modules/test/mock_personaIframe.html";
+
+let index = 0;
+
+// Intercept all requests to get the persona iframes and redirect
+// them to our local mock.
+function RequestListener() {
+  Services.obs.addObserver(this, "http-on-modify-request", false);
+  logger.log("Listening for http-on-modify-request");
+}
+
+RequestListener.prototype = {
+  observe: function observe(aSubject, aTopic, aData) {
+    if (aTopic === "http-on-modify-request") {
+      let channel = SpecialPowers.wrap(aSubject).QueryInterface(Ci.nsIHttpChannel);
+      let ioservice = Cc["@mozilla.org/network/io-service;1"]
+                        .getService(Ci.nsIIOService);
+      let src = channel.URI.spec;
+      let target = null;
+      if (src.match(/include.js/)) target = MOCK_INCLUDEJS;
+      if (src.match(/communication_iframe/)) target = MOCK_IFRAME;
+      if (src.match(/sign_in/)) target = MOCK_DIALOG;
+      if (target) {
+        let redirect = ioservice.newURI(target, null, null);
+        try {
+          logger.log("Intercepting http request and redirecting", src, "->", target);
+          channel.redirectTo(redirect);
+        } catch (err) {
+          do_throw("Redirect failed: " + err);
+        }
+      }
+    }
+  },
+
+  remove: function() {
+    Services.obs.removeObserver(this, "http-on-modify-request");
+  }
+};
+
+window.requestListener = new RequestListener();
+
+// mimicking callback funtionality for ease of testing
+// this observer auto-removes itself after the observe function
+// is called, so this is meant to observe only ONE event.
+function makeObserver(aObserveTopic, aObserveFunc) {
+  function observe(aSubject, aTopic, aData) {
+    if (aTopic == aObserveTopic) {
+      aObserveFunc(aSubject, aTopic, aData);
+      Services.obs.removeObserver(this, aObserveTopic);
+    }
+  }
+
+  Services.obs.addObserver(observe, aObserveTopic, false);
+}
+
+function expectException(aFunc, msg, aErrorType="Error") {
+  info("Expecting an exception: " + msg);
+  msg = msg || "";
+  let caughtEx = null;
+  try {
+    aFunc();
+  } catch (ex) {
+    let exProto = Object.getPrototypeOf(ex);
+    // Don't count NS_* exceptions since they shouldn't be exposed to content
+    if (exProto.toString() == aErrorType
+        && ex.toString().indexOf("NS_ERROR_FAILURE") == -1) {
+      caughtEx = ex;
+    } else {
+      ok(false, ex);
+      return;
+    }
+  }
+  isnot(caughtEx, null, "Check for thrown exception.");
+}
+
+function next() {
+  if (!identity) {
+    todo(false, "DOM API is not available. Skipping tests.");
+    finish_tests();
+    return;
+  }
+  if (index >= steps.length) {
+    ok(false, "Shouldn't get here!");
+    return;
+  }
+  try {
+    let fn = steps[index];
+    info("Begin test " + index + " '" + steps[index].name + "'!");
+    fn();
+  } catch(ex) {
+    ok(false, "Caught exception", ex);
+  }
+  index += 1;
+}
+
+function finish_tests() {
+  info("all done");
+  SpecialPowers.clearUserPref("toolkit.identity.debug");
+  SpecialPowers.clearUserPref("dom.identity.enabled");
+  window.requestListener.remove();
+  SimpleTest.finish();
+}
+
diff --git a/dom/identity/tests/test_rp.html b/dom/identity/tests/test_rp.html
new file mode 100644
--- /dev/null
+++ b/dom/identity/tests/test_rp.html
@@ -0,0 +1,106 @@
+<!DOCTYPE html>
+<!-- Any copyright is dedicated to the Public Domain.
+   - http://creativecommons.org/publicdomain/zero/1.0/ -->
+<html>
+<head>
+  <meta charset="utf-8">
+  <title>Test for navigator.id relying party (RP) basics</title>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="application/javascript;version=1.8" src="head_identity.js"></script>
+</head>
+<body>
+<a target="_blank">navigator.id RP basics</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+<script type="application/javascript;version=1.8">
+
+"use strict";
+
+const RP = Cu.import("resource://gre/modules/identity/IdentityService.jsm").IdentityService.RP;
+
+function resetAndNext() {
+  // Watch can only be called once per page.  So reset
+  // the state before moving on to the next test.
+  makeObserver("identity-DOM-state-reset", function stateReset() {
+    SimpleTest.executeSoon(next);
+  });
+
+  let context = RP._rpFlows[outerWinId];
+  DOMIdentity._resetFrameState(context);
+}
+
+let steps = [
+  function nonExistentProp() {
+    is(identity.foobarbaz, undefined, "Check that foobarbaz does not exist");
+    expectException(function() {
+      identity.foobarbaz()
+    }, "Check for exception calling non-existent method", "TypeError");
+    SimpleTest.executeSoon(next);
+  },
+
+  function watchExists() {
+    is(typeof(identity.watch), "function", "Check watch is a function");
+    SimpleTest.executeSoon(next);
+  },
+
+  function requestExists() {
+    is(typeof(identity.request), "function", "Check request is a function");
+    SimpleTest.executeSoon(next);
+  },
+
+  function logoutExists() {
+    is(typeof(identity.logout), "function", "Check logout is a function");
+    SimpleTest.executeSoon(next);
+  },
+
+  function testWatch() {
+    function onReady() {
+      resetAndNext();
+    }
+    identity.watch({
+      onlogin: function(){},
+      onlogout: function(){},
+      onready: onReady
+    });
+  },
+
+  function testLogout() {
+    identity.watch({
+      onlogin: function(){},
+      onlogout: function() {
+        resetAndNext();
+      },
+      onready: function() {
+        identity.logout();
+      }
+    }); 
+  },
+
+  function testLogin() {
+    identity.watch({
+      onlogin: function(assertion) {
+        is(assertion, "I love your shoes!", "Get an assertion on request()");
+        resetAndNext();
+      },
+      onlogout: function() {},
+      onready: function() {
+        identity.request();
+      }
+    });
+  },
+
+  finish_tests
+];
+
+SimpleTest.waitForExplicitFinish();
+addLoadEvent(next);
+</script>
+</pre>
+</body>
+</html>
+
diff --git a/toolkit/identity/Identity.jsm b/toolkit/identity/Identity.jsm
deleted file mode 100644
--- a/toolkit/identity/Identity.jsm
+++ /dev/null
@@ -1,305 +0,0 @@
-/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-this.EXPORTED_SYMBOLS = ["IdentityService"];
-
-const Cu = Components.utils;
-const Ci = Components.interfaces;
-const Cc = Components.classes;
-const Cr = Components.results;
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/identity/LogUtils.jsm");
-Cu.import("resource://gre/modules/identity/IdentityStore.jsm");
-Cu.import("resource://gre/modules/identity/RelyingParty.jsm");
-Cu.import("resource://gre/modules/identity/IdentityProvider.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this,
-                                  "jwcrypto",
-                                  "resource://gre/modules/identity/jwcrypto.jsm");
-
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["core"].concat(aMessageArgs));
-}
-function reportError(...aMessageArgs) {
-  Logger.reportError.apply(Logger, ["core"].concat(aMessageArgs));
-}
-
-function IDService() {
-  Services.obs.addObserver(this, "quit-application-granted", false);
-  Services.obs.addObserver(this, "identity-auth-complete", false);
-
-  this._store = IdentityStore;
-  this.RP = RelyingParty;
-  this.IDP = IdentityProvider;
-}
-
-IDService.prototype = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports, Ci.nsIObserver]),
-
-  observe: function observe(aSubject, aTopic, aData) {
-    switch (aTopic) {
-      case "quit-application-granted":
-        Services.obs.removeObserver(this, "quit-application-granted");
-        this.shutdown();
-        break;
-      case "identity-auth-complete":
-        if (!aSubject || !aSubject.wrappedJSObject)
-          break;
-        let subject = aSubject.wrappedJSObject;
-        log("Auth complete:", aSubject.wrappedJSObject);
-        // We have authenticated in order to provision an identity.
-        // So try again.
-        this.selectIdentity(subject.rpId, subject.identity);
-        break;
-    }
-  },
-
-  reset: function reset() {
-    // Explicitly call reset() on our RP and IDP classes.
-    // This is here to make testing easier.  When the
-    // quit-application-granted signal is emitted, reset() will be
-    // called here, on RP, on IDP, and on the store.  So you don't
-    // need to use this :)
-    this._store.reset();
-    this.RP.reset();
-    this.IDP.reset();
-  },
-
-  shutdown: function shutdown() {
-    log("shutdown");
-    Services.obs.removeObserver(this, "identity-auth-complete");
-    Services.obs.removeObserver(this, "quit-application-granted");
-  },
-
-  /**
-   * Parse an email into username and domain if it is valid, else return null
-   */
-  parseEmail: function parseEmail(email) {
-    var match = email.match(/^([^@]+)@([^@^/]+.[a-z]+)$/);
-    if (match) {
-      return {
-        username: match[1],
-        domain: match[2]
-      };
-    }
-    return null;
-  },
-
-  /**
-   * The UX wants to add a new identity
-   * often followed by selectIdentity()
-   *
-   * @param aIdentity
-   *        (string) the email chosen for login
-   */
-  addIdentity: function addIdentity(aIdentity) {
-    if (this._store.fetchIdentity(aIdentity) === null) {
-      this._store.addIdentity(aIdentity, null, null);
-    }
-  },
-
-  /**
-   * The UX comes back and calls selectIdentity once the user has picked
-   * an identity.
-   *
-   * @param aRPId
-   *        (integer) the id of the doc object obtained in .watch() and
-   *                  passed to the UX component.
-   *
-   * @param aIdentity
-   *        (string) the email chosen for login
-   */
-  selectIdentity: function selectIdentity(aRPId, aIdentity) {
-    log("selectIdentity: RP id:", aRPId, "identity:", aIdentity);
-
-    // Get the RP that was stored when watch() was invoked.
-    let rp = this.RP._rpFlows[aRPId];
-    if (!rp) {
-      reportError("selectIdentity", "Invalid RP id: ", aRPId);
-      return;
-    }
-
-    // It's possible that we are in the process of provisioning an
-    // identity.
-    let provId = rp.provId;
-
-    let rpLoginOptions = {
-      loggedInUser: aIdentity,
-      origin: rp.origin
-    };
-    log("selectIdentity: provId:", provId, "origin:", rp.origin);
-
-    // Once we have a cert, and once the user is authenticated with the
-    // IdP, we can generate an assertion and deliver it to the doc.
-    let self = this;
-    this.RP._generateAssertion(rp.origin, aIdentity, function hadReadyAssertion(err, assertion) {
-      if (!err && assertion) {
-        self.RP._doLogin(rp, rpLoginOptions, assertion);
-        return;
-
-      }
-      // Need to provision an identity first.  Begin by discovering
-      // the user's IdP.
-      self._discoverIdentityProvider(aIdentity, function gotIDP(err, idpParams) {
-        if (err) {
-          rp.doError(err);
-          return;
-        }
-
-        // The idpParams tell us where to go to provision and authenticate
-        // the identity.
-        self.IDP._provisionIdentity(aIdentity, idpParams, provId, function gotID(err, aProvId) {
-
-          // Provision identity may have created a new provision flow
-          // for us.  To make it easier to relate provision flows with
-          // RP callers, we cross index the two here.
-          rp.provId = aProvId;
-          self.IDP._provisionFlows[aProvId].rpId = aRPId;
-
-          // At this point, we already have a cert.  If the user is also
-          // already authenticated with the IdP, then we can try again
-          // to generate an assertion and login.
-          if (err) {
-            // We are not authenticated.  If we have already tried to
-            // authenticate and failed, then this is a "hard fail" and
-            // we give up.  Otherwise we try to authenticate with the
-            // IdP.
-
-            if (self.IDP._provisionFlows[aProvId].didAuthentication) {
-              self.IDP._cleanUpProvisionFlow(aProvId);
-              self.RP._cleanUpProvisionFlow(aRPId, aProvId);
-              log("ERROR: selectIdentity: authentication hard fail");
-              rp.doError("Authentication fail.");
-              return;
-            }
-            // Try to authenticate with the IdP.  Note that we do
-            // not clean up the provision flow here.  We will continue
-            // to use it.
-            self.IDP._doAuthentication(aProvId, idpParams);
-            return;
-          }
-
-          // Provisioning flows end when a certificate has been registered.
-          // Thus IdentityProvider's registerCertificate() cleans up the
-          // current provisioning flow.  We only do this here on error.
-          self.RP._generateAssertion(rp.origin, aIdentity, function gotAssertion(err, assertion) {
-            if (err) {
-              rp.doError(err);
-              return;
-            }
-            self.RP._doLogin(rp, rpLoginOptions, assertion);
-            self.RP._cleanUpProvisionFlow(aRPId, aProvId);
-            return;
-          });
-        });
-      });
-    });
-  },
-
-  // methods for chrome and add-ons
-
-  /**
-   * Discover the IdP for an identity
-   *
-   * @param aIdentity
-   *        (string) the email we're logging in with
-   *
-   * @param aCallback
-   *        (function) callback to invoke on completion
-   *                   with first-positional parameter the error.
-   */
-  _discoverIdentityProvider: function _discoverIdentityProvider(aIdentity, aCallback) {
-    // XXX bug 767610 - validate email address call
-    // When that is available, we can remove this custom parser
-    var parsedEmail = this.parseEmail(aIdentity);
-    if (parsedEmail === null) {
-      return aCallback("Could not parse email: " + aIdentity);
-    }
-    log("_discoverIdentityProvider: identity:", aIdentity, "domain:", parsedEmail.domain);
-
-    this._fetchWellKnownFile(parsedEmail.domain, function fetchedWellKnown(err, idpParams) {
-      // idpParams includes the pk, authorization url, and
-      // provisioning url.
-
-      // XXX bug 769861 follow any authority delegations
-      // if no well-known at any point in the delegation
-      // fall back to browserid.org as IdP
-      return aCallback(err, idpParams);
-    });
-  },
-
-  /**
-   * Fetch the well-known file from the domain.
-   *
-   * @param aDomain
-   *
-   * @param aScheme
-   *        (string) (optional) Protocol to use.  Default is https.
-   *                 This is necessary because we are unable to test
-   *                 https.
-   *
-   * @param aCallback
-   *
-   */
-  _fetchWellKnownFile: function _fetchWellKnownFile(aDomain, aCallback, aScheme='https') {
-    // XXX bug 769854 make tests https and remove aScheme option
-    let url = aScheme + '://' + aDomain + "/.well-known/browserid";
-    log("_fetchWellKnownFile:", url);
-
-    // this appears to be a more successful way to get at xmlhttprequest (which supposedly will close with a window
-    let req = Cc["@mozilla.org/xmlextras/xmlhttprequest;1"]
-                .createInstance(Ci.nsIXMLHttpRequest);
-
-    // XXX bug 769865 gracefully handle being off-line
-    // XXX bug 769866 decide on how to handle redirects
-    req.open("GET", url, true);
-    req.responseType = "json";
-    req.mozBackgroundRequest = true;
-    req.onload = function _fetchWellKnownFile_onload() {
-      if (req.status < 200 || req.status >= 400) {
-        log("_fetchWellKnownFile", url, ": server returned status:", req.status);
-        return aCallback("Error");
-      }
-      try {
-        let idpParams = req.response;
-
-        // Verify that the IdP returned a valid configuration
-        if (! (idpParams.provisioning &&
-            idpParams.authentication &&
-            idpParams['public-key'])) {
-          let errStr= "Invalid well-known file from: " + aDomain;
-          log("_fetchWellKnownFile:", errStr);
-          return aCallback(errStr);
-        }
-
-        let callbackObj = {
-          domain: aDomain,
-          idpParams: idpParams,
-        };
-        log("_fetchWellKnownFile result: ", callbackObj);
-        // Yay.  Valid IdP configuration for the domain.
-        return aCallback(null, callbackObj);
-
-      } catch (err) {
-        reportError("_fetchWellKnownFile", "Bad configuration from", aDomain, err);
-        return aCallback(err.toString());
-      }
-    };
-    req.onerror = function _fetchWellKnownFile_onerror() {
-      log("_fetchWellKnownFile", "ERROR:", req.status, req.statusText);
-      log("ERROR: _fetchWellKnownFile:", err);
-      return aCallback("Error");
-    };
-    req.send(null);
-  },
-
-};
-
-this.IdentityService = new IDService();
diff --git a/toolkit/identity/IdentityProvider.jsm b/toolkit/identity/IdentityProvider.jsm
deleted file mode 100644
--- a/toolkit/identity/IdentityProvider.jsm
+++ /dev/null
@@ -1,494 +0,0 @@
-/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-const Cu = Components.utils;
-const Ci = Components.interfaces;
-const Cc = Components.classes;
-const Cr = Components.results;
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/identity/LogUtils.jsm");
-Cu.import("resource://gre/modules/identity/Sandbox.jsm");
-
-this.EXPORTED_SYMBOLS = ["IdentityProvider"];
-const FALLBACK_PROVIDER = "browserid.org";
-
-XPCOMUtils.defineLazyModuleGetter(this,
-                                  "jwcrypto",
-                                  "resource://gre/modules/identity/jwcrypto.jsm");
-
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["IDP"].concat(aMessageArgs));
-}
-function reportError(...aMessageArgs) {
-  Logger.reportError.apply(Logger, ["IDP"].concat(aMessageArgs));
-}
-
-
-function IdentityProviderService() {
-  XPCOMUtils.defineLazyModuleGetter(this,
-                                    "_store",
-                                    "resource://gre/modules/identity/IdentityStore.jsm",
-                                    "IdentityStore");
-
-  this.reset();
-}
-
-IdentityProviderService.prototype = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports, Ci.nsIObserver]),
-  _sandboxConfigured: false,
-
-  observe: function observe(aSubject, aTopic, aData) {
-    switch (aTopic) {
-      case "quit-application-granted":
-        Services.obs.removeObserver(this, "quit-application-granted");
-        this.shutdown();
-        break;
-    }
-  },
-
-  reset: function IDP_reset() {
-    // Clear the provisioning flows.  Provision flows contain an
-    // identity, idpParams (how to reach the IdP to provision and
-    // authenticate), a callback (a completion callback for when things
-    // are done), and a provisioningFrame (which is the provisioning
-    // sandbox).  Additionally, two callbacks will be attached:
-    // beginProvisioningCallback and genKeyPairCallback.
-    this._provisionFlows = {};
-
-    // Clear the authentication flows.  Authentication flows attach
-    // to provision flows.  In the process of provisioning an id, it
-    // may be necessary to authenticate with an IdP.  The authentication
-    // flow maintains the state of that authentication process.
-    this._authenticationFlows = {};
-  },
-
-  getProvisionFlow: function getProvisionFlow(aProvId, aErrBack) {
-    let provFlow = this._provisionFlows[aProvId];
-    if (provFlow) {
-      return provFlow;
-    }
-
-    let err = "No provisioning flow found with id " + aProvId;
-    log("ERROR:", err);
-    if (typeof aErrBack === 'function') {
-      aErrBack(err);
-    }
-  },
-
-  shutdown: function RP_shutdown() {
-    this.reset();
-
-    if (this._sandboxConfigured) {
-      // Tear down message manager listening on the hidden window
-      Cu.import("resource://gre/modules/DOMIdentity.jsm");
-      DOMIdentity._configureMessages(Services.appShell.hiddenDOMWindow, false);
-      this._sandboxConfigured = false;
-    }
-
-    Services.obs.removeObserver(this, "quit-application-granted");
-  },
-
-  get securityLevel() {
-    return 1;
-  },
-
-  get certDuration() {
-    switch(this.securityLevel) {
-      default:
-        return 3600;
-    }
-  },
-
-  /**
-   * Provision an Identity
-   *
-   * @param aIdentity
-   *        (string) the email we're logging in with
-   *
-   * @param aIDPParams
-   *        (object) parameters of the IdP
-   *
-   * @param aCallback
-   *        (function) callback to invoke on completion
-   *                   with first-positional parameter the error.
-   */
-  _provisionIdentity: function _provisionIdentity(aIdentity, aIDPParams, aProvId, aCallback) {
-    let provPath = aIDPParams.idpParams.provisioning;
-    let url = Services.io.newURI("https://" + aIDPParams.domain, null, null).resolve(provPath);
-    log("_provisionIdentity: identity:", aIdentity, "url:", url);
-
-    // If aProvId is not null, then we already have a flow
-    // with a sandbox.  Otherwise, get a sandbox and create a
-    // new provision flow.
-
-    if (aProvId) {
-      // Re-use an existing sandbox
-      log("_provisionIdentity: re-using sandbox in provisioning flow with id:", aProvId);
-      this._provisionFlows[aProvId].provisioningSandbox.reload();
-
-    } else {
-      this._createProvisioningSandbox(url, function createdSandbox(aSandbox) {
-        // create a provisioning flow, using the sandbox id, and
-        // stash callback associated with this provisioning workflow.
-
-        let provId = aSandbox.id;
-        this._provisionFlows[provId] = {
-          identity: aIdentity,
-          idpParams: aIDPParams,
-          securityLevel: this.securityLevel,
-          provisioningSandbox: aSandbox,
-          callback: function doCallback(aErr) {
-            aCallback(aErr, provId);
-          },
-        };
-
-        log("_provisionIdentity: Created sandbox and provisioning flow with id:", provId);
-        // XXX bug 769862 - provisioning flow should timeout after N seconds
-
-      }.bind(this));
-    }
-  },
-
-  // DOM Methods
-  /**
-   * the provisioning iframe sandbox has called navigator.id.beginProvisioning()
-   *
-   * @param aCaller
-   *        (object)  the iframe sandbox caller with all callbacks and
-   *                  other information.  Callbacks include:
-   *                  - doBeginProvisioningCallback(id, duration_s)
-   *                  - doGenKeyPairCallback(pk)
-   */
-  beginProvisioning: function beginProvisioning(aCaller) {
-    log("beginProvisioning:", aCaller.id);
-
-    // Expect a flow for this caller already to be underway.
-    let provFlow = this.getProvisionFlow(aCaller.id, aCaller.doError);
-
-    // keep the caller object around
-    provFlow.caller = aCaller;
-
-    let identity = provFlow.identity;
-    let frame = provFlow.provisioningFrame;
-
-    // Determine recommended length of cert.
-    let duration = this.certDuration;
-
-    // Make a record that we have begun provisioning.  This is required
-    // for genKeyPair.
-    provFlow.didBeginProvisioning = true;
-
-    // Let the sandbox know to invoke the callback to beginProvisioning with
-    // the identity and cert length.
-    return aCaller.doBeginProvisioningCallback(identity, duration);
-  },
-
-  /**
-   * the provisioning iframe sandbox has called
-   * navigator.id.raiseProvisioningFailure()
-   *
-   * @param aProvId
-   *        (int)  the identifier of the provisioning flow tied to that sandbox
-   * @param aReason
-   */
-  raiseProvisioningFailure: function raiseProvisioningFailure(aProvId, aReason) {
-    reportError("Provisioning failure", aReason);
-
-    // look up the provisioning caller and its callback
-    let provFlow = this.getProvisionFlow(aProvId);
-
-    // Sandbox is deleted in _cleanUpProvisionFlow in case we re-use it.
-
-    // This may be either a "soft" or "hard" fail.  If it's a
-    // soft fail, we'll flow through setAuthenticationFlow, where
-    // the provision flow data will be copied into a new auth
-    // flow.  If it's a hard fail, then the callback will be
-    // responsible for cleaning up the now defunct provision flow.
-
-    // invoke the callback with an error.
-    provFlow.callback(aReason);
-  },
-
-  /**
-   * When navigator.id.genKeyPair is called from provisioning iframe sandbox.
-   * Generates a keypair for the current user being provisioned.
-   *
-   * @param aProvId
-   *        (int)  the identifier of the provisioning caller tied to that sandbox
-   *
-   * It is an error to call genKeypair without receiving the callback for
-   * the beginProvisioning() call first.
-   */
-  genKeyPair: function genKeyPair(aProvId) {
-    // Look up the provisioning caller and make sure it's valid.
-    let provFlow = this.getProvisionFlow(aProvId);
-
-    if (!provFlow.didBeginProvisioning) {
-      let errStr = "ERROR: genKeyPair called before beginProvisioning";
-      log(errStr);
-      provFlow.callback(errStr);
-      return;
-    }
-
-    // Ok generate a keypair
-    jwcrypto.generateKeyPair(jwcrypto.ALGORITHMS.DS160, function gkpCb(err, kp) {
-      log("in gkp callback");
-      if (err) {
-        log("ERROR: genKeyPair:", err);
-        provFlow.callback(err);
-        return;
-      }
-
-      provFlow.kp = kp;
-
-      // Serialize the publicKey of the keypair and send it back to the
-      // sandbox.
-      log("genKeyPair: generated keypair for provisioning flow with id:", aProvId);
-      provFlow.caller.doGenKeyPairCallback(provFlow.kp.serializedPublicKey);
-    }.bind(this));
-  },
-
-  /**
-   * When navigator.id.registerCertificate is called from provisioning iframe
-   * sandbox.
-   *
-   * Sets the certificate for the user for which a certificate was requested
-   * via a preceding call to beginProvisioning (and genKeypair).
-   *
-   * @param aProvId
-   *        (integer) the identifier of the provisioning caller tied to that
-   *                  sandbox
-   *
-   * @param aCert
-   *        (String)  A JWT representing the signed certificate for the user
-   *                  being provisioned, provided by the IdP.
-   */
-  registerCertificate: function registerCertificate(aProvId, aCert) {
-    log("registerCertificate:", aProvId, aCert);
-
-    // look up provisioning caller, make sure it's valid.
-    let provFlow = this.getProvisionFlow(aProvId);
-
-    if (!provFlow.caller) {
-      reportError("registerCertificate", "No provision flow or caller");
-      return;
-    }
-    if (!provFlow.kp)  {
-      let errStr = "Cannot register a certificate without a keypair";
-      reportError("registerCertificate", errStr);
-      provFlow.callback(errStr);
-      return;
-    }
-
-    // store the keypair and certificate just provided in IDStore.
-    this._store.addIdentity(provFlow.identity, provFlow.kp, aCert);
-
-    // Great success!
-    provFlow.callback(null);
-
-    // Clean up the flow.
-    this._cleanUpProvisionFlow(aProvId);
-  },
-
-  /**
-   * Begin the authentication process with an IdP
-   *
-   * @param aProvId
-   *        (int) the identifier of the provisioning flow which failed
-   *
-   * @param aCallback
-   *        (function) to invoke upon completion, with
-   *                   first-positional-param error.
-   */
-  _doAuthentication: function _doAuthentication(aProvId, aIDPParams) {
-    log("_doAuthentication: provId:", aProvId, "idpParams:", aIDPParams);
-    // create an authentication caller and its identifier AuthId
-    // stash aIdentity, idpparams, and callback in it.
-
-    // extract authentication URL from idpParams
-    let authPath = aIDPParams.idpParams.authentication;
-    let authURI = Services.io.newURI("https://" + aIDPParams.domain, null, null).resolve(authPath);
-
-    // beginAuthenticationFlow causes the "identity-auth" topic to be
-    // observed.  Since it's sending a notification to the DOM, there's
-    // no callback.  We wait for the DOM to trigger the next phase of
-    // provisioning.
-    this._beginAuthenticationFlow(aProvId, authURI);
-
-    // either we bind the AuthID to the sandbox ourselves, or UX does that,
-    // in which case we need to tell UX the AuthId.
-    // Currently, the UX creates the UI and gets the AuthId from the window
-    // and sets is with setAuthenticationFlow
-  },
-
-  /**
-   * The authentication frame has called navigator.id.beginAuthentication
-   *
-   * IMPORTANT: the aCaller is *always* non-null, even if this is called from
-   * a regular content page. We have to make sure, on every DOM call, that
-   * aCaller is an expected authentication-flow identifier. If not, we throw
-   * an error or something.
-   *
-   * @param aCaller
-   *        (object)  the authentication caller
-   *
-   */
-  beginAuthentication: function beginAuthentication(aCaller) {
-    log("beginAuthentication: caller id:", aCaller.id);
-
-    // Begin the authentication flow after having concluded a provisioning
-    // flow.  The aCaller that the DOM gives us will have the same ID as
-    // the provisioning flow we just concluded.  (see setAuthenticationFlow)
-    let authFlow = this._authenticationFlows[aCaller.id];
-    if (!authFlow) {
-      return aCaller.doError("beginAuthentication: no flow for caller id", aCaller.id);
-    }
-
-    authFlow.caller = aCaller;
-
-    let identity = this._provisionFlows[authFlow.provId].identity;
-
-    // tell the UI to start the authentication process
-    log("beginAuthentication: authFlow:", aCaller.id, "identity:", identity);
-    return authFlow.caller.doBeginAuthenticationCallback(identity);
-  },
-
-  /**
-   * The auth frame has called navigator.id.completeAuthentication
-   *
-   * @param aAuthId
-   *        (int)  the identifier of the authentication caller tied to that sandbox
-   *
-   */
-  completeAuthentication: function completeAuthentication(aAuthId) {
-    log("completeAuthentication:", aAuthId);
-
-    // look up the AuthId caller, and get its callback.
-    let authFlow = this._authenticationFlows[aAuthId];
-    if (!authFlow) {
-      reportError("completeAuthentication", "No auth flow with id", aAuthId);
-      return;
-    }
-    let provId = authFlow.provId;
-
-    // delete caller
-    delete authFlow['caller'];
-    delete this._authenticationFlows[aAuthId];
-
-    let provFlow = this.getProvisionFlow(provId);
-    provFlow.didAuthentication = true;
-    let subject = {
-      rpId: provFlow.rpId,
-      identity: provFlow.identity,
-    };
-    Services.obs.notifyObservers({ wrappedJSObject: subject }, "identity-auth-complete", aAuthId);
-  },
-
-  /**
-   * The auth frame has called navigator.id.cancelAuthentication
-   *
-   * @param aAuthId
-   *        (int)  the identifier of the authentication caller
-   *
-   */
-  cancelAuthentication: function cancelAuthentication(aAuthId) {
-    log("cancelAuthentication:", aAuthId);
-
-    // look up the AuthId caller, and get its callback.
-    let authFlow = this._authenticationFlows[aAuthId];
-    if (!authFlow) {
-      reportError("cancelAuthentication", "No auth flow with id:", aAuthId);
-      return;
-    }
-    let provId = authFlow.provId;
-
-    // delete caller
-    delete authFlow['caller'];
-    delete this._authenticationFlows[aAuthId];
-
-    let provFlow = this.getProvisionFlow(provId);
-    provFlow.didAuthentication = true;
-    Services.obs.notifyObservers(null, "identity-auth-complete", aAuthId);
-
-    // invoke callback with ERROR.
-    let errStr = "Authentication canceled by IDP";
-    log("ERROR: cancelAuthentication:", errStr);
-    provFlow.callback(errStr);
-  },
-
-  /**
-   * Called by the UI to set the ID and caller for the authentication flow after it gets its ID
-   */
-  setAuthenticationFlow: function(aAuthId, aProvId) {
-    // this is the transition point between the two flows,
-    // provision and authenticate.  We tell the auth flow which
-    // provisioning flow it is started from.
-    log("setAuthenticationFlow: authId:", aAuthId, "provId:", aProvId);
-    this._authenticationFlows[aAuthId] = { provId: aProvId };
-    this._provisionFlows[aProvId].authId = aAuthId;
-  },
-
-  /**
-   * Load the provisioning URL in a hidden frame to start the provisioning
-   * process.
-   */
-  _createProvisioningSandbox: function _createProvisioningSandbox(aURL, aCallback) {
-    log("_createProvisioningSandbox:", aURL);
-
-    if (!this._sandboxConfigured) {
-      // Configure message manager listening on the hidden window
-      Cu.import("resource://gre/modules/DOMIdentity.jsm");
-      DOMIdentity._configureMessages(Services.appShell.hiddenDOMWindow, true);
-      this._sandboxConfigured = true;
-    }
-
-    new Sandbox(aURL, aCallback);
-  },
-
-  /**
-   * Load the authentication UI to start the authentication process.
-   */
-  _beginAuthenticationFlow: function _beginAuthenticationFlow(aProvId, aURL) {
-    log("_beginAuthenticationFlow:", aProvId, aURL);
-    let propBag = {provId: aProvId};
-
-    Services.obs.notifyObservers({wrappedJSObject:propBag}, "identity-auth", aURL);
-  },
-
-  /**
-   * Clean up a provision flow and the authentication flow and sandbox
-   * that may be attached to it.
-   */
-  _cleanUpProvisionFlow: function _cleanUpProvisionFlow(aProvId) {
-    log('_cleanUpProvisionFlow:', aProvId);
-    let prov = this._provisionFlows[aProvId];
-
-    // Clean up the sandbox, if there is one.
-    if (prov.provisioningSandbox) {
-      let sandbox = this._provisionFlows[aProvId]['provisioningSandbox'];
-      if (sandbox.free) {
-        log('_cleanUpProvisionFlow: freeing sandbox');
-        sandbox.free();
-      }
-      delete this._provisionFlows[aProvId]['provisioningSandbox'];
-    }
-
-    // Clean up a related authentication flow, if there is one.
-    if (this._authenticationFlows[prov.authId]) {
-      delete this._authenticationFlows[prov.authId];
-    }
-
-    // Finally delete the provision flow
-    delete this._provisionFlows[aProvId];
-  }
-
-};
-
-this.IdentityProvider = new IdentityProviderService();
diff --git a/toolkit/identity/IdentityService.jsm b/toolkit/identity/IdentityService.jsm
new file mode 100644
--- /dev/null
+++ b/toolkit/identity/IdentityService.jsm
@@ -0,0 +1,390 @@
+/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+this.EXPORTED_SYMBOLS = ["IdentityService"];
+
+const Cu = Components.utils;
+const Ci = Components.interfaces;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+Cu.import("resource://gre/modules/Services.jsm");
+Cu.import("resource://gre/modules/identity/IdentityUtils.jsm");
+
+XPCOMUtils.defineLazyGetter(this, "logger", function() {
+  Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+  return getLogger("Identity", "toolkit.identity.debug");
+});
+
+function makeMessageObject(aRpCaller) {
+  let options = {};
+
+  options.id = aRpCaller.id;
+  options.origin = aRpCaller.origin;
+
+  // loggedInUser can be undefined, null, or a string
+  options.loggedInUser = aRpCaller.loggedInUser;
+
+  // Special flag for internal calls
+  options._internal = aRpCaller._internal;
+
+  Object.keys(aRpCaller).forEach(function(option) {
+    // Duplicate the callerobject, scrubbing out functions and other
+    // internal variables (like _mm, the message manager object)
+    if (!Object.hasOwnProperty(this, option)
+        && option[0] !== '_'
+        && typeof aRpCaller[option] !== 'function') {
+      options[option] = aRpCaller[option];
+    }
+  });
+
+  // check validity of message structure
+  if ((typeof options.id === 'undefined') ||
+      (typeof options.origin === 'undefined')) {
+    let err = "id and origin required in relying-party message: " + JSON.stringify(options);
+    logger.error(err);
+    throw new Error(err);
+  }
+
+  return options;
+}
+
+function getWindowInfo() {
+  /*
+  let someWindow = Services.wm.getMostRecentWindow('navigator:browser');
+  let windowUtils = someWindow
+    .QueryInterface(Ci.nsIInterfaceRequestor)
+    .getInterface(Ci.nsIDOMWindowUtils);
+
+  let id = windowUtils.outerWindowID;
+  */
+
+  let wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
+                       .getService(Components.interfaces.nsIWindowMediator);
+  let recentWindow = wm.getMostRecentWindow("navigator:browser");
+
+  //let origin = recentWindow.content.document.location || 'resource://your-agent';
+  //logger.log("found origin:", origin);
+
+  let id = recentWindow
+    .content
+    .QueryInterface(Ci.nsIInterfaceRequestor)
+    .getInterface(Ci.nsIDOMWindowUtils)
+    .outerWindowID;
+
+  return({
+    origin: 'resource://your-agent',
+    id: id
+  });
+}
+
+function IDService() {
+  Services.obs.addObserver(this, "quit-application-granted", false);
+
+  // simplify, it's one object
+  this.RP = this;
+  this.IDP = this;
+
+  // keep track of flows
+  this._rpFlows = {};
+  this._authFlows = {};
+  this._provFlows = {};
+}
+
+IDService.prototype = {
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports, Ci.nsIObserver]),
+
+  observe: function IDService_observe(aSubject, aTopic, aData) {
+    switch (aTopic) {
+      case "quit-application-granted":
+        Services.obs.removeObserver(this, "quit-application-granted");
+        break;
+    }
+  },
+
+  /**
+   * Register a listener for a given windowID as a result of a call to
+   * navigator.id.watch().
+   *
+   * @param aCaller
+   *        (Object)  an object that represents the caller document, and
+   *                  is expected to have properties:
+   *                  - id (unique, e.g. uuid)
+   *                  - loggedInUser (string or null)
+   *                  - origin (string)
+   *
+   *                  and a bunch of callbacks
+   *                  - doReady()
+   *                  - doLogin()
+   *                  - doLogout()
+   *                  - doError()
+   *                  - doCancel()
+   *
+   */
+  watch: function IDService_watch(aRpCaller) {
+    // store the caller structure and notify the UI observers
+    this._rpFlows[aRpCaller.id] = aRpCaller;
+
+    let options = makeMessageObject(aRpCaller);
+    logger.log("sending identity-controller-watch:", options);
+    Services.obs.notifyObservers({wrappedJSObject: options},"identity-controller-watch", null);
+  },
+
+  /*
+   * The RP has gone away; remove handles to the hidden iframe.
+   * It's probable that the frame will already have been cleaned up.
+   */
+  unwatch: function IDService_unwatch(aRpId, aTargetMM) {
+    let rp = this._rpFlows[aRpId];
+    if (!rp) {
+      logger.warning("no rp to go with callerId " + aRpId + "\n");
+      return;
+    }
+
+    let options = makeMessageObject({
+      id: aRpId,
+      origin: rp.origin,
+      messageManager: aTargetMM
+    });
+    logger.log("sending identity-controller-unwatch for id", options.id, options.origin);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-unwatch", null);
+  },
+
+  /**
+   * Initiate a login with user interaction as a result of a call to
+   * navigator.id.request().
+   *
+   * @param aRPId
+   *        (integer)  the id of the doc object obtained in .watch()
+   *
+   * @param aOptions
+   *        (Object)  options including privacyPolicy, termsOfService
+   */
+  request: function IDService_request(aRPId, aOptions) {
+    let rp = this._rpFlows[aRPId];
+
+    // Notify UX to display identity picker.
+    // Pass the doc id to UX so it can pass it back to us later.
+    let options = makeMessageObject(rp);
+    objectCopy(aOptions, options);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-request", null);
+  },
+
+  /**
+   * Invoked when a user wishes to logout of a site (for instance, when clicking
+   * on an in-content logout button).
+   *
+   * @param aRpCallerId
+   *        (integer)  the id of the doc object obtained in .watch()
+   *
+   */
+  logout: function IDService_logout(aRpCallerId) {
+    let rp = this._rpFlows[aRpCallerId];
+
+    let options = makeMessageObject(rp);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-logout", null);
+  },
+
+  childProcessShutdown: function IDService_childProcessShutdown(messageManager) {
+    let options = makeMessageObject({messageManager: messageManager, id: null, origin: null});
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-child-process-shutdown", null);
+    Object.keys(this._rpFlows).forEach(function(key) {
+      if (this._rpFlows[key]._mm === messageManager) {
+        logger.log("child process shutdown for rp", key, "- deleting flow");
+        delete this._rpFlows[key];
+      }
+    }, this);
+  },
+
+
+  /**
+   * Sign In To Browser functions:
+   *   getIdentity()
+   *   signIn()
+   *   signOut()
+   *   accountExists()
+   *   createAccount()
+   */
+
+  getIdentity: function IDService_getIdentity(aOptions, aCallback) {
+    let info = getWindowInfo();
+    let rp = {
+      origin: info.origin,
+      id: info.id,
+      onGetIdentity: aCallback
+    };
+    this._rpFlows[info.id] = rp;
+
+    let options = makeMessageObject(rp);
+    objectCopy(aOptions, options);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-getIdentity", null);
+  },
+
+  /**
+   * signIn to browser; callback with assertion on success or null
+   */
+  signIn: function IDService_signIn(aOptions, aCallback) {
+    let info = getWindowInfo();
+    let rp = {
+      id: info.id,
+      origin: info.origin,
+      onSignIn: aCallback
+    };
+    this._rpFlows[info.id] = rp;
+
+    let options = makeMessageObject(rp);
+    objectCopy(aOptions, options);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-signIn", null);
+  },
+
+  signOut: function IDService_signOut(aCallback) {
+    let info = getWindowInfo();
+    let rp = {
+      id: info.id,
+      origin: info.origin,
+      onSignOut: aCallback
+    };
+    this._rpFlows[info.id] = rp;
+
+    let options = makeMessageObject(rp);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-signOut", null);
+  },
+
+  accountExists: function IDService_accountExists(aOptions, aCallback) {
+    let info = getWindowInfo();
+    let rp = {
+      id: info.id,
+      email: aOptions.email,
+      origin: 'dummy-origin',
+      onAccountExists: aCallback
+    };
+    this._rpFlows[info.id] = rp;
+
+    let options = makeMessageObject(rp);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-accountExists", null);
+  },
+
+  createAccount: function IDService_createAccount(aOptions, aCallback) {
+    let info = getWindowInfo();
+    let rp = {
+      id: info.id,
+      origin: info.origin,
+      onCreateAccount: aCallback
+    };
+    this._rpFlows[info.id] = rp;
+
+    let options = makeMessageObject(rp);
+    objectCopy(aOptions, options);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-createAccount", null);
+  },
+
+  /*
+   * once the UI-and-display-logic components have received
+   * notifications, they call back with direct invocation of the
+   * following functions (doLogin, doLogout, or doReady)
+   */
+
+  doLogin: function IDService_doLogin(aRpCallerId, aAssertion, aInternalParams) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (!rp) {
+      logger.warning("no rp to go with callerId " + aRpCallerId + "\n");
+      return;
+    }
+
+    rp.doLogin(aAssertion, aInternalParams);
+  },
+
+  doLogout: function IDService_doLogout(aRpCallerId) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (!rp) {
+      logger.warning("no rp to go with callerId " + aRpCallerId + "\n");
+      return;
+    }
+
+    rp.doLogout();
+  },
+
+  doReady: function IDService_doReady(aRpCallerId) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (!rp) {
+      logger.warning("no rp to go with callerId " + aRpCallerId + "\n");
+      return;
+    }
+
+    rp.doReady();
+  },
+
+  doCancel: function IDService_doCancel(aRpCallerId) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (!rp) {
+      logger.warning("no rp to go with callerId " + aRpCallerId + "\n");
+      return;
+    }
+
+    rp.doCancel();
+  },
+
+  doGetIdentity: function IDService_doGetIdentity(aRpCallerId, aAssertion, aInternalParams) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (!rp) {
+      logger.error("no flow for id", aRpCallerId);
+    }
+    logger.log("got identity with assertion", aAssertion);
+    if (typeof rp.onGetIdentity === 'function') {
+      rp.onGetIdentity(aAssertion, aInternalParams);
+    }
+  },
+
+  doSignIn: function IDService_doSignIn(aRpCallerId, aAssertion, aInternalParams) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (!rp) {
+      logger.error("no flow for id", aRpCallerId);
+    }
+    logger.log("signed in with assertion", aAssertion);
+    if (typeof rp.onSignIn === 'function') {
+      rp.onSignIn(aAssertion, aInternalParams);
+    }
+  },
+
+  doSignOut: function IDService_doSignOut(aRpCallerId) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (rp) {
+      if (typeof rp.onSignOut === 'function') {
+        rp.onSignOut(true);
+      }
+      delete(this._rpFlows[aRpCallerId]);
+    }
+  },
+
+  doAccountExists: function IDService_doAccountExists(aRpCallerId, aExists) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (rp) {
+      if (typeof rp.onAccountExists === 'function') {
+        rp.onAccountExists(aExists);
+      }
+      delete(this._rpFlows[aRpCallerId]);
+    }
+  },
+
+  doCreateAccount: function IDService_doCreateAccount(aRpCallerId, aAssertion) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (rp) {
+      if (typeof rp.onCreateAccount === 'function') {
+        rp.onCreateAccount(aAssertion);
+      }
+      delete(this._rpFlows[aRpCallerId]);
+    }
+  },
+
+  doFoo: function doFoo() {
+    let wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
+                   .getService(Components.interfaces.nsIWindowMediator);
+    let mainWindow = wm.getMostRecentWindow("navigator:browser");
+  }
+};
+
+this.IdentityService = new IDService();
diff --git a/toolkit/identity/IdentityStore.jsm b/toolkit/identity/IdentityStore.jsm
deleted file mode 100644
--- a/toolkit/identity/IdentityStore.jsm
+++ /dev/null
@@ -1,97 +0,0 @@
-/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-const Cu = Components.utils;
-const Ci = Components.interfaces;
-const Cc = Components.classes;
-const Cr = Components.results;
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-
-this.EXPORTED_SYMBOLS = ["IdentityStore"];
-
-// the data store for IDService
-// written as a separate thing so it can easily be mocked
-function IDServiceStore() {
-  this.reset();
-}
-
-// Note: eventually these methods may be async, but we haven no need for this
-// for now, since we're not storing to disk.
-IDServiceStore.prototype = {
-  addIdentity: function addIdentity(aEmail, aKeyPair, aCert) {
-    this._identities[aEmail] = {keyPair: aKeyPair, cert: aCert};
-  },
-  fetchIdentity: function fetchIdentity(aEmail) {
-    return aEmail in this._identities ? this._identities[aEmail] : null;
-  },
-  removeIdentity: function removeIdentity(aEmail) {
-    let data = this._identities[aEmail];
-    delete this._identities[aEmail];
-    return data;
-  },
-  getIdentities: function getIdentities() {
-    // XXX - should clone?
-    return this._identities;
-  },
-  clearCert: function clearCert(aEmail) {
-    // XXX - should remove key from store?
-    this._identities[aEmail].cert = null;
-    this._identities[aEmail].keyPair = null;
-  },
-
-  /**
-   * set the login state for a given origin
-   *
-   * @param aOrigin
-   *        (string) a web origin
-   *
-   * @param aState
-   *        (boolean) whether or not the user is logged in
-   *
-   * @param aEmail
-   *        (email) the email address the user is logged in with,
-   *                or, if not logged in, the default email for that origin.
-   */
-  setLoginState: function setLoginState(aOrigin, aState, aEmail) {
-    if (aState && !aEmail) {
-      throw "isLoggedIn cannot be set to true without an email";
-    }
-    return this._loginStates[aOrigin] = {isLoggedIn: aState, email: aEmail};
-  },
-  getLoginState: function getLoginState(aOrigin) {
-    return aOrigin in this._loginStates ? this._loginStates[aOrigin] : null;
-  },
-  clearLoginState: function clearLoginState(aOrigin) {
-    delete this._loginStates[aOrigin];
-  },
-
-  reset: function Store_reset() {
-    // _identities associates emails with keypairs and certificates
-    this._identities = {};
-
-    // _loginStates associates. remote origins with a login status and
-    // the email the user has chosen as his or her identity when logging
-    // into that origin.
-    this._loginStates = {};
-  },
-
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports, Ci.nsIObserver]),
-
-  observe: function observe(aSubject, aTopic, aData) {
-    switch (aTopic) {
-      case "quit-application-granted":
-        Services.obs.removeObserver(this, "quit-application-granted");
-        this.reset();
-        break;
-    }
-  },
-};
-
-this.IdentityStore = new IDServiceStore();
diff --git a/toolkit/identity/IdentityUtils.jsm b/toolkit/identity/IdentityUtils.jsm
--- a/toolkit/identity/IdentityUtils.jsm
+++ b/toolkit/identity/IdentityUtils.jsm
@@ -1,16 +1,14 @@
 /* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-// functions common to Identity.jsm and MinimalIdentity.jsm
-
 "use strict";
 
 this.EXPORTED_SYMBOLS = [
   "checkDeprecated",
   "checkRenamed",
   "getRandomId",
   "objectCopy"
 ];
@@ -18,40 +16,38 @@ this.EXPORTED_SYMBOLS = [
 const Cu = Components.utils;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyServiceGetter(this, "uuidgen",
                                    "@mozilla.org/uuid-generator;1",
                                    "nsIUUIDGenerator");
 
-XPCOMUtils.defineLazyModuleGetter(this, "Logger",
-                                  "resource://gre/modules/identity/LogUtils.jsm");
-
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["Identity"].concat(aMessageArgs));
-}
+XPCOMUtils.defineLazyGetter(this, "logger", function() {
+  Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+  return getLogger("Identity", "toolkit.identity.debug");
+});
 
 function defined(item) {
   return typeof item !== 'undefined';
 }
 
 var checkDeprecated = this.checkDeprecated = function checkDeprecated(aOptions, aField) {
   if (defined(aOptions[aField])) {
-    log("WARNING: field is deprecated:", aField);
+    logger.log("WARNING: field is deprecated:", aField);
     return true;
   }
   return false;
 };
 
 this.checkRenamed = function checkRenamed(aOptions, aOldName, aNewName) {
   if (defined(aOptions[aOldName]) &&
       defined(aOptions[aNewName])) {
     let err = "You cannot provide both " + aOldName + " and " + aNewName;
-    Logger.reportError(err);
+    logger.error(err);
     throw new Error(err);
   }
 
   if (checkDeprecated(aOptions, aOldName)) {
     aOptions[aNewName] = aOptions[aOldName];
     delete(aOptions[aOldName]);
   }
 };
@@ -59,17 +55,17 @@ this.checkRenamed = function checkRename
 this.getRandomId = function getRandomId() {
   return uuidgen.generateUUID().toString();
 };
 
 /*
  * copy source object into target, excluding private properties
  * (those whose names begin with an underscore)
  */
-this.objectCopy = function objectCopy(source, target){
+this.objectCopy = function objectCopy(source, target) {
   let desc;
   Object.getOwnPropertyNames(source).forEach(function(name) {
     if (name[0] !== '_') {
       desc = Object.getOwnPropertyDescriptor(source, name);
       Object.defineProperty(target, name, desc);
     }
   });
 };
diff --git a/toolkit/identity/LogUtils.jsm b/toolkit/identity/LogUtils.jsm
--- a/toolkit/identity/LogUtils.jsm
+++ b/toolkit/identity/LogUtils.jsm
@@ -1,103 +1,178 @@
 /* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
-this.EXPORTED_SYMBOLS = ["Logger"];
-const PREF_DEBUG = "toolkit.identity.debug";
+this.EXPORTED_SYMBOLS = ["Logger", "getLogger"];
 
 const Cu = Components.utils;
 const Ci = Components.interfaces;
-const Cc = Components.classes;
-const Cr = Components.results;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
-function IdentityLogger() {
-  Services.prefs.addObserver(PREF_DEBUG, this, false);
-  this._debug = Services.prefs.getBoolPref(PREF_DEBUG);
-  return this;
+function Logger(aIdentifier, aEnablingPref) {
+  this._identifier = aIdentifier;
+  this._enablingPref = aEnablingPref;
+
+  // Enabled by default if a pref for toggling the logger is not given
+  this._enabled = !this._enablingPref;
+
+  this.init();
 }
 
-IdentityLogger.prototype = {
+Logger.prototype = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports, Ci.nsIObserver]),
 
+  init: function Logger_init() {
+    if (this._enablingPref) {
+      Services.prefs.addObserver(this._enablingPref, this, false);
+      this._enabled = Services.prefs.getBoolPref(this._enablingPref);
+    }
+  },
+
   observe: function observe(aSubject, aTopic, aData) {
-    switch(aTopic) {
+    switch (aTopic) {
       case "nsPref:changed":
-        this._debug = Services.prefs.getBoolPref(PREF_DEBUG);
+        this._enabled = Services.prefs.getBoolPref(this._enablingPref);
+        dump("LogUtils " +
+             (this._enabled ? "enabled" : "disabled") +
+             " for " + this._identifier + "\n");
         break;
 
       case "quit-application-granted":
-        Services.prefs.removeObserver(PREF_DEBUG, this);
+        Services.prefs.removeObserver(this._enablingPref, this);
         break;
 
       default:
         this.log("Logger observer", "Unknown topic:", aTopic);
         break;
     }
   },
 
-  _generateLogMessage: function _generateLogMessage(aPrefix, args) {
-    // create a string representation of a list of arbitrary things
+  _generatePrefix: function _generatePrefix() {
+    let caller = Components.stack.caller.caller;
+    let parts = ['[' + this._identifier + ']'];
+
+    // filename could be like path/to/foo.js or Scratchpad/1
+    if (caller.filename) {
+      let path = caller.filename.split('/');
+      if (path[path.length - 1].match(/\./)) {
+        parts.push(path[path.length - 1])
+      } else {
+        parts.push(caller.filename);
+      }
+    }
+
+    // Might not be called from a function; might be top-level
+    if (caller.name) {
+      parts.push(caller.name + '()');
+    }
+
+    parts.push('line ' + caller.lineNumber + ': ');
+
+    return parts.join(' ');
+  },
+
+  _generateLogMessage: function _generateLogMessage(severity, argList) {
     let strings = [];
-
-    // XXX bug 770418 - args look like flattened array, not list of strings
-
-    args.forEach(function(arg) {
-      if (typeof arg === 'string') {
-        strings.push(arg);
-      } else if (typeof arg === 'undefined') {
-        strings.push('undefined');
-      } else if (arg === null) {
+    argList.forEach(function(arg) {
+      if (arg === null) {
         strings.push('null');
       } else {
-        try {
-          strings.push(JSON.stringify(arg, null, 2));
-        } catch(err) {
-          strings.push("<<something>>");
+        switch (typeof arg) {
+          case 'string':
+            strings.push(arg);
+            break;
+          case 'undefined':
+            strings.push('undefined');
+            break;
+          case 'function':
+            strings.push('<<function>>');
+            break;
+          case 'object':
+            try {
+              strings.push(JSON.stringify(arg, null, 2));
+            } catch (err) {
+              strings.push('<<object>>');
+            }
+            break;
+          default:
+            try {
+              strings.push(arg.toString());
+            } catch (err) {
+              strings.push('<<something>>');
+            }
+            break;
         }
       }
     });
-    return 'Identity ' + aPrefix + ': ' + strings.join(' ');
+    return strings.join(' ');
   },
 
   /**
    * log() - utility function to print a list of arbitrary things
    *
    * Enable with about:config pref toolkit.identity.debug
    */
-  log: function log(aPrefix, ...args) {
-    if (!this._debug) {
+  log: function log(...argList) {
+    if (!this._enabled) {
       return;
     }
-    let output = this._generateLogMessage(aPrefix, args);
+    let output = this._generatePrefix() + this._generateLogMessage('info', argList);
+
+    // print to the shell console and the browser error console
     dump(output + "\n");
-
-    // Additionally, make the output visible in the Error Console
     Services.console.logStringMessage(output);
   },
 
+  warning: function Logger_warning(...argList) {
+    if (!this._enabled) {
+      return;
+    }
+
+    let output = this._generatePrefix() + this._generateLogMessage('warning', argList);
+  },
+
   /**
-   * reportError() - report an error through component utils as well as
+   * error() - report an error through component utils as well as
    * our log function
    */
-  reportError: function reportError(aPrefix, ...aArgs) {
-    let prefix = aPrefix + ' ERROR';
+  error: function Logger_error(...argList) {
+    if (!this._enabled) {
+      return;
+    }
 
     // Report the error in the browser
-    let output = this._generateLogMessage(aPrefix, aArgs);
+    let output = this._generatePrefix() + this._generateLogMessage('error', argList);
     Cu.reportError(output);
+
+    // print to the console
     dump("ERROR: " + output + "\n");
+    dump("   traceback follows:\n");
     for (let frame = Components.stack.caller; frame; frame = frame.caller) {
       dump(frame + "\n");
     }
   }
-
 };
 
-this.Logger = new IdentityLogger();
+/**
+ * let logger = getLogger('my component', 'toolkit.foo.debug');
+ * logger.log("I would like", 42, "pies", {'and-some': 'object'});
+ */
+
+let _loggers = {};
+
+this.getLogger = function(aIdentifier, aEnablingPref) {
+  let key = aIdentifier;
+  if (aEnablingPref) {
+    key = key + '-' + aEnablingPref;
+  }
+  if (!_loggers[key]) {
+    _loggers[key] = new Logger(aIdentifier, aEnablingPref);
+  }
+  return _loggers[key];
+}
diff --git a/toolkit/identity/Makefile.in b/toolkit/identity/Makefile.in
--- a/toolkit/identity/Makefile.in
+++ b/toolkit/identity/Makefile.in
@@ -18,22 +18,17 @@ LIBXUL_LIBRARY = 1
 IS_COMPONENT = 1
 EXPORT_LIBRARY = 1
 
 CPPSRCS = \
   IdentityCryptoService.cpp \
   $(NULL)
 
 EXTRA_JS_MODULES = \
+	jwcrypto.jsm \
 	IdentityUtils.jsm \
-	Identity.jsm \
-	IdentityProvider.jsm \
-	IdentityStore.jsm \
-	jwcrypto.jsm \
 	LogUtils.jsm \
-	MinimalIdentity.jsm \
-	RelyingParty.jsm \
-	Sandbox.jsm \
+	IdentityService.jsm \
 	$(NULL)
 
 JS_MODULES_PATH = $(FINAL_TARGET)/modules/identity
 
 include $(topsrcdir)/config/rules.mk
diff --git a/toolkit/identity/MinimalIdentity.jsm b/toolkit/identity/MinimalIdentity.jsm
deleted file mode 100644
--- a/toolkit/identity/MinimalIdentity.jsm
+++ /dev/null
@@ -1,445 +0,0 @@
-/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-/*
- * This alternate implementation of IdentityService provides just the
- * channels for navigator.id, leaving the certificate storage to a
- * server-provided app.
- *
- * On b2g, the messages identity-controller-watch, -request, and
- * -logout, are observed by the component SignInToWebsite.jsm.
- */
-
-"use strict";
-
-this.EXPORTED_SYMBOLS = ["IdentityService"];
-
-const Cu = Components.utils;
-const Ci = Components.interfaces;
-const Cc = Components.classes;
-const Cr = Components.results;
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/identity/LogUtils.jsm");
-Cu.import("resource://gre/modules/identity/IdentityUtils.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this,
-                                  "jwcrypto",
-                                  "resource://gre/modules/identity/jwcrypto.jsm");
-
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["minimal core"].concat(aMessageArgs));
-}
-function reportError(...aMessageArgs) {
-  Logger.reportError.apply(Logger, ["core"].concat(aMessageArgs));
-}
-
-function makeMessageObject(aRpCaller) {
-  let options = {};
-
-  options.id = aRpCaller.id;
-  options.origin = aRpCaller.origin;
-
-  // loggedInUser can be undefined, null, or a string
-  options.loggedInUser = aRpCaller.loggedInUser;
-
-  // Special flag for internal calls
-  options._internal = aRpCaller._internal;
-
-  Object.keys(aRpCaller).forEach(function(option) {
-    // Duplicate the callerobject, scrubbing out functions and other
-    // internal variables (like _mm, the message manager object)
-    if (!Object.hasOwnProperty(this, option)
-        && option[0] !== '_'
-        && typeof aRpCaller[option] !== 'function') {
-      options[option] = aRpCaller[option];
-    }
-  });
-
-  // check validity of message structure
-  if ((typeof options.id === 'undefined') ||
-      (typeof options.origin === 'undefined')) {
-    let err = "id and origin required in relying-party message: " + JSON.stringify(options);
-    reportError(err);
-    throw new Error(err);
-  }
-
-  return options;
-}
-
-function IDService() {
-  Services.obs.addObserver(this, "quit-application-granted", false);
-  // Services.obs.addObserver(this, "identity-auth-complete", false);
-
-  // simplify, it's one object
-  this.RP = this;
-  this.IDP = this;
-
-  // keep track of flows
-  this._rpFlows = {};
-  this._authFlows = {};
-  this._provFlows = {};
-}
-
-IDService.prototype = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports, Ci.nsIObserver]),
-
-  observe: function observe(aSubject, aTopic, aData) {
-    switch (aTopic) {
-      case "quit-application-granted":
-        Services.obs.removeObserver(this, "quit-application-granted");
-        // Services.obs.removeObserver(this, "identity-auth-complete");
-        break;
-    }
-  },
-
-  /**
-   * Parse an email into username and domain if it is valid, else return null
-   */
-  parseEmail: function parseEmail(email) {
-    var match = email.match(/^([^@]+)@([^@^/]+.[a-z]+)$/);
-    if (match) {
-      return {
-        username: match[1],
-        domain: match[2]
-      };
-    }
-    return null;
-  },
-
-  /**
-   * Register a listener for a given windowID as a result of a call to
-   * navigator.id.watch().
-   *
-   * @param aCaller
-   *        (Object)  an object that represents the caller document, and
-   *                  is expected to have properties:
-   *                  - id (unique, e.g. uuid)
-   *                  - loggedInUser (string or null)
-   *                  - origin (string)
-   *
-   *                  and a bunch of callbacks
-   *                  - doReady()
-   *                  - doLogin()
-   *                  - doLogout()
-   *                  - doError()
-   *                  - doCancel()
-   *
-   */
-  watch: function watch(aRpCaller) {
-    // store the caller structure and notify the UI observers
-    this._rpFlows[aRpCaller.id] = aRpCaller;
-
-    let options = makeMessageObject(aRpCaller);
-    log("sending identity-controller-watch:", options);
-    Services.obs.notifyObservers({wrappedJSObject: options},"identity-controller-watch", null);
-  },
-
-  /*
-   * The RP has gone away; remove handles to the hidden iframe.
-   * It's probable that the frame will already have been cleaned up.
-   */
-  unwatch: function unwatch(aRpId, aTargetMM) {
-    let rp = this._rpFlows[aRpId];
-    let options = makeMessageObject({
-      id: aRpId,
-      origin: rp.origin,
-      messageManager: aTargetMM
-    });
-    log("sending identity-controller-unwatch for id", options.id, options.origin);
-    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-unwatch", null);
-  },
-
-  /**
-   * Initiate a login with user interaction as a result of a call to
-   * navigator.id.request().
-   *
-   * @param aRPId
-   *        (integer)  the id of the doc object obtained in .watch()
-   *
-   * @param aOptions
-   *        (Object)  options including privacyPolicy, termsOfService
-   */
-  request: function request(aRPId, aOptions) {
-    let rp = this._rpFlows[aRPId];
-
-    // Notify UX to display identity picker.
-    // Pass the doc id to UX so it can pass it back to us later.
-    let options = makeMessageObject(rp);
-    objectCopy(aOptions, options);
-    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-request", null);
-  },
-
-  /**
-   * Invoked when a user wishes to logout of a site (for instance, when clicking
-   * on an in-content logout button).
-   *
-   * @param aRpCallerId
-   *        (integer)  the id of the doc object obtained in .watch()
-   *
-   */
-  logout: function logout(aRpCallerId) {
-    let rp = this._rpFlows[aRpCallerId];
-
-    let options = makeMessageObject(rp);
-    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-logout", null);
-  },
-
-  childProcessShutdown: function childProcessShutdown(messageManager) {
-    let options = makeMessageObject({messageManager: messageManager, id: null, origin: null});
-    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-child-process-shutdown", null);
-    Object.keys(this._rpFlows).forEach(function(key) {
-      if (this._rpFlows[key]._mm === messageManager) {
-        log("child process shutdown for rp", key, "- deleting flow");
-        delete this._rpFlows[key];
-      }
-    }, this);
-  },
-
-  /*
-   * once the UI-and-display-logic components have received
-   * notifications, they call back with direct invocation of the
-   * following functions (doLogin, doLogout, or doReady)
-   */
-
-  doLogin: function doLogin(aRpCallerId, aAssertion, aInternalParams) {
-    let rp = this._rpFlows[aRpCallerId];
-    if (!rp) {
-      dump("WARNING: doLogin found no rp to go with callerId " + aRpCallerId + "\n");
-      return;
-    }
-
-    rp.doLogin(aAssertion, aInternalParams);
-  },
-
-  doLogout: function doLogout(aRpCallerId) {
-    let rp = this._rpFlows[aRpCallerId];
-    if (!rp) {
-      dump("WARNING: doLogout found no rp to go with callerId " + aRpCallerId + "\n");
-      return;
-    }
-
-    rp.doLogout();
-  },
-
-  doReady: function doReady(aRpCallerId) {
-    let rp = this._rpFlows[aRpCallerId];
-    if (!rp) {
-      dump("WARNING: doReady found no rp to go with callerId " + aRpCallerId + "\n");
-      return;
-    }
-
-    rp.doReady();
-  },
-
-  doCancel: function doCancel(aRpCallerId) {
-    let rp = this._rpFlows[aRpCallerId];
-    if (!rp) {
-      dump("WARNING: doCancel found no rp to go with callerId " + aRpCallerId + "\n");
-      return;
-    }
-
-    rp.doCancel();
-  },
-
-
-  /*
-   * XXX Bug 804229: Implement Identity Provider Functions
-   *
-   * Stubs for Identity Provider functions follow
-   */
-
-  /**
-   * the provisioning iframe sandbox has called navigator.id.beginProvisioning()
-   *
-   * @param aCaller
-   *        (object)  the iframe sandbox caller with all callbacks and
-   *                  other information.  Callbacks include:
-   *                  - doBeginProvisioningCallback(id, duration_s)
-   *                  - doGenKeyPairCallback(pk)
-   */
-  beginProvisioning: function beginProvisioning(aCaller) {
-  },
-
-  /**
-   * the provisioning iframe sandbox has called
-   * navigator.id.raiseProvisioningFailure()
-   *
-   * @param aProvId
-   *        (int)  the identifier of the provisioning flow tied to that sandbox
-   * @param aReason
-   */
-  raiseProvisioningFailure: function raiseProvisioningFailure(aProvId, aReason) {
-    reportError("Provisioning failure", aReason);
-  },
-
-  /**
-   * When navigator.id.genKeyPair is called from provisioning iframe sandbox.
-   * Generates a keypair for the current user being provisioned.
-   *
-   * @param aProvId
-   *        (int)  the identifier of the provisioning caller tied to that sandbox
-   *
-   * It is an error to call genKeypair without receiving the callback for
-   * the beginProvisioning() call first.
-   */
-  genKeyPair: function genKeyPair(aProvId) {
-  },
-
-  /**
-   * When navigator.id.registerCertificate is called from provisioning iframe
-   * sandbox.
-   *
-   * Sets the certificate for the user for which a certificate was requested
-   * via a preceding call to beginProvisioning (and genKeypair).
-   *
-   * @param aProvId
-   *        (integer) the identifier of the provisioning caller tied to that
-   *                  sandbox
-   *
-   * @param aCert
-   *        (String)  A JWT representing the signed certificate for the user
-   *                  being provisioned, provided by the IdP.
-   */
-  registerCertificate: function registerCertificate(aProvId, aCert) {
-  },
-
-  /**
-   * The authentication frame has called navigator.id.beginAuthentication
-   *
-   * IMPORTANT: the aCaller is *always* non-null, even if this is called from
-   * a regular content page. We have to make sure, on every DOM call, that
-   * aCaller is an expected authentication-flow identifier. If not, we throw
-   * an error or something.
-   *
-   * @param aCaller
-   *        (object)  the authentication caller
-   *
-   */
-  beginAuthentication: function beginAuthentication(aCaller) {
-  },
-
-  /**
-   * The auth frame has called navigator.id.completeAuthentication
-   *
-   * @param aAuthId
-   *        (int)  the identifier of the authentication caller tied to that sandbox
-   *
-   */
-  completeAuthentication: function completeAuthentication(aAuthId) {
-  },
-
-  /**
-   * The auth frame has called navigator.id.cancelAuthentication
-   *
-   * @param aAuthId
-   *        (int)  the identifier of the authentication caller
-   *
-   */
-  cancelAuthentication: function cancelAuthentication(aAuthId) {
-  },
-
-  // methods for chrome and add-ons
-
-  /**
-   * Discover the IdP for an identity
-   *
-   * @param aIdentity
-   *        (string) the email we're logging in with
-   *
-   * @param aCallback
-   *        (function) callback to invoke on completion
-   *                   with first-positional parameter the error.
-   */
-  _discoverIdentityProvider: function _discoverIdentityProvider(aIdentity, aCallback) {
-    // XXX bug 767610 - validate email address call
-    // When that is available, we can remove this custom parser
-    var parsedEmail = this.parseEmail(aIdentity);
-    if (parsedEmail === null) {
-      return aCallback("Could not parse email: " + aIdentity);
-    }
-    log("_discoverIdentityProvider: identity:", aIdentity, "domain:", parsedEmail.domain);
-
-    this._fetchWellKnownFile(parsedEmail.domain, function fetchedWellKnown(err, idpParams) {
-      // idpParams includes the pk, authorization url, and
-      // provisioning url.
-
-      // XXX bug 769861 follow any authority delegations
-      // if no well-known at any point in the delegation
-      // fall back to browserid.org as IdP
-      return aCallback(err, idpParams);
-    });
-  },
-
-  /**
-   * Fetch the well-known file from the domain.
-   *
-   * @param aDomain
-   *
-   * @param aScheme
-   *        (string) (optional) Protocol to use.  Default is https.
-   *                 This is necessary because we are unable to test
-   *                 https.
-   *
-   * @param aCallback
-   *
-   */
-  _fetchWellKnownFile: function _fetchWellKnownFile(aDomain, aCallback, aScheme='https') {
-    // XXX bug 769854 make tests https and remove aScheme option
-    let url = aScheme + '://' + aDomain + "/.well-known/browserid";
-    log("_fetchWellKnownFile:", url);
-
-    // this appears to be a more successful way to get at xmlhttprequest (which supposedly will close with a window
-    let req = Cc["@mozilla.org/xmlextras/xmlhttprequest;1"]
-                .createInstance(Ci.nsIXMLHttpRequest);
-
-    // XXX bug 769865 gracefully handle being off-line
-    // XXX bug 769866 decide on how to handle redirects
-    req.open("GET", url, true);
-    req.responseType = "json";
-    req.mozBackgroundRequest = true;
-    req.onload = function _fetchWellKnownFile_onload() {
-      if (req.status < 200 || req.status >= 400) {
-        log("_fetchWellKnownFile", url, ": server returned status:", req.status);
-        return aCallback("Error");
-      }
-      try {
-        let idpParams = req.response;
-
-        // Verify that the IdP returned a valid configuration
-        if (! (idpParams.provisioning &&
-            idpParams.authentication &&
-            idpParams['public-key'])) {
-          let errStr= "Invalid well-known file from: " + aDomain;
-          log("_fetchWellKnownFile:", errStr);
-          return aCallback(errStr);
-        }
-
-        let callbackObj = {
-          domain: aDomain,
-          idpParams: idpParams,
-        };
-        log("_fetchWellKnownFile result: ", callbackObj);
-        // Yay.  Valid IdP configuration for the domain.
-        return aCallback(null, callbackObj);
-
-      } catch (err) {
-        reportError("_fetchWellKnownFile", "Bad configuration from", aDomain, err);
-        return aCallback(err.toString());
-      }
-    };
-    req.onerror = function _fetchWellKnownFile_onerror() {
-      log("_fetchWellKnownFile", "ERROR:", req.status, req.statusText);
-      log("ERROR: _fetchWellKnownFile:", err);
-      return aCallback("Error");
-    };
-    req.send(null);
-  },
-
-};
-
-this.IdentityService = new IDService();
diff --git a/toolkit/identity/RelyingParty.jsm b/toolkit/identity/RelyingParty.jsm
deleted file mode 100644
--- a/toolkit/identity/RelyingParty.jsm
+++ /dev/null
@@ -1,370 +0,0 @@
-/* -*- Mode: js2; js2-basic-offset: 2; indent-tabs-mode: nil; -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-const Cu = Components.utils;
-const Ci = Components.interfaces;
-const Cc = Components.classes;
-const Cr = Components.results;
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/identity/LogUtils.jsm");
-Cu.import("resource://gre/modules/identity/IdentityUtils.jsm");
-Cu.import("resource://gre/modules/identity/IdentityStore.jsm");
-
-this.EXPORTED_SYMBOLS = ["RelyingParty"];
-
-XPCOMUtils.defineLazyModuleGetter(this,
-                                  "jwcrypto",
-                                  "resource://gre/modules/identity/jwcrypto.jsm");
-
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["RP"].concat(aMessageArgs));
-}
-function reportError(...aMessageArgs) {
-  Logger.reportError.apply(Logger, ["RP"].concat(aMessageArgs));
-}
-
-function IdentityRelyingParty() {
-  // The store is a singleton shared among Identity, RelyingParty, and
-  // IdentityProvider.  The Identity module takes care of resetting
-  // state in the _store on shutdown.
-  this._store = IdentityStore;
-
-  this.reset();
-}
-
-IdentityRelyingParty.prototype = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports, Ci.nsIObserver]),
-
-  observe: function observe(aSubject, aTopic, aData) {
-    switch (aTopic) {
-      case "quit-application-granted":
-        Services.obs.removeObserver(this, "quit-application-granted");
-        this.shutdown();
-        break;
-
-    }
-  },
-
-  reset: function RP_reset() {
-    // Forget all documents that call in.  (These are sometimes
-    // referred to as callers.)
-    this._rpFlows = {};
-  },
-
-  shutdown: function RP_shutdown() {
-    this.reset();
-    Services.obs.removeObserver(this, "quit-application-granted");
-  },
-
-  /**
-   * Register a listener for a given windowID as a result of a call to
-   * navigator.id.watch().
-   *
-   * @param aCaller
-   *        (Object)  an object that represents the caller document, and
-   *                  is expected to have properties:
-   *                  - id (unique, e.g. uuid)
-   *                  - loggedInUser (string or null)
-   *                  - origin (string)
-   *
-   *                  and a bunch of callbacks
-   *                  - doReady()
-   *                  - doLogin()
-   *                  - doLogout()
-   *                  - doError()
-   *                  - doCancel()
-   *
-   */
-  watch: function watch(aRpCaller) {
-    this._rpFlows[aRpCaller.id] = aRpCaller;
-    let origin = aRpCaller.origin;
-    let state = this._store.getLoginState(origin) || { isLoggedIn: false, email: null };
-
-    log("watch: rpId:", aRpCaller.id,
-        "origin:", origin,
-        "loggedInUser:", aRpCaller.loggedInUser,
-        "loggedIn:", state.isLoggedIn,
-        "email:", state.email);
-
-    // If the user is already logged in, then there are three cases
-    // to deal with:
-    //
-    //   1. the email is valid and unchanged:  'ready'
-    //   2. the email is null:                 'login'; 'ready'
-    //   3. the email has changed:             'login'; 'ready'
-    if (state.isLoggedIn) {
-      if (state.email && aRpCaller.loggedInUser === state.email) {
-        this._notifyLoginStateChanged(aRpCaller.id, state.email);
-        return aRpCaller.doReady();
-
-      } else if (aRpCaller.loggedInUser === null) {
-        // Generate assertion for existing login
-        let options = {loggedInUser: state.email, origin: origin};
-        return this._doLogin(aRpCaller, options);
-
-      } else {
-        // A loggedInUser different from state.email has been specified.
-        // Change login identity.
-
-        let options = {loggedInUser: state.email, origin: origin};
-        return this._doLogin(aRpCaller, options);
-      }
-
-    // If the user is not logged in, there are two cases:
-    //
-    //   1. a logged in email was provided: 'ready'; 'logout'
-    //   2. not logged in, no email given:  'ready';
-
-    } else {
-      if (aRpCaller.loggedInUser) {
-        return this._doLogout(aRpCaller, {origin: origin});
-
-      } else {
-        return aRpCaller.doReady();
-      }
-    }
-  },
-
-  /**
-   * A utility for watch() to set state and notify the dom
-   * on login
-   *
-   * Note that this calls _getAssertion
-   */
-  _doLogin: function _doLogin(aRpCaller, aOptions, aAssertion) {
-    log("_doLogin: rpId:", aRpCaller.id, "origin:", aOptions.origin);
-
-    let loginWithAssertion = function loginWithAssertion(assertion) {
-      this._store.setLoginState(aOptions.origin, true, aOptions.loggedInUser);
-      this._notifyLoginStateChanged(aRpCaller.id, aOptions.loggedInUser);
-      aRpCaller.doLogin(assertion);
-      aRpCaller.doReady();
-    }.bind(this);
-
-    if (aAssertion) {
-      loginWithAssertion(aAssertion);
-    } else {
-      this._getAssertion(aOptions, function gotAssertion(err, assertion) {
-        if (err) {
-          reportError("_doLogin:", "Failed to get assertion on login attempt:", err);
-          this._doLogout(aRpCaller);
-        } else {
-          loginWithAssertion(assertion);
-        }
-      }.bind(this));
-    }
-  },
-
-  /**
-   * A utility for watch() to set state and notify the dom
-   * on logout.
-   */
-  _doLogout: function _doLogout(aRpCaller, aOptions) {
-    log("_doLogout: rpId:", aRpCaller.id, "origin:", aOptions.origin);
-
-    let state = this._store.getLoginState(aOptions.origin) || {};
-
-    state.isLoggedIn = false;
-    this._notifyLoginStateChanged(aRpCaller.id, null);
-
-    aRpCaller.doLogout();
-    aRpCaller.doReady();
-  },
-
-  /**
-   * For use with login or logout, emit 'identity-login-state-changed'
-   *
-   * The notification will send the rp caller id in the properties,
-   * and the email of the user in the message.
-   *
-   * @param aRpCallerId
-   *        (integer) The id of the RP caller
-   *
-   * @param aIdentity
-   *        (string) The email of the user whose login state has changed
-   */
-  _notifyLoginStateChanged: function _notifyLoginStateChanged(aRpCallerId, aIdentity) {
-    log("_notifyLoginStateChanged: rpId:", aRpCallerId, "identity:", aIdentity);
-
-    let options = {rpId: aRpCallerId};
-    Services.obs.notifyObservers({wrappedJSObject: options},
-                                 "identity-login-state-changed",
-                                 aIdentity);
-  },
-
-  /**
-   * Initiate a login with user interaction as a result of a call to
-   * navigator.id.request().
-   *
-   * @param aRPId
-   *        (integer)  the id of the doc object obtained in .watch()
-   *
-   * @param aOptions
-   *        (Object)  options including privacyPolicy, termsOfService
-   */
-  request: function request(aRPId, aOptions) {
-    log("request: rpId:", aRPId);
-    let rp = this._rpFlows[aRPId];
-
-    // Notify UX to display identity picker.
-    // Pass the doc id to UX so it can pass it back to us later.
-    let options = {rpId: aRPId, origin: rp.origin};
-    objectCopy(aOptions, options);
-
-    // Append URLs after resolving
-    let baseURI = Services.io.newURI(rp.origin, null, null);
-    for (let optionName of ["privacyPolicy", "termsOfService"]) {
-      if (aOptions[optionName]) {
-        options[optionName] = baseURI.resolve(aOptions[optionName]);
-      }
-    }
-
-    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-request", null);
-  },
-
-  /**
-   * Invoked when a user wishes to logout of a site (for instance, when clicking
-   * on an in-content logout button).
-   *
-   * @param aRpCallerId
-   *        (integer)  the id of the doc object obtained in .watch()
-   *
-   */
-  logout: function logout(aRpCallerId) {
-    log("logout: RP caller id:", aRpCallerId);
-    let rp = this._rpFlows[aRpCallerId];
-    if (rp && rp.origin) {
-      let origin = rp.origin;
-      log("logout: origin:", origin);
-      this._doLogout(rp, {origin: origin});
-    } else {
-      log("logout: no RP found with id:", aRpCallerId);
-    }
-    // We don't delete this._rpFlows[aRpCallerId], because
-    // the user might log back in again.
-  },
-
-  getDefaultEmailForOrigin: function getDefaultEmailForOrigin(aOrigin) {
-    let identities = this.getIdentitiesForSite(aOrigin);
-    let result = identities.lastUsed || null;
-    log("getDefaultEmailForOrigin:", aOrigin, "->", result);
-    return result;
-  },
-
-  /**
-   * Return the list of identities a user may want to use to login to aOrigin.
-   */
-  getIdentitiesForSite: function getIdentitiesForSite(aOrigin) {
-    let rv = { result: [] };
-    for (let id in this._store.getIdentities()) {
-      rv.result.push(id);
-    }
-    let loginState = this._store.getLoginState(aOrigin);
-    if (loginState && loginState.email)
-      rv.lastUsed = loginState.email;
-    return rv;
-  },
-
-  /**
-   * Obtain a BrowserID assertion with the specified characteristics.
-   *
-   * @param aCallback
-   *        (Function) Callback to be called with (err, assertion) where 'err'
-   *        can be an Error or NULL, and 'assertion' can be NULL or a valid
-   *        BrowserID assertion. If no callback is provided, an exception is
-   *        thrown.
-   *
-   * @param aOptions
-   *        (Object) An object that may contain the following properties:
-   *
-   *          "audience"      : The audience for which the assertion is to be
-   *                            issued. If this property is not set an exception
-   *                            will be thrown.
-   *
-   *        Any properties not listed above will be ignored.
-   */
-  _getAssertion: function _getAssertion(aOptions, aCallback) {
-    let audience = aOptions.origin;
-    let email = aOptions.loggedInUser || this.getDefaultEmailForOrigin(audience);
-    log("_getAssertion: audience:", audience, "email:", email);
-    if (!audience) {
-      throw "audience required for _getAssertion";
-    }
-
-    // We might not have any identity info for this email
-    if (!this._store.fetchIdentity(email)) {
-      this._store.addIdentity(email, null, null);
-    }
-
-    let cert = this._store.fetchIdentity(email)['cert'];
-    if (cert) {
-      this._generateAssertion(audience, email, function generatedAssertion(err, assertion) {
-        if (err) {
-          log("ERROR: _getAssertion:", err);
-        }
-        log("_getAssertion: generated assertion:", assertion);
-        return aCallback(err, assertion);
-      });
-    }
-  },
-
-  /**
-   * Generate an assertion, including provisioning via IdP if necessary,
-   * but no user interaction, so if provisioning fails, aCallback is invoked
-   * with an error.
-   *
-   * @param aAudience
-   *        (string) web origin
-   *
-   * @param aIdentity
-   *        (string) the email we're logging in with
-   *
-   * @param aCallback
-   *        (function) callback to invoke on completion
-   *                   with first-positional parameter the error.
-   */
-  _generateAssertion: function _generateAssertion(aAudience, aIdentity, aCallback) {
-    log("_generateAssertion: audience:", aAudience, "identity:", aIdentity);
-
-    let id = this._store.fetchIdentity(aIdentity);
-    if (! (id && id.cert)) {
-      let errStr = "Cannot generate an assertion without a certificate";
-      log("ERROR: _generateAssertion:", errStr);
-      aCallback(errStr);
-      return;
-    }
-
-    let kp = id.keyPair;
-
-    if (!kp) {
-      let errStr = "Cannot generate an assertion without a keypair";
-      log("ERROR: _generateAssertion:", errStr);
-      aCallback(errStr);
-      return;
-    }
-
-    jwcrypto.generateAssertion(id.cert, kp, aAudience, aCallback);
-  },
-
-  /**
-   * Clean up references to the provisioning flow for the specified RP.
-   */
-  _cleanUpProvisionFlow: function RP_cleanUpProvisionFlow(aRPId, aProvId) {
-    let rp = this._rpFlows[aRPId];
-    if (rp) {
-      delete rp['provId'];
-    } else {
-      log("Error: Couldn't delete provision flow ", aProvId, " for RP ", aRPId);
-    }
-  },
-
-};
-
-this.RelyingParty = new IdentityRelyingParty();
diff --git a/toolkit/identity/Sandbox.jsm b/toolkit/identity/Sandbox.jsm
deleted file mode 100644
--- a/toolkit/identity/Sandbox.jsm
+++ /dev/null
@@ -1,153 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-this.EXPORTED_SYMBOLS = ["Sandbox"];
-
-const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
-
-const XHTML_NS = "http://www.w3.org/1999/xhtml";
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this,
-                                  "Logger",
-                                  "resource://gre/modules/identity/LogUtils.jsm");
-
-/**
- * An object that represents a sandbox in an iframe loaded with aURL. The
- * callback provided to the constructor will be invoked when the sandbox is
- * ready to be used. The callback will receive this object as its only argument.
- *
- * You must call free() when you are finished with the sandbox to explicitly
- * free up all associated resources.
- *
- * @param aURL
- *        (string) URL to load in the sandbox.
- *
- * @param aCallback
- *        (function) Callback to be invoked with a Sandbox, when ready.
- */
-this.Sandbox = function Sandbox(aURL, aCallback) {
-  // Normalize the URL so the comparison in _makeSandboxContentLoaded works
-  this._url = Services.io.newURI(aURL, null, null).spec;
-  this._log("Creating sandbox for:", this._url);
-  this._createFrame();
-  this._createSandbox(aCallback);
-};
-
-this.Sandbox.prototype = {
-
-  /**
-   * Use the outer window ID as the identifier of the sandbox.
-   */
-  get id() {
-    return this._frame.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
-               .getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
-  },
-
-  /**
-   * Reload the URL in the sandbox. This is useful to reuse a Sandbox (same
-   * id and URL).
-   */
-  reload: function Sandbox_reload(aCallback) {
-    this._log("reload:", this.id, ":", this._url);
-    this._createSandbox(function createdSandbox(aSandbox) {
-      this._log("reloaded sandbox id:", aSandbox.id);
-      aCallback(aSandbox);
-    }.bind(this));
-  },
-
-  /**
-   * Frees the sandbox and releases the iframe created to host it.
-   */
-  free: function Sandbox_free() {
-    this._log("free:", this.id);
-    this._container.removeChild(this._frame);
-    this._frame = null;
-    this._container = null;
-    this._url = null;
-  },
-
-  /**
-   * Creates an empty, hidden iframe and sets it to the _frame
-   * property of this object.
-   */
-  _createFrame: function Sandbox__createFrame() {
-    let hiddenWindow = Services.appShell.hiddenDOMWindow;
-    let doc = hiddenWindow.document;
-
-    // Insert iframe in to create docshell.
-    let frame = doc.createElementNS(XHTML_NS, "iframe");
-    frame.setAttribute("mozframetype", "content");
-    frame.sandbox = "allow-forms allow-scripts allow-same-origin";
-    frame.style.visibility = "collapse";
-    doc.documentElement.appendChild(frame);
-
-    let docShell = frame.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
-                                      .getInterface(Ci.nsIWebNavigation)
-                                      .QueryInterface(Ci.nsIInterfaceRequestor)
-                                      .getInterface(Ci.nsIDocShell);
-
-    // Stop about:blank from being loaded.
-    docShell.stop(Ci.nsIWebNavigation.STOP_NETWORK);
-
-    // Disable some types of content
-    docShell.allowAuth = false;
-    docShell.allowPlugins = false;
-    docShell.allowImages = false;
-    docShell.allowWindowControl = false;
-    // TODO: disable media (bug 759964)
-
-    // Disable stylesheet loading since the document is not visible.
-    let markupDocViewer = docShell.contentViewer
-                                  .QueryInterface(Ci.nsIMarkupDocumentViewer);
-    markupDocViewer.authorStyleDisabled = true;
-
-    // Set instance properties.
-    this._frame = frame;
-    this._container = doc.documentElement;
-  },
-
-  _createSandbox: function Sandbox__createSandbox(aCallback) {
-    let self = this;
-    function _makeSandboxContentLoaded(event) {
-      self._log("_makeSandboxContentLoaded:", self.id,
-                event.target.location.toString());
-      if (event.target != self._frame.contentDocument) {
-        return;
-      }
-      self._frame.removeEventListener(
-        "DOMWindowCreated", _makeSandboxContentLoaded, true
-      );
-
-      aCallback(self);
-    };
-
-    this._frame.addEventListener("DOMWindowCreated",
-                                 _makeSandboxContentLoaded,
-                                 true);
-
-    // Load the iframe.
-    let webNav = this._frame.contentWindow
-                            .QueryInterface(Ci.nsIInterfaceRequestor)
-                            .getInterface(Ci.nsIWebNavigation);
-
-    webNav.loadURI(
-      this._url,
-      Ci.nsIWebNavigation.LOAD_FLAGS_BYPASS_CACHE,
-      null, // referrer
-      null, // postData
-      null  // headers
-    );
-
-  },
-
-  _log: function Sandbox__log(...aMessageArgs) {
-    Logger.log.apply(Logger, ["sandbox"].concat(aMessageArgs));
-  },
-
-};
diff --git a/toolkit/identity/jwcrypto.jsm b/toolkit/identity/jwcrypto.jsm
--- a/toolkit/identity/jwcrypto.jsm
+++ b/toolkit/identity/jwcrypto.jsm
@@ -9,33 +9,33 @@
 
 const Cu = Components.utils;
 const Ci = Components.interfaces;
 const Cc = Components.classes;
 const Cr = Components.results;
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/identity/LogUtils.jsm");
+
+XPCOMUtils.defineLazyGetter(this, "logger", function() {
+  Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+  return getLogger("Identity test", "toolkit.identity.debug");
+});
 
 XPCOMUtils.defineLazyServiceGetter(this,
                                    "IdentityCryptoService",
                                    "@mozilla.org/identity/crypto-service;1",
                                    "nsIIdentityCryptoService");
 
 this.EXPORTED_SYMBOLS = ["jwcrypto"];
 
 const ALGORITHMS = { RS256: "RS256", DS160: "DS160" };
 
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["jwcrypto"].concat(aMessageArgs));
-}
-
 function generateKeyPair(aAlgorithmName, aCallback) {
-  log("Generate key pair; alg =", aAlgorithmName);
+  logger.log("Generate key pair; alg =", aAlgorithmName);
 
   IdentityCryptoService.generateKeyPair(aAlgorithmName, function(rv, aKeyPair) {
     if (!Components.isSuccessCode(rv)) {
       return aCallback("key generation failed");
     }
 
     var publicKey;
 
@@ -69,36 +69,36 @@ function generateKeyPair(aAlgorithmName,
 
     return aCallback(null, keyWrapper);
   });
 }
 
 function sign(aPayload, aKeypair, aCallback) {
   aKeypair._kp.sign(aPayload, function(rv, signature) {
     if (!Components.isSuccessCode(rv)) {
-      log("ERROR: signer.sign failed");
+      logger.warning("ERROR: signer.sign failed");
       return aCallback("Sign failed");
     }
-    log("signer.sign: success");
+    logger.log("signer.sign: success");
     return aCallback(null, signature);
   });
 }
 
 function jwcryptoClass()
 {
 }
 
 jwcryptoClass.prototype = {
   isCertValid: function(aCert, aCallback) {
     // XXX check expiration, bug 769850
     aCallback(true);
   },
 
   generateKeyPair: function(aAlgorithmName, aCallback) {
-    log("generating");
+    logger.log("generating");
     generateKeyPair(aAlgorithmName, aCallback);
   },
 
   generateAssertion: function(aCert, aKeyPair, aAudience, aCallback) {
     // for now, we hack the algorithm name
     // XXX bug 769851
     var header = {"alg": "DS128"};
     var headerBytes = IdentityCryptoService.base64UrlEncode(
@@ -108,17 +108,17 @@ jwcryptoClass.prototype = {
       // expires in 2 minutes
       // XXX clock skew needs exploration bug 769852
       exp: Date.now() + (2 * 60 * 1000),
       aud: aAudience
     };
     var payloadBytes = IdentityCryptoService.base64UrlEncode(
                           JSON.stringify(payload));
 
-    log("payload bytes", payload, payloadBytes);
+    logger.log("payload bytes", payload, payloadBytes);
     sign(headerBytes + "." + payloadBytes, aKeyPair, function(err, signature) {
       if (err)
         return aCallback(err);
 
       var signedAssertion = headerBytes + "." + payloadBytes + "." + signature;
       return aCallback(null, aCert + "~" + signedAssertion);
     });
   }
diff --git a/toolkit/identity/tests/chrome/Makefile.in b/toolkit/identity/tests/chrome/Makefile.in
--- a/toolkit/identity/tests/chrome/Makefile.in
+++ b/toolkit/identity/tests/chrome/Makefile.in
@@ -6,20 +6,11 @@ DEPTH          = @DEPTH@
 topsrcdir      = @top_srcdir@
 srcdir         = @srcdir@
 VPATH          = @srcdir@
 relativesrcdir = @relativesrcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 MOCHITEST_CHROME_FILES = \
-		sandbox_content.html \
-		sandbox_content_alert.html \
-		sandbox_content_framed.html \
-		sandbox_content_perms.html \
-		sandbox_content_popup.html \
-		sandbox_content_redirect.html \
-		sandbox_content_redirect.html^headers^ \
-		sandbox_content.sjs \
-		test_sandbox.xul \
 		$(NULL)
 
 include $(topsrcdir)/config/rules.mk
diff --git a/toolkit/identity/tests/chrome/sandbox_content.html b/toolkit/identity/tests/chrome/sandbox_content.html
deleted file mode 100644
--- a/toolkit/identity/tests/chrome/sandbox_content.html
+++ /dev/null
@@ -1,32 +0,0 @@
-<!DOCTYPE html>
-<html>
-<!-- Any copyright is dedicated to the Public Domain.
-   - http://creativecommons.org/publicdomain/zero/1.0/ -->
-<head>
-<meta charset="utf-8">
-<title>Page testing blocked content in the Sandbox</title>
-
-<link rel="stylesheet" src="sandbox_content.sjs?text/css"/>
-
-<script src="sandbox_content.sjs?application/javascript"></script>
-
-</head>
-
-<body>
-
-<img src="sandbox_content.sjs?image/jpeg"/>
-
-<!-- media -->
-<video src="sandbox_content.sjs?video/webm" autoplay="true"></video>
-<audio src="sandbox_content.sjs?audio/ogg" autoplay="true"></audio>
-
-<!-- plugins -->
-<embed src="sandbox_content.sjs?application/x-test"/>
-<object data="sandbox_content.sjs?application/x-test"></object>
-<applet code="sandbox_content.sjs?application/x-java-applet"></applet>
-
-<iframe src="sandbox_content.sjs?text/html"></iframe>
-
-</body>
-
-</html>
diff --git a/toolkit/identity/tests/chrome/sandbox_content.sjs b/toolkit/identity/tests/chrome/sandbox_content.sjs
deleted file mode 100644
--- a/toolkit/identity/tests/chrome/sandbox_content.sjs
+++ /dev/null
@@ -1,36 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- *  * License, v. 2.0. If a copy of the MPL was not distributed with this
- *  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-function handleRequest(request, response) {
-  response.setHeader("Cache-Control", "no-cache", false);
-
-  let loadedStateKey = "sandbox_content_loaded";
-  switch(request.queryString) {
-    case "reset": {
-      setState(loadedStateKey, "");
-      response.write("reset");
-      break;
-    }
-    case "get_loaded": {
-      response.setHeader("Content-Type", "text/plain", false);
-      let loaded = getState(loadedStateKey);
-      if (loaded)
-        response.write(loaded);
-      else
-        response.write("NOTHING");
-      break;
-    }
-    default: {
-      let contentType = decodeURIComponent(request.queryString);
-      // set the Content-Type equal to the query string
-      response.setHeader("Content-Type", contentType, false);
-      // If any content is loaded, append it's content type in state
-      let loaded = getState(loadedStateKey);
-      if (loaded)
-        loaded += ",";
-      setState(loadedStateKey, loaded + contentType);
-      break;
-    }
-  }
-}
diff --git a/toolkit/identity/tests/chrome/sandbox_content_alert.html b/toolkit/identity/tests/chrome/sandbox_content_alert.html
deleted file mode 100644
--- a/toolkit/identity/tests/chrome/sandbox_content_alert.html
+++ /dev/null
@@ -1,20 +0,0 @@
-<!DOCTYPE html>
-<html>
-<!-- Any copyright is dedicated to the Public Domain.
-     http://creativecommons.org/publicdomain/zero/1.0/ -->
-<head>
-<meta charset="utf-8">
-<title>Page creating an alert inside the Sandbox</title>
-
-<script>
-
-alert("The user shouldn't see this");
-
-</script>
-
-</head>
-
-<body>
-
-</body>
-</html>
diff --git a/toolkit/identity/tests/chrome/sandbox_content_framed.html b/toolkit/identity/tests/chrome/sandbox_content_framed.html
deleted file mode 100644
--- a/toolkit/identity/tests/chrome/sandbox_content_framed.html
+++ /dev/null
@@ -1,17 +0,0 @@
-<!DOCTYPE html>
-<html>
-<!-- Any copyright is dedicated to the Public Domain.
-     http://creativecommons.org/publicdomain/zero/1.0/ -->
-<head>
-<meta charset="utf-8">
-<title>Page testing blocked content in an iframe inside the Sandbox</title>
-
-</head>
-
-<body>
-
-<iframe src="sandbox_content.html"></iframe>
-
-</body>
-
-</html>
diff --git a/toolkit/identity/tests/chrome/sandbox_content_perms.html b/toolkit/identity/tests/chrome/sandbox_content_perms.html
deleted file mode 100644
--- a/toolkit/identity/tests/chrome/sandbox_content_perms.html
+++ /dev/null
@@ -1,66 +0,0 @@
-<!DOCTYPE html>
-<html>
-  <!-- Any copyright is dedicated to the Public Domain.
-     - http://creativecommons.org/publicdomain/zero/1.0/ -->
-  <head>
-    <meta charset="utf-8">
-    <title>Page testing content in the Sandbox can't escape</title>
-    <script type="application/javascript;version=1.8">
-      const TEST_BASE = "http://mochi.test:8888/chrome/toolkit/identity/tests/chrome/"
-      const Ci = SpecialPowers.Ci;
-
-      function expectException(aFunc) {
-        try {
-          aFunc();
-        } catch (ex) {
-          return true;
-        }
-        return false;
-      }
-
-      function CcDenied() {
-        // Once Components goes away in content, the question of whether or not
-        // Components.classes throws is not well-formed.
-        if (typeof Components === 'undefined')
-          return true;
-        try {
-          Components.classes;
-          return false;
-        } catch (e) {
-          return !!/denied/.exec(e);
-        }
-      }
-
-      // Build an object with test results (true = pass)
-      let results = {
-        windowTop: window.top == window,
-
-        qiWindow: expectException(function() {
-          let isForced = window.QueryInterface(Ci.nsIInterfaceRequestor)
-                               .getInterface(Ci.nsIDOMWindowUtils)
-                               .docCharsetIsForced;
-        }),
-
-        ccAccess: !!CcDenied(),
-      };
-
-      let resultsJSON = JSON.stringify(results);
-
-      // Send the results to the mochitest server so the test file can retrieve them.
-      let stateURL = TEST_BASE + "sandbox_content.sjs"
-      let xhr = new XMLHttpRequest();
-      xhr.open("GET", stateURL + "?" + encodeURIComponent(resultsJSON), true);
-      xhr.onload = function() {
-        if (xhr.status != 200) {
-          dump("Failed sending results\n");
-        }
-      };
-      xhr.send();
-
-    </script>
-  </head>
-
-  <body>
-
-  </body>
-</html>
diff --git a/toolkit/identity/tests/chrome/sandbox_content_popup.html b/toolkit/identity/tests/chrome/sandbox_content_popup.html
deleted file mode 100644
--- a/toolkit/identity/tests/chrome/sandbox_content_popup.html
+++ /dev/null
@@ -1,25 +0,0 @@
-<!DOCTYPE html>
-<html>
-<!-- Any copyright is dedicated to the Public Domain.
-   - http://creativecommons.org/publicdomain/zero/1.0/ -->
-<head>
-<meta charset="utf-8">
-<title>Page creating an popup inside the Sandbox</title>
-
-<script>
-
-var strWindowFeatures = "menubar=yes,location=yes,resizable=yes,scrollbars=yes,status=yes";
-
-var uri = "data:text/html,";
-uri += encodeURI("<body onload='setTimeout(window.close, 1000)'>");
-
-var win = window.open(uri, "sandbox_popup", strWindowFeatures);
-
-</script>
-
-</head>
-
-<body>
-
-</body>
-</html>
diff --git a/toolkit/identity/tests/chrome/sandbox_content_redirect.html b/toolkit/identity/tests/chrome/sandbox_content_redirect.html
deleted file mode 100644
--- a/toolkit/identity/tests/chrome/sandbox_content_redirect.html
+++ /dev/null
@@ -1,2 +0,0 @@
-<!-- Any copyright is dedicated to the Public Domain.
-     http://creativecommons.org/publicdomain/zero/1.0/ -->
diff --git a/toolkit/identity/tests/chrome/sandbox_content_redirect.html^headers^ b/toolkit/identity/tests/chrome/sandbox_content_redirect.html^headers^
deleted file mode 100644
--- a/toolkit/identity/tests/chrome/sandbox_content_redirect.html^headers^
+++ /dev/null
@@ -1,2 +0,0 @@
-HTTP 302 Found
-Location: http://mochi.test:8888/chrome/toolkit/identity/tests/chrome/sandbox_content.html
diff --git a/toolkit/identity/tests/chrome/test_sandbox.xul b/toolkit/identity/tests/chrome/test_sandbox.xul
deleted file mode 100644
--- a/toolkit/identity/tests/chrome/test_sandbox.xul
+++ /dev/null
@@ -1,327 +0,0 @@
-<?xml version="1.0"?>
-<?xml-stylesheet type="text/css" href="chrome://global/skin"?>
-<?xml-stylesheet type="text/css" href="/tests/SimpleTest/test.css"?>
-<!-- Any copyright is dedicated to the Public Domain.
-     http://creativecommons.org/publicdomain/zero/1.0/ -->
-<!--
-https://bugzilla.mozilla.org/show_bug.cgi?id=762993
--->
-<window title="Mozilla Bug 762993"
-        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-        onload="run_next_test();">
-  <script type="application/javascript"
-          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"/>
-
-  <!-- test results are displayed in the html:body -->
-  <body xmlns="http://www.w3.org/1999/xhtml">
-  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=762993"
-     target="_blank">Mozilla Bug 762993</a>
-  </body>
-
-  <!-- test code goes here -->
-  <script type="application/javascript;version=1.8">
-  <![CDATA[
-
-  /** Test for Bug 762993 **/
-
-"use strict";
-
-SimpleTest.expectAssertions(2);
-
-SimpleTest.waitForExplicitFinish();
-
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cu = Components.utils;
-const OSX_10_5 = navigator.oscpu == "Intel Mac OS X 10.5";
-
-const secMan = Cc["@mozilla.org/scriptsecuritymanager;1"].getService(Ci.nsIScriptSecurityManager);
-
-const TEST_URL_1 = "https://example.com/";
-// No trailing slash plus port to test normalization
-const TEST_URL_2 = "https://example.com:443";
-
-const TEST_BASE = "http://mochi.test:8888/chrome/toolkit/identity/tests/chrome/"
-const STATE_URL = TEST_BASE + "sandbox_content.sjs"
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-
-Services.prefs.setBoolPref("toolkit.identity.debug", true);
-
-XPCOMUtils.defineLazyModuleGetter(this, "Sandbox",
-                                  "resource://gre/modules/identity/Sandbox.jsm");
-
-function check_sandbox(aSandbox, aURL) {
-  ok(aSandbox.id > 0, "valid ID");
-  is(aSandbox._url, aURL, "matching URL (with normalization)");
-  isnot(aSandbox._frame, null, "frame");
-  isnot(aSandbox._container, null, "container");
-  let docPrincipal = aSandbox._frame.contentDocument.nodePrincipal;
-  is(secMan.isSystemPrincipal(docPrincipal), false,
-     "principal must not be system");
-}
-
-/**
- * Free the sandbox and make sure all properties that are not booleans,
- * functions or numbers were freed.
- */
-function free_and_check_sandbox(aSandbox) {
-  SimpleTest.executeSoon(function() {
-    aSandbox.free();
-
-    for(let prop in aSandbox) {
-      // Don't trigger the "id" getter when the frame is supposed to be freed already
-      if (prop == "id")
-        continue;
-      let propType = typeof(aSandbox[prop]);
-      if (propType == "boolean" || propType == "function" || propType == "number")
-        continue;
-      is(aSandbox[prop], null, "freed " + prop);
-    }
-    run_next_test();
-  });
-}
-
-function reset_server_state() {
-  // Now reset the server state
-  let resetReq = new XMLHttpRequest();
-  resetReq.open("GET", STATE_URL + "?reset", false);
-  resetReq.send();
-}
-
-function test_creation() {
-  new Sandbox(TEST_URL_1, function sandboxCB(aSandbox) {
-    check_sandbox(aSandbox, TEST_URL_1);
-    free_and_check_sandbox(aSandbox);
-  });
-}
-
-function test_reload() {
-  new Sandbox(TEST_URL_1, function sandboxCB(aSandbox) {
-    check_sandbox(aSandbox, TEST_URL_1);
-    let originalId = aSandbox.id;
-
-    aSandbox.reload(function sandboxReloadCB(aSandbox) {
-      check_sandbox(aSandbox, TEST_URL_1);
-      is(aSandbox.id, originalId, "Sandbox ID should be the same after reload");
-      free_and_check_sandbox(aSandbox);
-    });
-  });
-}
-
-function test_url_normalization() {
-  new Sandbox(TEST_URL_2, function sandboxCB(aSandbox) {
-    // TEST_URL_2 should be normalized into the form of TEST_URL_1
-    check_sandbox(aSandbox, TEST_URL_1);
-    free_and_check_sandbox(aSandbox);
-  });
-}
-
-/**
- * Check with the server's state to see what content was loaded then reset it.
- */
-function check_loaded_content(aSandbox, aNothingShouldLoad, aCallback) {
-
-  let xhr = new XMLHttpRequest();
-  xhr.open("GET", STATE_URL + "?get_loaded", true);
-  xhr.onload = function() {
-    let res = xhr.responseText;
-    is(xhr.status, 200, "Check successful response");
-
-    if (aNothingShouldLoad) {
-      is(res, "NOTHING", "Check that nothing was loaded on the server");
-    } else if (!OSX_10_5) {
-      let allowedTypes = [ "application/javascript", "text/html", "video/webm",
-                           "audio/ogg", "application/x-test" ];
-      let loadedTypes = res == "NOTHING" ? [] : res.split(",");
-
-      for (let loadedType of loadedTypes) {
-        isnot(allowedTypes.indexOf(loadedType), -1, "Check that " + loadedType + " was expected to load");
-      }
-
-      // TODO: Media should be disabled after bug 759964.
-      isnot(loadedTypes.indexOf("application/javascript"), -1, "Check JS was loaded");
-      isnot(loadedTypes.indexOf("text/html"), -1, "Check iframe was loaded");
-      //todo_is(loadedTypes.indexOf("video/webm"), -1, "Check webm was not loaded");
-      //todo_is(loadedTypes.indexOf("audio/ogg"), -1, "Check ogg was not loaded");
-
-      // Check that no plugin tags have a type other than TYPE_NULL (failed load)
-      // --
-      // Checking if a channel was opened is not sufficient for plugin tags --
-      // An object tag may still be allowed to load a sub-document, but not a
-      // plugin, so it will open a channel but then abort when it gets a
-      // plugin-type.
-      let doc = aSandbox._frame.contentDocument;
-      let nullType = Components.interfaces.nsIObjectLoadingContent.TYPE_NULL;
-      for (let tag of doc.querySelectorAll("embed, object, applet")) {
-        tag instanceof Components.interfaces.nsIObjectLoadingContent;
-        is(tag.displayedType, nullType, "Check that plugin did not load content");
-      }
-    }
-
-    reset_server_state();
-
-    aCallback();
-  };
-  xhr.send();
-}
-
-/**
- * Helper to check that only certain content is loaded on creation and during reload.
- */
-function check_disabled_content(aSandboxURL, aNothingShouldLoad = false) {
-  new Sandbox(aSandboxURL, function sandboxCB(aSandbox) {
-    check_sandbox(aSandbox, aSandboxURL);
-    let originalId = aSandbox.id;
-
-    setTimeout(function() {
-      check_loaded_content(aSandbox, aNothingShouldLoad, function checkFinished() {
-
-        info("reload the sandbox content");
-        aSandbox.reload(function sandboxReloadCB(aSandbox) {
-          check_sandbox(aSandbox, aSandboxURL);
-          is(aSandbox.id, originalId, "Sandbox ID should be the same after reload");
-
-          setTimeout(function() {
-            check_loaded_content(aSandbox, aNothingShouldLoad, function reloadCheckFinished() {
-              free_and_check_sandbox(aSandbox);
-            });
-          }, 5000);
-        });
-      });
-    }, 5000);
-  });
-}
-
-function test_disabled_content() {
-  let url = TEST_BASE + "sandbox_content.html";
-  check_disabled_content(url);
-}
-
-// Same as test above but with content in an iframe.
-function test_disabled_content_framed() {
-  let url = TEST_BASE + "sandbox_content_framed.html";
-  check_disabled_content(url);
-}
-
-function test_redirect() {
-  let url = TEST_BASE + "sandbox_content_redirect.html";
-  check_disabled_content(url);
-}
-
-function WindowObserver(aCallback) {
-  this.observe = function(aSubject, aTopic, aData) {
-    if (aTopic != "domwindowopened") {
-      return;
-    }
-    Services.ww.unregisterNotification(this);
-
-    let domWin = aSubject.QueryInterface(Ci.nsIDOMWindow);
-    ok(!domWin, "No window should be opened");
-    SimpleTest.executeSoon(function() {
-      info("Closing opened window");
-      domWin.close();
-      aCallback();
-    });
-  }
-}
-
-// Can the sandbox call window.alert() or popup other UI?
-function test_alert() {
-  let alertURL = TEST_BASE + "sandbox_content_alert.html";
-
-  new Sandbox(alertURL, function sandboxCB(aSandbox) {
-    check_sandbox(aSandbox, alertURL);
-    setTimeout(function() {
-
-      let win = Services.wm.getMostRecentWindow(null);
-      isnot(win.document.documentElement.getAttribute("id"), "commonDialog",
-                 "Make sure most recent window is not a dialog");
-      if (win.document.documentElement.getAttribute("id") == "commonDialog") {
-        // If a dialog did open, close it so we don't interfere with future tests
-        win.close()
-      }
-
-      free_and_check_sandbox(aSandbox);
-    }, 1000);
-  });
-}
-
-// Can the sandboxed page open a popup with window.open?
-function test_popup() {
-  let alertURL = TEST_BASE + "sandbox_content_popup.html";
-  let theSandbox;
-  function continueTest() {
-    // avoid double-free
-    if (!theSandbox)
-      return;
-    free_and_check_sandbox(theSandbox);
-    theSandbox = null;
-  }
-  let winObs = new WindowObserver(continueTest);
-  Services.ww.registerNotification(winObs);
-  new Sandbox(alertURL, function sandboxCB(aSandbox) {
-    theSandbox = aSandbox;
-    check_sandbox(aSandbox, alertURL);
-    // Wait 5 seconds to see if the window is going to open.
-    setTimeout(function() {
-      Services.ww.unregisterNotification(winObs);
-      continueTest();
-    }, 5000);
-  });
-}
-
-// Loading a page with a bad cert
-function test_bad_cert() {
-  let url = TEST_BASE + "sandbox_content.sjs?text/html";
-  url = url.replace("http://mochi.test:8888", "https://untrusted.example.com");
-  check_disabled_content(url, /*nothingShouldLoad=*/true);
-}
-
-// Loading a page to check window.top and other permissions.
-function test_frame_perms() {
-  let url = TEST_BASE + "sandbox_content_perms.html";
-  new Sandbox(url, function sandboxCB(aSandbox) {
-    check_sandbox(aSandbox, url);
-
-    // Give the content time to load
-    setTimeout(function() {
-      let xhr = new XMLHttpRequest();
-      xhr.open("GET", STATE_URL + "?get_loaded", true);
-      xhr.responseType = "json";
-      xhr.onload = function() {
-        is(xhr.status, 200, "Check successful response");
-        is(typeof(xhr.response), "object", "Check response is object");
-        is(Object.keys(xhr.response).length, 3, "Check the number of perm. tests");
-        for (let test in xhr.response) {
-          ok(xhr.response[test], "Check result of " + test);
-        }
-
-        reset_server_state();
-        free_and_check_sandbox(aSandbox);
-      };
-      xhr.send();
-    }, 3000);
-  });
-}
-
-let TESTS = [test_creation, test_reload, test_url_normalization];
-TESTS.push(test_disabled_content, test_disabled_content_framed);
-TESTS.push(test_alert, test_popup, test_bad_cert);
-TESTS.push(test_redirect, test_frame_perms);
-
-function run_next_test() {
-  if (TESTS.length) {
-    let test = TESTS.shift();
-    info(test.name);
-    test();
-  } else {
-    Services.prefs.clearUserPref("toolkit.identity.debug");
-    SimpleTest.finish();
-  }
-}
-
-  ]]>
-  </script>
-</window>
diff --git a/toolkit/identity/tests/moz.build b/toolkit/identity/tests/moz.build
--- a/toolkit/identity/tests/moz.build
+++ b/toolkit/identity/tests/moz.build
@@ -1,10 +1,10 @@
 # -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-DIRS += ['chrome', 'mochitest']
+DIRS += []
 
 MODULE = 'test_identity'
 
diff --git a/toolkit/identity/tests/unit/data/idp_1/.well-known/browserid b/toolkit/identity/tests/unit/data/idp_1/.well-known/browserid
deleted file mode 100644
--- a/toolkit/identity/tests/unit/data/idp_1/.well-known/browserid
+++ /dev/null
@@ -1,5 +0,0 @@
-{
-    "public-key": {"algorithm":"RS","n":"65718905405105134410187227495885391609221288015566078542117409373192106382993306537273677557482085204736975067567111831005921322991127165013340443563713385983456311886801211241492470711576322130577278575529202840052753612576061450560588102139907846854501252327551303482213505265853706269864950437458242988327","e":"65537"},
-    "authentication": "/browserid/sign_in.html",
-    "provisioning": "/browserid/provision.html"
-}
diff --git a/toolkit/identity/tests/unit/data/idp_invalid_1/.well-known/browserid b/toolkit/identity/tests/unit/data/idp_invalid_1/.well-known/browserid
deleted file mode 100644
--- a/toolkit/identity/tests/unit/data/idp_invalid_1/.well-known/browserid
+++ /dev/null
@@ -1,5 +0,0 @@
-{
-    "public-key": {"algorithm":"RS","n":"65718905405105134410187227495885391609221288015566078542117409373192106382993306537273677557482085204736975067567111831005921322991127165013340443563713385983456311886801211241492470711576322130577278575529202840052753612576061450560588102139907846854501252327551303482213505265853706269864950437458242988327","e":"65537"},
-    "authentication": "/browserid/sign_in.html",
-    // missing "provisioning"
-}
diff --git a/toolkit/identity/tests/unit/head_identity.js b/toolkit/identity/tests/unit/head_identity.js
--- a/toolkit/identity/tests/unit/head_identity.js
+++ b/toolkit/identity/tests/unit/head_identity.js
@@ -12,78 +12,26 @@ Cu.import("resource://testing-common/htt
 // that use the profile directory work.
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "jwcrypto",
                                   "resource://gre/modules/identity/jwcrypto.jsm");
 
-XPCOMUtils.defineLazyModuleGetter(this, "IDService",
-                                  "resource://gre/modules/identity/Identity.jsm",
-                                  "IdentityService");
-
-XPCOMUtils.defineLazyModuleGetter(this,
-                                  "IdentityStore",
-                                  "resource://gre/modules/identity/IdentityStore.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this,
-                                  "Logger",
-                                  "resource://gre/modules/identity/LogUtils.jsm");
-
 XPCOMUtils.defineLazyServiceGetter(this,
                                    "uuidGenerator",
                                    "@mozilla.org/uuid-generator;1",
                                    "nsIUUIDGenerator");
 
+Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+const logger = getLogger("Identity test", "toolkit.identity.debug");
+const log = logger.log;
+
 const TEST_URL = "https://myfavoritebacon.com";
-const TEST_URL2 = "https://myfavoritebaconinacan.com";
-const TEST_USER = "user@mozilla.com";
-const TEST_PRIVKEY = "fake-privkey";
-const TEST_CERT = "fake-cert";
-const TEST_IDPPARAMS = {
-  domain: "myfavoriteflan.com",
-  authentication: "/foo/authenticate.html",
-  provisioning: "/foo/provision.html"
-};
-
-let XULAppInfo = {
-  vendor: "Mozilla",
-  name: "XPCShell",
-  ID: "xpcshell@tests.mozilla.org",
-  version: "1",
-  appBuildID: "20100621",
-  platformVersion: "",
-  platformBuildID: "20100621",
-  inSafeMode: false,
-  logConsoleErrors: true,
-  OS: "XPCShell",
-  XPCOMABI: "noarch-spidermonkey",
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIXULAppInfo, Ci.nsIXULRuntime]),
-  invalidateCachesOnRestart: function invalidateCachesOnRestart() { }
-};
-
-let XULAppInfoFactory = {
-  createInstance: function (outer, iid) {
-    if (outer != null)
-      throw Cr.NS_ERROR_NO_AGGREGATION;
-    return XULAppInfo.QueryInterface(iid);
-  }
-};
-
-let registrar = Components.manager.QueryInterface(Ci.nsIComponentRegistrar);
-registrar.registerFactory(Components.ID("{fbfae60b-64a4-44ef-a911-08ceb70b9f31}"),
-                          "XULAppInfo", "@mozilla.org/xre/app-info;1",
-                          XULAppInfoFactory);
-
-// The following are utility functions for Identity testing
-
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["test"].concat(aMessageArgs));
-}
 
 function get_idstore() {
   return IdentityStore;
 }
 
 function partial(fn) {
   let args = Array.prototype.slice.call(arguments, 1);
   return function() {
@@ -128,86 +76,10 @@ function makeObserver(aObserveTopic, aOb
         Services.obs.removeObserver(observer, aObserveTopic);
       }
     }
   };
 
   Services.obs.addObserver(observer, aObserveTopic, false);
 }
 
-// set up the ID service with an identity with keypair and all
-// when ready, invoke callback with the identity
-function setup_test_identity(identity, cert, cb) {
-  // set up the store so that we're supposed to be logged in
-  let store = get_idstore();
-
-  function keyGenerated(err, kpo) {
-    store.addIdentity(identity, kpo, cert);
-    cb();
-  };
-
-  jwcrypto.generateKeyPair("DS160", keyGenerated);
-}
-
-// takes a list of functions and returns a function that
-// when called the first time, calls the first func,
-// then the next time the second, etc.
-function call_sequentially() {
-  let numCalls = 0;
-  let funcs = arguments;
-
-  return function() {
-    if (!funcs[numCalls]) {
-      let argString = Array.prototype.slice.call(arguments).join(",");
-      do_throw("Too many calls: " + argString);
-      return;
-    }
-    funcs[numCalls].apply(funcs[numCalls],arguments);
-    numCalls += 1;
-  };
-}
-
-/*
- * Setup a provisioning workflow with appropriate callbacks
- *
- * identity is the email we're provisioning.
- *
- * afterSetupCallback is required.
- *
- * doneProvisioningCallback is optional, if the caller
- * wants to be notified when the whole provisioning workflow is done
- *
- * frameCallbacks is optional, contains the callbacks that the sandbox
- * frame would provide in response to DOM calls.
- */
-function setup_provisioning(identity, afterSetupCallback, doneProvisioningCallback, callerCallbacks) {
-  IDService.reset();
-
-  let provId = uuid();
-  IDService.IDP._provisionFlows[provId] = {
-    identity : identity,
-    idpParams: TEST_IDPPARAMS,
-    callback: function(err) {
-      if (doneProvisioningCallback)
-        doneProvisioningCallback(err);
-    },
-    sandbox: {
-	// Emulate the free() method on the iframe sandbox
-	free: function() {}
-    }
-  };
-
-  let caller = {};
-  caller.id = provId;
-  caller.doBeginProvisioningCallback = function(id, duration_s) {
-    if (callerCallbacks && callerCallbacks.beginProvisioningCallback)
-      callerCallbacks.beginProvisioningCallback(id, duration_s);
-  };
-  caller.doGenKeyPairCallback = function(pk) {
-    if (callerCallbacks && callerCallbacks.genKeyPairCallback)
-      callerCallbacks.genKeyPairCallback(pk);
-  };
-
-  afterSetupCallback(caller);
-}
-
 // Switch debug messages on by default
 Services.prefs.setBoolPref("toolkit.identity.debug", true);
diff --git a/toolkit/identity/tests/unit/tail_identity.js b/toolkit/identity/tests/unit/tail_identity.js
deleted file mode 100644
--- a/toolkit/identity/tests/unit/tail_identity.js
+++ /dev/null
@@ -1,8 +0,0 @@
-
-// pre-emptively shut down to clear resources
-if (typeof IdentityService !== "undefined") {
-  IdentityService.shutdown();
-} else if (typeof IDService !== "undefined") {
-  IDService.shutdown();
-}
-
diff --git a/toolkit/identity/tests/unit/test_authentication.js b/toolkit/identity/tests/unit/test_authentication.js
deleted file mode 100644
--- a/toolkit/identity/tests/unit/test_authentication.js
+++ /dev/null
@@ -1,159 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
-   http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-XPCOMUtils.defineLazyModuleGetter(this, "IDService",
-                                  "resource://gre/modules/identity/Identity.jsm",
-                                  "IdentityService");
-
-XPCOMUtils.defineLazyModuleGetter(this, "jwcrypto",
-                                  "resource://gre/modules/identity/jwcrypto.jsm");
-
-function test_begin_authentication_flow() {
-  do_test_pending();
-  let _provId = null;
-
-  // set up a watch, to be consistent
-  let mockedDoc = mock_doc(null, TEST_URL, function(action, params) {});
-  IDService.RP.watch(mockedDoc);
-
-  // The identity-auth notification is sent up to the UX from the
-  // _doAuthentication function.  Be ready to receive it and call
-  // beginAuthentication
-  makeObserver("identity-auth", function (aSubject, aTopic, aData) {
-    do_check_neq(aSubject, null);
-
-    do_check_eq(aSubject.wrappedJSObject.provId, _provId);
-
-    do_test_finished();
-    run_next_test();
-  });
-
-  setup_provisioning(
-    TEST_USER,
-    function(caller) {
-      _provId = caller.id;
-      IDService.IDP.beginProvisioning(caller);
-    }, function() {},
-    {
-      beginProvisioningCallback: function(email, duration_s) {
-
-        // let's say this user needs to authenticate
-        IDService.IDP._doAuthentication(_provId, {idpParams:TEST_IDPPARAMS});
-      }
-    }
-  );
-}
-
-function test_complete_authentication_flow() {
-  do_test_pending();
-  let _provId = null;
-  let _authId = null;
-  let id = TEST_USER;
-
-  let callbacksFired = false;
-  let loginStateChanged = false;
-  let identityAuthComplete = false;
-
-  // The result of authentication should be a successful login
-  IDService.reset();
-
-  setup_test_identity(id, TEST_CERT, function() {
-    // set it up so we're supposed to be logged in to TEST_URL
-
-    get_idstore().setLoginState(TEST_URL, true, id);
-
-    // When we authenticate, our ready callback will be fired.
-    // At the same time, a separate topic will be sent up to the
-    // the observer in the UI.  The test is complete when both
-    // events have occurred.
-    let mockedDoc = mock_doc(id, TEST_URL, call_sequentially(
-      function(action, params) {
-        do_check_eq(action, 'ready');
-        do_check_eq(params, undefined);
-
-        // if notification already received by observer, test is done
-        callbacksFired = true;
-        if (loginStateChanged && identityAuthComplete) {
-          do_test_finished();
-          run_next_test();
-        }
-      }
-    ));
-
-    makeObserver("identity-auth-complete", function(aSubject, aTopic, aData) {
-      identityAuthComplete = true;
-      do_test_finished();
-      run_next_test();
-    });
-
-    makeObserver("identity-login-state-changed", function (aSubject, aTopic, aData) {
-      do_check_neq(aSubject, null);
-
-      do_check_eq(aSubject.wrappedJSObject.rpId, mockedDoc.id);
-      do_check_eq(aData, id);
-
-      // if callbacks in caller doc already fired, test is done.
-      loginStateChanged = true;
-      if (callbacksFired && identityAuthComplete) {
-        do_test_finished();
-        run_next_test();
-      }
-    });
-
-    IDService.RP.watch(mockedDoc);
-
-    // Create a provisioning flow for our auth flow to attach to
-    setup_provisioning(
-      TEST_USER,
-      function(provFlow) {
-        _provId = provFlow.id;
-
-        IDService.IDP.beginProvisioning(provFlow);
-      }, function() {},
-      {
-        beginProvisioningCallback: function(email, duration_s) {
-          // let's say this user needs to authenticate
-          IDService.IDP._doAuthentication(_provId, {idpParams:TEST_IDPPARAMS});
-
-          // test_begin_authentication_flow verifies that the right
-          // message is sent to the UI.  So that works.  Moving on,
-          // the UI calls setAuthenticationFlow ...
-          _authId = uuid();
-          IDService.IDP.setAuthenticationFlow(_authId, _provId);
-
-          // ... then the UI calls beginAuthentication ...
-          authCaller.id = _authId;
-          IDService.IDP._provisionFlows[_provId].caller = authCaller;
-          IDService.IDP.beginAuthentication(authCaller);
-        }
-      }
-    );
-  });
-
-  // A mock calling context
-  let authCaller = {
-    doBeginAuthenticationCallback: function doBeginAuthenticationCallback(identity) {
-      do_check_eq(identity, TEST_USER);
-      // completeAuthentication will emit "identity-auth-complete"
-      IDService.IDP.completeAuthentication(_authId);
-    },
-
-    doError: function(err) {
-      log("OW! My doError callback hurts!", err);
-    },
-  };
-
-}
-
-let TESTS = [];
-
-TESTS.push(test_begin_authentication_flow);
-TESTS.push(test_complete_authentication_flow);
-
-TESTS.forEach(add_test);
-
-function run_test() {
-  run_next_test();
-}
diff --git a/toolkit/identity/tests/unit/test_crypto_service.js b/toolkit/identity/tests/unit/test_crypto_service.js
--- a/toolkit/identity/tests/unit/test_crypto_service.js
+++ b/toolkit/identity/tests/unit/test_crypto_service.js
@@ -1,64 +1,63 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import('resource://gre/modules/identity/LogUtils.jsm');
 
 const idService = Cc["@mozilla.org/identity/crypto-service;1"]
                     .getService(Ci.nsIIdentityCryptoService);
 
 const ALG_DSA = "DS160";
 const ALG_RSA = "RS256";
 
 // When the output of an operation is a
 function do_check_eq_or_slightly_less(x, y) {
   do_check_true(x >= y - (3 * 8));
 }
 
 function test_dsa() {
   idService.generateKeyPair(ALG_DSA, function (rv, keyPair) {
-    log("DSA generateKeyPair finished ", rv);
+    logger.log("DSA generateKeyPair finished ", rv);
     do_check_true(Components.isSuccessCode(rv));
     do_check_eq(typeof keyPair.sign, "function");
     do_check_eq(keyPair.keyType, ALG_DSA);
     do_check_eq_or_slightly_less(keyPair.hexDSAGenerator.length, 1024 / 8 * 2);
     do_check_eq_or_slightly_less(keyPair.hexDSAPrime.length, 1024 / 8 * 2);
     do_check_eq_or_slightly_less(keyPair.hexDSASubPrime.length, 160 / 8 * 2);
     do_check_eq_or_slightly_less(keyPair.hexDSAPublicValue.length, 1024 / 8 * 2);
     // XXX: test that RSA parameters throw the correct error
 
-    log("about to sign with DSA key");
+    logger.log("about to sign with DSA key");
     keyPair.sign("foo", function (rv, signature) {
-      log("DSA sign finished ", rv, signature);
+      logger.log("DSA sign finished ", rv, signature);
       do_check_true(Components.isSuccessCode(rv));
       do_check_true(signature.length > 1);
       // TODO: verify the signature with the public key
       run_next_test();
     });
   });
 }
 
 function test_rsa() {
   idService.generateKeyPair(ALG_RSA, function (rv, keyPair) {
-    log("RSA generateKeyPair finished ", rv);
+    logger.log("RSA generateKeyPair finished ", rv);
     do_check_true(Components.isSuccessCode(rv));
     do_check_eq(typeof keyPair.sign, "function");
     do_check_eq(keyPair.keyType, ALG_RSA);
     do_check_eq_or_slightly_less(keyPair.hexRSAPublicKeyModulus.length,
                                  2048 / 8);
     do_check_true(keyPair.hexRSAPublicKeyExponent.length > 1);
 
-    log("about to sign with RSA key");
+    logger.log("about to sign with RSA key");
     keyPair.sign("foo", function (rv, signature) {
-      log("RSA sign finished ", rv, signature);
+      logger.log("RSA sign finished ", rv, signature);
       do_check_true(Components.isSuccessCode(rv));
       do_check_true(signature.length > 1);
       run_next_test();
     });
   });
 }
 
 add_test(test_dsa);
diff --git a/toolkit/identity/tests/unit/test_identity.js b/toolkit/identity/tests/unit/test_identity.js
deleted file mode 100644
--- a/toolkit/identity/tests/unit/test_identity.js
+++ /dev/null
@@ -1,114 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
-   http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-XPCOMUtils.defineLazyModuleGetter(this, "IDService",
-                                  "resource://gre/modules/identity/Identity.jsm",
-                                  "IdentityService");
-
-function test_overall() {
-  do_check_neq(IDService, null);
-  run_next_test();
-}
-
-function test_mock_doc() {
-  do_test_pending();
-  let mockedDoc = mock_doc(null, TEST_URL, function(action, params) {
-    do_check_eq(action, 'coffee');
-    do_test_finished();
-    run_next_test();
-  });
-
-  mockedDoc.doCoffee();
-}
-
-function test_add_identity() {
-  IDService.reset();
-
-  IDService.addIdentity(TEST_USER);
-
-  let identities = IDService.RP.getIdentitiesForSite(TEST_URL);
-  do_check_eq(identities.result.length, 1);
-  do_check_eq(identities.result[0], TEST_USER);
-
-  run_next_test();
-}
-
-function test_select_identity() {
-  do_test_pending();
-
-  IDService.reset();
-
-  let id = "ishtar@mockmyid.com";
-  setup_test_identity(id, TEST_CERT, function() {
-    let gotAssertion = false;
-    let mockedDoc = mock_doc(null, TEST_URL, call_sequentially(
-      function(action, params) {
-        // ready emitted from first watch() call
-        do_check_eq(action, 'ready');
-        do_check_null(params);
-      },
-      // first the login call
-      function(action, params) {
-        do_check_eq(action, 'login');
-        do_check_neq(params, null);
-
-        // XXX - check that the assertion is for the right email
-
-        gotAssertion = true;
-      },
-      // then the ready call
-      function(action, params) {
-        do_check_eq(action, 'ready');
-        do_check_null(params);
-
-        // we should have gotten the assertion already
-        do_check_true(gotAssertion);
-
-        do_test_finished();
-        run_next_test();
-      }));
-
-    // register the callbacks
-    IDService.RP.watch(mockedDoc);
-
-    // register the request UX observer
-    makeObserver("identity-request", function (aSubject, aTopic, aData) {
-      // do the select identity
-      // we expect this to succeed right away because of test_identity
-      // so we don't mock network requests or otherwise
-      IDService.selectIdentity(aSubject.wrappedJSObject.rpId, id);
-    });
-
-    // do the request
-    IDService.RP.request(mockedDoc.id, {});
-  });
-}
-
-function test_parse_good_email() {
-  var parsed = IDService.parseEmail('prime-minister@jed.gov');
-  do_check_eq(parsed.username, 'prime-minister');
-  do_check_eq(parsed.domain, 'jed.gov');
-  run_next_test();
-}
-
-function test_parse_bogus_emails() {
-  do_check_eq(null, IDService.parseEmail('@evil.org'));
-  do_check_eq(null, IDService.parseEmail('foo@bar@baz.com'));
-  do_check_eq(null, IDService.parseEmail('you@wellsfargo.com/accounts/transfer?to=dolske&amt=all'));
-  run_next_test();
-}
-
-let TESTS = [test_overall, test_mock_doc];
-
-TESTS.push(test_add_identity);
-TESTS.push(test_select_identity);
-TESTS.push(test_parse_good_email);
-TESTS.push(test_parse_bogus_emails);
-
-TESTS.forEach(add_test);
-
-function run_test() {
-  run_next_test();
-}
diff --git a/toolkit/identity/tests/unit/test_identityservice.js b/toolkit/identity/tests/unit/test_identityservice.js
new file mode 100644
--- /dev/null
+++ b/toolkit/identity/tests/unit/test_identityservice.js
@@ -0,0 +1,127 @@
+"use strict";
+
+XPCOMUtils.defineLazyModuleGetter(this, "IdentityService",
+                                  "resource://gre/modules/identity/IdentityService.jsm",
+                                  "IdentityService");
+
+function test_overall() {
+  do_check_neq(IdentityService, null);
+  run_next_test();
+}
+
+function test_mock_doc() {
+  do_test_pending();
+  let mockedDoc = mock_doc(null, TEST_URL, function(action, params) {
+    do_check_eq(action, 'coffee');
+    do_test_finished();
+    run_next_test();
+  });
+
+  mockedDoc.doCoffee();
+}
+
+/*
+ * Test that the "identity-controller-watch" signal is emitted correctly
+ */
+function test_watch() {
+  do_test_pending();
+
+  let mockedDoc = mock_doc(null, TEST_URL);
+  makeObserver("identity-controller-watch", function (aSubject, aTopic, aData) {
+    do_check_eq(aSubject.wrappedJSObject.id, mockedDoc.id);
+    do_check_eq(aSubject.wrappedJSObject.origin, TEST_URL);
+    do_test_finished();
+    run_next_test();
+   });
+
+  IdentityService.RP.watch(mockedDoc);
+}
+
+/*
+ * Test that the "identity-controller-request" signal is emitted correctly
+ */
+function test_request() {
+  do_test_pending();
+
+  let mockedDoc = mock_doc(null, TEST_URL);
+  makeObserver("identity-controller-request", function (aSubject, aTopic, aData) {
+    do_check_eq(aSubject.wrappedJSObject.id, mockedDoc.id);
+    do_check_eq(aSubject.wrappedJSObject.origin, TEST_URL);
+    do_test_finished();
+    run_next_test();
+  });
+
+  IdentityService.RP.watch(mockedDoc);
+  IdentityService.RP.request(mockedDoc.id, {});
+}
+
+/*
+ * Test that the forceAuthentication flag can be sent
+ */
+function test_request_forceAuthentication() {
+  do_test_pending();
+
+  let mockedDoc = mock_doc(null, TEST_URL);
+  makeObserver("identity-controller-request", function (aSubject, aTopic, aData) {
+    do_check_eq(aSubject.wrappedJSObject.id, mockedDoc.id);
+    do_check_eq(aSubject.wrappedJSObject.origin, TEST_URL);
+    do_check_eq(aSubject.wrappedJSObject.forceAuthentication, true);
+    do_test_finished();
+    run_next_test();
+   });
+
+  IdentityService.RP.watch(mockedDoc);
+  IdentityService.RP.request(mockedDoc.id, {forceAuthentication: true});
+}
+
+/*
+ * Test that the issuer can be forced
+ */
+function test_request_forceIssuer() {
+  do_test_pending();
+
+  let mockedDoc = mock_doc(null, TEST_URL);
+  makeObserver("identity-controller-request", function (aSubject, aTopic, aData) {
+    do_check_eq(aSubject.wrappedJSObject.id, mockedDoc.id);
+    do_check_eq(aSubject.wrappedJSObject.origin, TEST_URL);
+    do_check_eq(aSubject.wrappedJSObject.issuer, "https://jed.gov");
+    do_test_finished();
+    run_next_test();
+   });
+
+  IdentityService.RP.watch(mockedDoc);
+  IdentityService.RP.request(mockedDoc.id, {issuer: "https://jed.gov"});
+}
+
+/*
+ * Test that the "identity-controller-logout" signal is emitted correctly
+ */
+function test_logout() {
+  do_test_pending();
+
+  let mockedDoc = mock_doc(null, TEST_URL);
+  makeObserver("identity-controller-logout", function (aSubject, aTopic, aData) {
+    do_check_eq(aSubject.wrappedJSObject.id, mockedDoc.id);
+    do_test_finished();
+    run_next_test();
+  });
+
+  IdentityService.RP.watch(mockedDoc);
+  IdentityService.RP.logout(mockedDoc.id, {});
+}
+
+let TESTS = [
+  test_overall,
+  test_mock_doc,
+  test_watch,
+  test_request,
+  test_request_forceAuthentication,
+  test_request_forceIssuer,
+  test_logout
+];
+
+TESTS.forEach(add_test);
+
+function run_test() {
+  run_next_test();
+}
diff --git a/toolkit/identity/tests/unit/test_jwcrypto.js b/toolkit/identity/tests/unit/test_jwcrypto.js
--- a/toolkit/identity/tests/unit/test_jwcrypto.js
+++ b/toolkit/identity/tests/unit/test_jwcrypto.js
@@ -1,15 +1,13 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict"
 
-Cu.import('resource://gre/modules/identity/LogUtils.jsm');
-
 XPCOMUtils.defineLazyModuleGetter(this, "IDService",
                                   "resource://gre/modules/identity/Identity.jsm",
                                   "IdentityService");
 
 XPCOMUtils.defineLazyModuleGetter(this, "jwcrypto",
                                   "resource://gre/modules/identity/jwcrypto.jsm");
 
 const RP_ORIGIN = "http://123done.org";
@@ -42,29 +40,29 @@ function test_get_assertion() {
 
   jwcrypto.generateKeyPair(
     "DS160",
     function(err, kp) {
       jwcrypto.generateAssertion("fake-cert", kp, RP_ORIGIN, function(err, assertion) {
         do_check_null(err);
 
         // more checks on assertion
-        log("assertion", assertion);
+        logger.log("assertion", assertion);
 
         do_test_finished();
         run_next_test();
       });
     });
 }
 
 function test_rsa() {
   do_test_pending();
   function checkRSA(err, kpo) {
     do_check_neq(kpo, undefined);
-    log(kpo.serializedPublicKey);
+    logger.log(kpo.serializedPublicKey);
     let pk = JSON.parse(kpo.serializedPublicKey);
     do_check_eq(pk.algorithm, "RS");
 /* TODO
     do_check_neq(kpo.sign, null);
     do_check_eq(typeof kpo.sign, "function");
     do_check_neq(kpo.userID, null);
     do_check_neq(kpo.url, null);
     do_check_eq(kpo.url, INTERNAL_ORIGIN);
@@ -84,17 +82,17 @@ function test_rsa() {
 
   jwcrypto.generateKeyPair("RS256", checkRSA);
 }
 
 function test_dsa() {
   do_test_pending();
   function checkDSA(err, kpo) {
     do_check_neq(kpo, undefined);
-    log(kpo.serializedPublicKey);
+    logger.log(kpo.serializedPublicKey);
     let pk = JSON.parse(kpo.serializedPublicKey);
     do_check_eq(pk.algorithm, "DS");
 /* TODO
     do_check_neq(kpo.sign, null);
     do_check_eq(typeof kpo.sign, "function");
     do_check_neq(kpo.userID, null);
     do_check_neq(kpo.url, null);
     do_check_eq(kpo.url, INTERNAL_ORIGIN);
diff --git a/toolkit/identity/tests/unit/test_load_modules.js b/toolkit/identity/tests/unit/test_load_modules.js
--- a/toolkit/identity/tests/unit/test_load_modules.js
+++ b/toolkit/identity/tests/unit/test_load_modules.js
@@ -1,19 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const modules = [
-  "Identity.jsm",
-  "IdentityProvider.jsm",
-  "IdentityStore.jsm",
-  "jwcrypto.jsm",
-  "RelyingParty.jsm",
-  "Sandbox.jsm",
+  "IdentityService.jsm",
+  "jwcrypto.jsm"
 ];
 
 function run_test() {
   for each (let m in modules) {
     let resource = "resource://gre/modules/identity/" + m;
     Components.utils.import(resource, {});
     do_print("loaded " + resource);
   }
diff --git a/toolkit/identity/tests/unit/test_log_utils.js b/toolkit/identity/tests/unit/test_log_utils.js
--- a/toolkit/identity/tests/unit/test_log_utils.js
+++ b/toolkit/identity/tests/unit/test_log_utils.js
@@ -1,74 +1,70 @@
 
 "use strict";
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import('resource://gre/modules/Services.jsm');
-Cu.import('resource://gre/modules/identity/LogUtils.jsm');
+
+// logger defined in head_identity.js
 
 function toggle_debug() {
   do_test_pending();
 
   function Wrapper() {
     this.init();
   }
   Wrapper.prototype = {
     QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports, Ci.nsIObserver]),
 
     observe: function observe(aSubject, aTopic, aData) {
       if (aTopic === "nsPref:changed") {
         // race condition?
-        do_check_eq(Logger._debug, true);
+        do_check_eq(logger._enabled, true);
         do_test_finished();
         run_next_test();
       }
     },
 
     init: function() {
       Services.prefs.addObserver('toolkit.identity.debug', this, false);
     }
   };
 
   var wrapper = new Wrapper();
   Services.prefs.setBoolPref('toolkit.identity.debug', true);
 }
 
 // test that things don't break
 
-function logAlias(...args) {
-  Logger.log.apply(Logger, ["log alias"].concat(args));
-}
-function reportErrorAlias(...args) {
-  Logger.reportError.apply(Logger, ["report error alias"].concat(args));
-}
-
 function test_log() {
-  Logger.log("log test", "I like pie");
+  logger.log("log test", "I like pie");
   do_test_finished();
   run_next_test();
 }
 
-function test_reportError() {
-  Logger.reportError("log test", "We are out of pies!!!");
+function test_warning() {
+  logger.warning("similar log test", "We are still out of pies!!!");
   do_test_finished();
   run_next_test();
 }
 
-function test_wrappers() {
-  logAlias("I like potatoes");
+function test_error() {
+  logger.error("My head a splode");
   do_test_finished();
-  reportErrorAlias("Too much red bull");
+  run_next_test();
 }
 
+
 let TESTS = [
 // XXX fix me 
 //    toggle_debug,
     test_log,
-    test_reportError,
-    test_wrappers
+    test_warning,
+    test_error
 ];
 
 TESTS.forEach(add_test);
 
 function run_test() {
   run_next_test();
-}
\ No newline at end of file
+}
+
diff --git a/toolkit/identity/tests/unit/test_minimalidentity.js b/toolkit/identity/tests/unit/test_minimalidentity.js
deleted file mode 100644
--- a/toolkit/identity/tests/unit/test_minimalidentity.js
+++ /dev/null
@@ -1,133 +0,0 @@
-"use strict";
-
-XPCOMUtils.defineLazyModuleGetter(this, "MinimalIDService",
-                                  "resource://gre/modules/identity/MinimalIdentity.jsm",
-                                  "IdentityService");
-
-Cu.import("resource://gre/modules/identity/LogUtils.jsm");
-
-function log(...aMessageArgs) {
-  Logger.log.apply(Logger, ["test_minimalidentity"].concat(aMessageArgs));
-}
-
-function test_overall() {
-  do_check_neq(MinimalIDService, null);
-  run_next_test();
-}
-
-function test_mock_doc() {
-  do_test_pending();
-  let mockedDoc = mock_doc(null, TEST_URL, function(action, params) {
-    do_check_eq(action, 'coffee');
-    do_test_finished();
-    run_next_test();
-  });
-
-  mockedDoc.doCoffee();
-}
-
-/*
- * Test that the "identity-controller-watch" signal is emitted correctly
- */
-function test_watch() {
-  do_test_pending();
-
-  let mockedDoc = mock_doc(null, TEST_URL);
-  makeObserver("identity-controller-watch", function (aSubject, aTopic, aData) {
-    do_check_eq(aSubject.wrappedJSObject.id, mockedDoc.id);
-    do_check_eq(aSubject.wrappedJSObject.origin, TEST_URL);
-    do_test_finished();
-    run_next_test();
-   });
-
-  MinimalIDService.RP.watch(mockedDoc);
-}
-
-/*
- * Test that the "identity-controller-request" signal is emitted correctly
- */
-function test_request() {
-  do_test_pending();
-
-  let mockedDoc = mock_doc(null, TEST_URL);
-  makeObserver("identity-controller-request", function (aSubject, aTopic, aData) {
-    do_check_eq(aSubject.wrappedJSObject.id, mockedDoc.id);
-    do_check_eq(aSubject.wrappedJSObject.origin, TEST_URL);
-    do_test_finished();
-    run_next_test();
-  });
-
-  MinimalIDService.RP.watch(mockedDoc);
-  MinimalIDService.RP.request(mockedDoc.id, {});
-}
-
-/*
- * Test that the forceAuthentication flag can be sent
- */
-function test_request_forceAuthentication() {
-  do_test_pending();
-
-  let mockedDoc = mock_doc(null, TEST_URL);
-  makeObserver("identity-controller-request", function (aSubject, aTopic, aData) {
-    do_check_eq(aSubject.wrappedJSObject.id, mockedDoc.id);
-    do_check_eq(aSubject.wrappedJSObject.origin, TEST_URL);
-    do_check_eq(aSubject.wrappedJSObject.forceAuthentication, true);
-    do_test_finished();
-    run_next_test();
-   });
-
-  MinimalIDService.RP.watch(mockedDoc);
-  MinimalIDService.RP.request(mockedDoc.id, {forceAuthentication: true});
-}
-
-/*
- * Test that the issuer can be forced
- */
-function test_request_forceIssuer() {
-  do_test_pending();
-
-  let mockedDoc = mock_doc(null, TEST_URL);
-  makeObserver("identity-controller-request", function (aSubject, aTopic, aData) {
-    do_check_eq(aSubject.wrappedJSObject.id, mockedDoc.id);
-    do_check_eq(aSubject.wrappedJSObject.origin, TEST_URL);
-    do_check_eq(aSubject.wrappedJSObject.issuer, "https://jed.gov");
-    do_test_finished();
-    run_next_test();
-   });
-
-  MinimalIDService.RP.watch(mockedDoc);
-  MinimalIDService.RP.request(mockedDoc.id, {issuer: "https://jed.gov"});
-}
-
-/*
- * Test that the "identity-controller-logout" signal is emitted correctly
- */
-function test_logout() {
-  do_test_pending();
-
-  let mockedDoc = mock_doc(null, TEST_URL);
-  makeObserver("identity-controller-logout", function (aSubject, aTopic, aData) {
-    do_check_eq(aSubject.wrappedJSObject.id, mockedDoc.id);
-    do_test_finished();
-    run_next_test();
-  });
-
-  MinimalIDService.RP.watch(mockedDoc);
-  MinimalIDService.RP.logout(mockedDoc.id, {});
-}
-
-let TESTS = [
-  test_overall,
-  test_mock_doc,
-  test_watch,
-  test_request,
-  test_request_forceAuthentication,
-  test_request_forceIssuer,
-  test_logout
-];
-
-TESTS.forEach(add_test);
-
-function run_test() {
-  run_next_test();
-}
diff --git a/toolkit/identity/tests/unit/test_observer_topics.js b/toolkit/identity/tests/unit/test_observer_topics.js
deleted file mode 100644
--- a/toolkit/identity/tests/unit/test_observer_topics.js
+++ /dev/null
@@ -1,114 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
-   http://creativecommons.org/publicdomain/zero/1.0/ */
-
-/**
- * By their nature, these tests duplicate some of the functionality of
- * other tests for Identity, RelyingParty, and IdentityProvider.
- *
- * In particular, "identity-auth-complete" and
- * "identity-login-state-changed" are tested in test_authentication.js
- */
-
-"use strict";
-
-XPCOMUtils.defineLazyModuleGetter(this, "IDService",
-                                  "resource://gre/modules/identity/Identity.jsm",
-                                  "IdentityService");
-
-function test_smoke() {
-  do_check_neq(IDService, null);
-  run_next_test();
-}
-
-function test_identity_request() {
-  // In response to navigator.id.request(), initiate a login with user
-  // interaction by notifying observers of 'identity-request'
-
-  do_test_pending();
-
-  IDService.reset();
-
-  let id = "landru@mockmyid.com";
-  setup_test_identity(id, TEST_CERT, function() {
-    // deliberately adding a trailing final slash on the domain
-    // to test path composition
-    let mockedDoc = mock_doc(null, "http://jed.gov/", function() {});
-
-    // by calling watch() we create an rp flow.
-    IDService.RP.watch(mockedDoc);
-
-    // register the request UX observer
-    makeObserver("identity-request", function (aSubject, aTopic, aData) {
-      do_check_eq(aTopic, "identity-request");
-      do_check_eq(aData, null);
-
-      // check that all the URLs are properly resolved
-      let subj = aSubject.wrappedJSObject;
-      do_check_eq(subj.privacyPolicy, "http://jed.gov/pp.html");
-      do_check_eq(subj.termsOfService, "http://jed.gov/tos.html");
-
-      do_test_finished();
-      run_next_test();
-    });
-
-    let requestOptions = {
-      privacyPolicy: "/pp.html",
-      termsOfService: "/tos.html"
-    };
-    IDService.RP.request(mockedDoc.id, requestOptions);
-  });
-
-}
-
-function test_identity_auth() {
-  // see test_authentication.js for "identity-auth-complete"
-  // and "identity-login-state-changed"
-
-  do_test_pending();
-  let _provId = "bogus";
-
-  // Simulate what would be returned by IDService._fetchWellKnownFile
-  // for a given domain.
-  let idpParams = {
-    domain: "myfavoriteflan.com",
-    idpParams: {
-      authentication: "/foo/authenticate.html",
-      provisioning: "/foo/provision.html"
-    }
-  };
-
-  // Create an RP flow
-  let mockedDoc = mock_doc(null, TEST_URL, function(action, params) {});
-  IDService.RP.watch(mockedDoc);
-
-  // The identity-auth notification is sent up to the UX from the
-  // _doAuthentication function.  Be ready to receive it and call
-  // beginAuthentication
-  makeObserver("identity-auth", function (aSubject, aTopic, aData) {
-    do_check_neq(aSubject, null);
-    do_check_eq(aTopic, "identity-auth");
-    do_check_eq(aData, "https://myfavoriteflan.com/foo/authenticate.html");
-
-    do_check_eq(aSubject.wrappedJSObject.provId, _provId);
-    do_test_finished();
-    run_next_test();
-  });
-
-  // Even though our provisioning flow id is bogus, IdentityProvider
-  // won't look at it until farther along in the authentication
-  // process.  So this test can pass with a fake provId.
-  IDService.IDP._doAuthentication(_provId, idpParams);
-}
-
-let TESTS = [
-    test_smoke,
-    test_identity_request,
-    test_identity_auth,
-  ];
-
-
-TESTS.forEach(add_test);
-
-function run_test() {
-  run_next_test();
-}
diff --git a/toolkit/identity/tests/unit/test_provisioning.js b/toolkit/identity/tests/unit/test_provisioning.js
deleted file mode 100644
--- a/toolkit/identity/tests/unit/test_provisioning.js
+++ /dev/null
@@ -1,242 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
-   http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-Cu.import("resource://gre/modules/identity/IdentityProvider.jsm");
-
-function check_provision_flow_done(provId) {
-  do_check_null(IdentityProvider._provisionFlows[provId]);
-}
-
-function test_begin_provisioning() {
-  do_test_pending();
-
-  setup_provisioning(
-    TEST_USER,
-    function(caller) {
-      // call .beginProvisioning()
-      IdentityProvider.beginProvisioning(caller);
-    }, function() {},
-    {
-      beginProvisioningCallback: function(email, duration_s) {
-        do_check_eq(email, TEST_USER);
-        do_check_true(duration_s > 0);
-        do_check_true(duration_s <= (24 * 3600));
-
-        do_test_finished();
-        run_next_test();
-      }
-    });
-}
-
-function test_raise_provisioning_failure() {
-  do_test_pending();
-  let _callerId = null;
-
-  setup_provisioning(
-    TEST_USER,
-    function(caller) {
-      // call .beginProvisioning()
-      _callerId = caller.id;
-      IdentityProvider.beginProvisioning(caller);
-    }, function(err) {
-      // this should be invoked with a populated error
-      do_check_neq(err, null);
-      do_check_true(err.indexOf("can't authenticate this email") > -1);
-
-      do_test_finished();
-      run_next_test();
-    },
-    {
-      beginProvisioningCallback: function(email, duration_s) {
-        // raise the failure as if we can't provision this email
-        IdentityProvider.raiseProvisioningFailure(_callerId, "can't authenticate this email");
-      }
-    });
-}
-
-function test_genkeypair_before_begin_provisioning() {
-  do_test_pending();
-
-  setup_provisioning(
-    TEST_USER,
-    function(caller) {
-      // call genKeyPair without beginProvisioning
-      IdentityProvider.genKeyPair(caller.id);
-    },
-    // expect this to be called with an error
-    function(err) {
-      do_check_neq(err, null);
-
-      do_test_finished();
-      run_next_test();
-    },
-    {
-      // this should not be called at all!
-      genKeyPairCallback: function(pk) {
-        // a test that will surely fail because we shouldn't be here.
-        do_check_true(false);
-
-        do_test_finished();
-        run_next_test();
-      }
-    }
-  );
-}
-
-function test_genkeypair() {
-  do_test_pending();
-  let _callerId = null;
-
-  setup_provisioning(
-    TEST_USER,
-    function(caller) {
-      _callerId = caller.id;
-      IdentityProvider.beginProvisioning(caller);
-    },
-    function(err) {
-      // should not be called!
-      do_check_true(false);
-
-      do_test_finished();
-      run_next_test();
-    },
-    {
-      beginProvisioningCallback: function(email, time_s) {
-        IdentityProvider.genKeyPair(_callerId);
-      },
-      genKeyPairCallback: function(kp) {
-        do_check_neq(kp, null);
-
-        // yay!
-        do_test_finished();
-        run_next_test();
-      }
-    }
-  );
-}
-
-// we've already ensured that genkeypair can't be called
-// before beginProvisioning, so this test should be enough
-// to ensure full sequential call of the 3 APIs.
-function test_register_certificate_before_genkeypair() {
-  do_test_pending();
-  let _callerID = null;
-
-  setup_provisioning(
-    TEST_USER,
-    function(caller) {
-      // do the right thing for beginProvisioning
-      _callerID = caller.id;
-      IdentityProvider.beginProvisioning(caller);
-    },
-    // expect this to be called with an error
-    function(err) {
-      do_check_neq(err, null);
-
-      do_test_finished();
-      run_next_test();
-    },
-    {
-      beginProvisioningCallback: function(email, duration_s) {
-        // now we try to register cert but no keygen has been done
-        IdentityProvider.registerCertificate(_callerID, "fake-cert");
-      }
-    }
-  );
-}
-
-function test_register_certificate() {
-  do_test_pending();
-  let _callerId = null;
-
-  setup_provisioning(
-    TEST_USER,
-    function(caller) {
-      _callerId = caller.id;
-      IdentityProvider.beginProvisioning(caller);
-    },
-    function(err) {
-      // we should be cool!
-      do_check_null(err);
-
-      // check that the cert is there
-      let identity = get_idstore().fetchIdentity(TEST_USER);
-      do_check_neq(identity,null);
-      do_check_eq(identity.cert, "fake-cert-42");
-
-      do_execute_soon(function check_done() {
-        // cleanup will happen after the callback is called
-        check_provision_flow_done(_callerId);
-
-        do_test_finished();
-        run_next_test();
-      });
-    },
-    {
-      beginProvisioningCallback: function(email, duration_s) {
-        IdentityProvider.genKeyPair(_callerId);
-      },
-      genKeyPairCallback: function(pk) {
-        IdentityProvider.registerCertificate(_callerId, "fake-cert-42");
-      }
-    }
-  );
-}
-
-
-function test_get_assertion_after_provision() {
-  do_test_pending();
-  let _callerId = null;
-
-  setup_provisioning(
-    TEST_USER,
-    function(caller) {
-      _callerId = caller.id;
-      IdentityProvider.beginProvisioning(caller);
-    },
-    function(err) {
-      // we should be cool!
-      do_check_null(err);
-
-      // check that the cert is there
-      let identity = get_idstore().fetchIdentity(TEST_USER);
-      do_check_neq(identity,null);
-      do_check_eq(identity.cert, "fake-cert-42");
-
-      do_execute_soon(function check_done() {
-        // cleanup will happen after the callback is called
-        check_provision_flow_done(_callerId);
-
-        do_test_finished();
-        run_next_test();
-      });
-    },
-    {
-      beginProvisioningCallback: function(email, duration_s) {
-        IdentityProvider.genKeyPair(_callerId);
-      },
-      genKeyPairCallback: function(pk) {
-        IdentityProvider.registerCertificate(_callerId, "fake-cert-42");
-      }
-    }
-  );
-
-}
-
-let TESTS = [];
-
-TESTS.push(test_begin_provisioning);
-TESTS.push(test_raise_provisioning_failure);
-TESTS.push(test_genkeypair_before_begin_provisioning);
-TESTS.push(test_genkeypair);
-TESTS.push(test_register_certificate_before_genkeypair);
-TESTS.push(test_register_certificate);
-TESTS.push(test_get_assertion_after_provision);
-
-TESTS.forEach(add_test);
-
-function run_test() {
-  run_next_test();
-}
diff --git a/toolkit/identity/tests/unit/test_relying_party.js b/toolkit/identity/tests/unit/test_relying_party.js
deleted file mode 100644
--- a/toolkit/identity/tests/unit/test_relying_party.js
+++ /dev/null
@@ -1,255 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
-   http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-XPCOMUtils.defineLazyModuleGetter(this, "RelyingParty",
-                                  "resource://gre/modules/identity/RelyingParty.jsm");
-
-function resetState() {
-  get_idstore().reset();
-  RelyingParty.reset();
-}
-
-function test_watch_loggedin_ready() {
-  do_test_pending();
-
-  resetState();
-
-  let id = TEST_USER;
-  setup_test_identity(id, TEST_CERT, function() {
-    let store = get_idstore();
-
-    // set it up so we're supposed to be logged in to TEST_URL
-    store.setLoginState(TEST_URL, true, id);
-    RelyingParty.watch(mock_doc(id, TEST_URL, function(action, params) {
-      do_check_eq(action, 'ready');
-      do_check_eq(params, undefined);
-
-      do_test_finished();
-      run_next_test();
-    }));
-  });
-}
-
-function test_watch_loggedin_login() {
-  do_test_pending();
-
-  resetState();
-
-  let id = TEST_USER;
-  setup_test_identity(id, TEST_CERT, function() {
-    let store = get_idstore();
-
-    // set it up so we're supposed to be logged in to TEST_URL
-    store.setLoginState(TEST_URL, true, id);
-
-    // check for first a login() call, then a ready() call
-    RelyingParty.watch(mock_doc(null, TEST_URL, call_sequentially(
-      function(action, params) {
-        do_check_eq(action, 'login');
-        do_check_neq(params, null);
-      },
-      function(action, params) {
-        do_check_eq(action, 'ready');
-        do_check_null(params);
-
-        do_test_finished();
-        run_next_test();
-      }
-    )));
-  });
-}
-
-function test_watch_loggedin_logout() {
-  do_test_pending();
-
-  resetState();
-
-  let id = TEST_USER;
-  let other_id = "otherid@foo.com";
-  setup_test_identity(other_id, TEST_CERT, function() {
-    setup_test_identity(id, TEST_CERT, function() {
-      let store = get_idstore();
-
-      // set it up so we're supposed to be logged in to TEST_URL
-      // with id, not other_id
-      store.setLoginState(TEST_URL, true, id);
-
-      // this should cause a login with an assertion for id,
-      // not for other_id
-      RelyingParty.watch(mock_doc(other_id, TEST_URL, call_sequentially(
-        function(action, params) {
-          do_check_eq(action, 'login');
-          do_check_neq(params, null);
-        },
-        function(action, params) {
-          do_check_eq(action, 'ready');
-          do_check_null(params);
-
-          do_test_finished();
-          run_next_test();
-        }
-      )));
-    });
-  });
-}
-
-function test_watch_notloggedin_ready() {
-  do_test_pending();
-
-  resetState();
-
-  RelyingParty.watch(mock_doc(null, TEST_URL, function(action, params) {
-    do_check_eq(action, 'ready');
-    do_check_eq(params, undefined);
-
-    do_test_finished();
-    run_next_test();
-  }));
-}
-
-function test_watch_notloggedin_logout() {
-  do_test_pending();
-
-  resetState();
-
-  RelyingParty.watch(mock_doc(TEST_USER, TEST_URL, call_sequentially(
-    function(action, params) {
-      do_check_eq(action, 'logout');
-      do_check_eq(params, undefined);
-
-      let store = get_idstore();
-      do_check_null(store.getLoginState(TEST_URL));
-    },
-    function(action, params) {
-      do_check_eq(action, 'ready');
-      do_check_eq(params, undefined);
-      do_test_finished();
-      run_next_test();
-    }
-  )));
-}
-
-function test_request() {
-  do_test_pending();
-
-  // set up a watch, to be consistent
-  let mockedDoc = mock_doc(null, TEST_URL, function(action, params) {
-    // this isn't going to be called for now
-    // XXX but it is called - is that bad?
-  });
-
-  RelyingParty.watch(mockedDoc);
-
-  // be ready for the UX identity-request notification
-  makeObserver("identity-request", function (aSubject, aTopic, aData) {
-    do_check_neq(aSubject, null);
-
-    do_check_eq(aSubject.wrappedJSObject.rpId, mockedDoc.id);
-
-    do_test_finished();
-    run_next_test();
-  });
-
-  RelyingParty.request(mockedDoc.id, {});
-}
-
-/*
- * ensure the forceAuthentication param can be passed through
- */
-function test_request_forceAuthentication() {
-  do_test_pending();
-
-  let mockedDoc = mock_doc(null, TEST_URL, function(action, params) {});
-
-  RelyingParty.watch(mockedDoc);
-
-  makeObserver("identity-request", function(aSubject, aTopic, aData) {
-    do_check_eq(aSubject.wrappedJSObject.rpId, mockedDoc.id);
-    do_check_eq(aSubject.wrappedJSObject.forceAuthentication, true);
-    do_test_finished();
-    run_next_test();
-  });
-
-  RelyingParty.request(mockedDoc.id, {forceAuthentication: true});
-}
-
-/*
- * ensure the issuer can be forced
- */
-function test_request_forceIssuer() {
-  do_test_pending();
-
-  let mockedDoc = mock_doc(null, TEST_URL, function(action, params) {});
-
-  RelyingParty.watch(mockedDoc);
-
-  makeObserver("identity-request", function(aSubject, aTopic, aData) {
-    do_check_eq(aSubject.wrappedJSObject.rpId, mockedDoc.id);
-    do_check_eq(aSubject.wrappedJSObject.issuer, "https://ozten.co.uk");
-    do_test_finished();
-    run_next_test();
-  });
-
-  RelyingParty.request(mockedDoc.id, {issuer: "https://ozten.co.uk"});
-}
-function test_logout() {
-  do_test_pending();
-
-  resetState();
-
-  let id = TEST_USER;
-  setup_test_identity(id, TEST_CERT, function() {
-    let store = get_idstore();
-
-    // set it up so we're supposed to be logged in to TEST_URL
-    store.setLoginState(TEST_URL, true, id);
-
-    let doLogout;
-    let mockedDoc = mock_doc(id, TEST_URL, call_sequentially(
-      function(action, params) {
-        do_check_eq(action, 'ready');
-        do_check_eq(params, undefined);
-
-        do_timeout(100, doLogout);
-      },
-      function(action, params) {
-        do_check_eq(action, 'logout');
-        do_check_eq(params, undefined);
-      },
-      function(action, params) {
-        do_check_eq(action, 'ready');
-        do_check_eq(params, undefined);
-
-        do_test_finished();
-        run_next_test();
-      }));
-
-    doLogout = function() {
-      RelyingParty.logout(mockedDoc.id);
-      do_check_false(store.getLoginState(TEST_URL).isLoggedIn);
-      do_check_eq(store.getLoginState(TEST_URL).email, TEST_USER);
-    };
-
-    RelyingParty.watch(mockedDoc);
-  });
-}
-
-let TESTS = [
-  test_watch_loggedin_ready,
-  test_watch_loggedin_login,
-  test_watch_loggedin_logout,
-  test_watch_notloggedin_ready,
-  test_watch_notloggedin_logout,
-  test_request,
-  test_request_forceAuthentication,
-  test_request_forceIssuer,
-  test_logout
-];
-
-TESTS.forEach(add_test);
-
-function run_test() {
-  run_next_test();
-}
diff --git a/toolkit/identity/tests/unit/test_store.js b/toolkit/identity/tests/unit/test_store.js
deleted file mode 100644
--- a/toolkit/identity/tests/unit/test_store.js
+++ /dev/null
@@ -1,64 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
-   http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-XPCOMUtils.defineLazyModuleGetter(this, "IDService",
-                                  "resource://gre/modules/identity/Identity.jsm",
-                                  "IdentityService");
-
-function test_id_store() {
-  // XXX - this is ugly, peaking in like this into IDService
-  // probably should instantiate our own.
-  var store = get_idstore();
-
-  // try adding an identity
-  store.addIdentity(TEST_USER, TEST_PRIVKEY, TEST_CERT);
-  do_check_neq(store.getIdentities()[TEST_USER], null);
-  do_check_eq(store.getIdentities()[TEST_USER].cert, TEST_CERT);
-
-  // does fetch identity work?
-  do_check_neq(store.fetchIdentity(TEST_USER), null);
-  do_check_eq(store.fetchIdentity(TEST_USER).cert, TEST_CERT);
-
-  // clear the cert should keep the identity but not the cert
-  store.clearCert(TEST_USER);
-  do_check_neq(store.getIdentities()[TEST_USER], null);
-  do_check_null(store.getIdentities()[TEST_USER].cert);
-
-  // remove it should remove everything
-  store.removeIdentity(TEST_USER);
-  do_check_eq(store.getIdentities()[TEST_USER], undefined);
-
-  // act like we're logged in to TEST_URL
-  store.setLoginState(TEST_URL, true, TEST_USER);
-  do_check_neq(store.getLoginState(TEST_URL), null);
-  do_check_true(store.getLoginState(TEST_URL).isLoggedIn);
-  do_check_eq(store.getLoginState(TEST_URL).email, TEST_USER);
-
-  // log out
-  store.setLoginState(TEST_URL, false, TEST_USER);
-  do_check_neq(store.getLoginState(TEST_URL), null);
-  do_check_false(store.getLoginState(TEST_URL).isLoggedIn);
-
-  // email is still set
-  do_check_eq(store.getLoginState(TEST_URL).email, TEST_USER);
-
-  // not logged into other site
-  do_check_null(store.getLoginState(TEST_URL2));
-
-  // clear login state
-  store.clearLoginState(TEST_URL);
-  do_check_null(store.getLoginState(TEST_URL));
-  do_check_null(store.getLoginState(TEST_URL2));
-
-  run_next_test();
-}
-
-let TESTS = [test_id_store,];
-
-TESTS.forEach(add_test);
-
-function run_test() {
-  run_next_test();
-}
diff --git a/toolkit/identity/tests/unit/test_well-known.js b/toolkit/identity/tests/unit/test_well-known.js
deleted file mode 100644
--- a/toolkit/identity/tests/unit/test_well-known.js
+++ /dev/null
@@ -1,90 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
-   http://creativecommons.org/publicdomain/zero/1.0/ */
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "IDService",
-                                  "resource://gre/modules/identity/Identity.jsm",
-                                  "IdentityService");
-
-const WELL_KNOWN_PATH = "/.well-known/browserid";
-
-let SERVER_PORT = 8080;
-
-// valid IDP
-function test_well_known_1() {
-  do_test_pending();
-
-  let server = new HttpServer();
-  server.registerFile(WELL_KNOWN_PATH, do_get_file("data/idp_1" + WELL_KNOWN_PATH));
-  server.start(SERVER_PORT);
-  let hostPort = "localhost:" + SERVER_PORT;
-
-  function check_well_known(aErr, aCallbackObj) {
-    do_check_null(aErr);
-    do_check_eq(aCallbackObj.domain, hostPort);
-    let idpParams = aCallbackObj.idpParams;
-    do_check_eq(idpParams['public-key'].algorithm, "RS");
-    do_check_eq(idpParams.authentication, "/browserid/sign_in.html");
-    do_check_eq(idpParams.provisioning, "/browserid/provision.html");
-
-    do_test_finished();
-    server.stop(run_next_test);
-  }
-
-  IDService._fetchWellKnownFile(hostPort, check_well_known, "http");
-}
-
-// valid domain, non-exixtent browserid file
-function test_well_known_404() {
-  do_test_pending();
-
-  let server = new HttpServer();
-  // Don't register the well-known file
-  // Change ports to avoid HTTP caching
-  SERVER_PORT++;
-  server.start(SERVER_PORT);
-
-  let hostPort = "localhost:" + SERVER_PORT;
-
-  function check_well_known_404(aErr, aCallbackObj) {
-    do_check_eq("Error", aErr);
-    do_check_eq(undefined, aCallbackObj);
-    do_test_finished();
-    server.stop(run_next_test);
-  }
-
-  IDService._fetchWellKnownFile(hostPort, check_well_known_404, "http");
-}
-
-// valid domain, invalid browserid file (no "provisioning" member)
-function test_well_known_invalid_1() {
-  do_test_pending();
-
-  let server = new HttpServer();
-  server.registerFile(WELL_KNOWN_PATH, do_get_file("data/idp_invalid_1" + WELL_KNOWN_PATH));
-  // Change ports to avoid HTTP caching
-  SERVER_PORT++;
-  server.start(SERVER_PORT);
-
-  let hostPort = "localhost:" + SERVER_PORT;
-
-  function check_well_known_invalid_1(aErr, aCallbackObj) {
-    // check for an error message
-    do_check_true(aErr && aErr.length > 0);
-    do_check_eq(undefined, aCallbackObj);
-    do_test_finished();
-    server.stop(run_next_test);
-  }
-
-  IDService._fetchWellKnownFile(hostPort, check_well_known_invalid_1, "http");
-}
-
-let TESTS = [test_well_known_1, test_well_known_404, test_well_known_invalid_1];
-
-TESTS.forEach(add_test);
-
-function run_test() {
-  run_next_test();
-}
diff --git a/toolkit/identity/tests/unit/xpcshell.ini b/toolkit/identity/tests/unit/xpcshell.ini
--- a/toolkit/identity/tests/unit/xpcshell.ini
+++ b/toolkit/identity/tests/unit/xpcshell.ini
@@ -1,19 +1,12 @@
 [DEFAULT]
 head = head_identity.js
-tail = tail_identity.js
+tail = 
 
 # Test load modules first so syntax failures are caught early.
 [test_load_modules.js]
-[test_minimalidentity.js]
-
 [test_identity_utils.js]
 [test_log_utils.js]
-[test_authentication.js]
+[test_identityservice.js]
 [test_crypto_service.js]
-[test_identity.js]
 [test_jwcrypto.js]
-[test_observer_topics.js]
-[test_provisioning.js]
-[test_relying_party.js]
-[test_store.js]
-[test_well-known.js]
+
