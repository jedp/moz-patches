# HG changeset patch
# Parent 7abb56b3bbb7400d5387d53dfed35d0acf32eaca

diff --git a/browser/base/content/browser-id-createAccount.html b/browser/base/content/browser-id-createAccount.html
new file mode 100644
--- /dev/null
+++ b/browser/base/content/browser-id-createAccount.html
@@ -0,0 +1,34 @@
+<html>
+  <head>
+    <title>Create Account</title>
+  </head>
+  <body>
+    <!-- create a persona account -->
+    <form>
+      <input type='text' id='email'/>
+      <input type='password' id='password'/>
+      <input type='submit' id='submit'/>
+    </form>
+
+    <script type="text/javascript;version=1.8">
+      Components.utils.import('resource://gre/modules/identity/MinimalIdentity.jsm');
+      let origin = 'resource://some-kind-of-robot';
+      let submit = document.getElementById('submit');
+      let email = document.getElementById('email');
+      let password = document.getElementById('password');
+
+      submit.addEventListener('click', function(evt) {
+        evt.preventDefault();
+        IdentityService.createAccount({
+          email: email.value,
+          password: password.value,
+          origin: origin,
+          allowUnverified: true}, 
+          function(assertion) {
+            alert("created account and signed in!  Assertion is " + (assertion === null ? null : typeof assertion));
+          }
+        );
+      });
+    </script>
+  </body>
+</html>
diff --git a/browser/base/content/browser-id-signIn.html b/browser/base/content/browser-id-signIn.html
new file mode 100644
--- /dev/null
+++ b/browser/base/content/browser-id-signIn.html
@@ -0,0 +1,34 @@
+<html>
+  <head>
+    <title>Sign In</title>
+  </head>
+  <body>
+    <!-- sign in with persona account -->
+    <form>
+      <input type='text' id='email'/>
+      <input type='password' id='password'/>
+      <input type='submit' id='submit'/>
+    </form>
+
+    <script type="text/javascript;version=1.8">
+      Components.utils.import('resource://gre/modules/identity/MinimalIdentity.jsm');
+      let origin = 'resource://some-kind-of-robot';
+      let submit = document.getElementById('submit');
+      let email = document.getElementById('email');
+      let password = document.getElementById('password');
+
+      submit.addEventListener('click', function(evt) {
+        evt.preventDefault();
+        IdentityService.signIn({
+          email: email.value,
+          password: password.value,
+          origin: origin,
+          allowUnverified: true}, 
+          function(assertion) {
+            alert("signed in! Assertion is " + (assertion === null ? null : typeof assertion));
+          }
+        );
+      });
+    </script>
+  </body>
+</html>
diff --git a/browser/base/content/browser-identity.js b/browser/base/content/browser-identity.js
--- a/browser/base/content/browser-identity.js
+++ b/browser/base/content/browser-identity.js
@@ -21,43 +21,68 @@ function IdentityShim() {
   this.isLoaded = false;
 }
 
 IdentityShim.prototype = {
   init: function IdentityShim_init() {
     addMessageListener('identity-delegate-watch', this);
     addMessageListener('identity-delegate-request', this);
     addMessageListener('identity-delegate-logout', this);
+
+    addMessageListener('identity-delegate-getIdentity', this);
+    addMessageListener('identity-delegate-signIn', this);
+    addMessageListener('identity-delegate-signOut', this);
+    addMessageListener('identity-delegate-createAccount', this);
     sendAsyncMessage('identity-delegate-loaded');
     logger.log('init().  sent identity-delegate-complete');
     this.isLoaded = true;
   },
 
   uninit: function IdentityShim_uninit() {
     if (this.isLoaded) {
       removeMessageListener('identity-delegate-watch', this);
       removeMessageListener('identity-delegate-request', this);
       removeMessageListener('identity-delegate-logout', this);
+
+      removeMessageListener('identity-delegate-getIdentity', this);
+      removeMessageListener('identity-delegate-signIn', this);
+      removeMessageListener('identity-delegate-signOut', this);
+      removeMessageListener('identity-delegate-createAccount', this);
       sendAsyncMessage('identity-delegate-complete', null);
       logger.log('uninit().  sent identity-delegate-complete');
       this.isLoaded = false;
     }
   },
 
   receiveMessage: function IdentityShim_receiveMessage(aMessage) {
+    let options = aMessage.json;
     switch (aMessage.name) {
       case 'identity-delegate-watch':
-        this.watch(aMessage.json);
+        this.watch(options);
         break;
       case 'identity-delegate-request':
-        this.request(aMessage.json);
+        this.request(options);
         break;
       case 'identity-delegate-logout':
-        this.logout(aMessage.json);
+        this.logout(options);
         break;
+
+      case 'identity-delegate-getIdentity':
+        this.getIdentity(options);
+        break;
+      case 'identity-delegate-signIn':
+        this.signIn(options);
+        break;
+      case 'identity-delegate-signOut':
+        this.signOut(options);
+        break;
+      case 'identity-delegate-createAccount':
+        this.createAccount(options);
+        break;
+  
       default:
         logger.error("received unexpected message:", aMessage.name);
         break;
     }
   },
 
   _identityDoMethod: function IdentityShim__identityDoMethod(message) {
     sendAsyncMessage('identity-service-doMethod', message);
@@ -66,17 +91,17 @@ IdentityShim.prototype = {
   _close: function IdentityShim__close() {
     this.uninit();
   },
 
   watch: function IdentityShim_watch(options) {
     logger.log('doInternalWatch: isLoaded:', this.isLoaded, 'options:', options);
     if (options) {
       let BrowserID = content.wrappedJSObject.BrowserID;
-      let callback = function(aParams, aInternalParams) {
+      let callback = function shim_watchCallback(aParams, aInternalParams) {
         this._identityDoMethod(aParams);
         if (aParams.method === 'ready') {
           this._close();
         }
       }.bind(this);
 
       BrowserID.internal.watch(
         callback,
@@ -86,49 +111,133 @@ IdentityShim.prototype = {
         }
       );
     }
   },
 
   request: function IdentityShim_request(options) {
     logger.log('doInternalRequest: isLoaded:', this.isLoaded, 'options:', options);
     if (options) {
-      var stringifiedOptions = JSON.stringify(options);
-      let callback = function(assertion, internalParams) {
+      let stringifiedOptions = JSON.stringify(options);
+      let callback = function shim_requestCallback(assertion, internalParams) {
         internalParams = internalParams || {};
-        if (assertion) {
-          logger.log("got assertion");
-          this._identityDoMethod({
-            method: 'login',
-            assertion: assertion,
-            _internal: options._internal,
-            _internalParams: internalParams});
-        }
+        this._identityDoMethod({
+          method: 'login',
+          assertion: assertion,
+          _internal: options._internal,
+          _internalParams: internalParams});
         this._close();
       }.bind(this);
 
       content.wrappedJSObject.BrowserID.internal.get(
         options.origin,
         callback,
         stringifiedOptions
       );
     }
   },
 
   logout: function IdentityShim_logout(options) {
     logger.log('doInternalLogout: isLoaded:', this.isLoaded, 'options:', options);
     if (options) {
       let BrowserID = content.wrappedJSObject.BrowserID;
-      let callback = function() {
+      let callback = function shim_logoutCallback() {
         this._identityDoMethod({method: 'logout', _internal: options._internal});
         this._close();
       }.bind(this);
 
       BrowserID.internal.logout(options.origin, callback);
     }
+  },
+
+  /*
+   * Get identity for browser
+   */
+  getIdentity: function IdentityShim_getIdentity(options) {
+    let stringifiedOptions = JSON.stringify(options);
+    let callback = function shim_getIdentityCallback(err, assertion, internalParams) {
+      logger.log("got identity:", assertion);
+      internalParams = internalParams || {};
+      this._identityDoMethod({
+        method: 'getIdentity',
+        assertion: assertion,
+        _internal: options._internal,
+        _internalParams: internalParams});
+      this._close();
+    }.bind(this);
+
+    content.wrappedJSObject.BrowserID.internal.getIdentity(
+      options.origin,
+      callback,
+      stringifiedOptions
+    );
+    logger.log("called internal getIdentity");
+  },
+
+  /*
+   * Sign in to browser
+   */
+  signIn: function IdentityShim_signIn(options) {
+    logger.log("signin with options", options);
+    let stringifiedOptions = JSON.stringify(options);
+    let BrowserID = content.wrappedJSObject.BrowserID;
+
+    let callback = function shim_signInCallback(err, assertion, internalParams) {
+      internalParams = internalParams || {};
+      logger.log("got assertion", assertion);
+      this._identityDoMethod({
+        method: 'signIn',
+        assertion: assertion,
+        error: err,
+        _internal: options._internal,
+        _internalParams: internalParams});
+    }.bind(this);
+
+    BrowserID.internal.signIn(stringifiedOptions, callback);
+  },
+
+  /*
+   * Sign out of browser
+   */
+
+  signOut: function IdentityShim_signOut(options) {
+    logger.log("signout with options", options);
+    let BrowserID = content.wrappedJSObject.BrowserID;
+    let stringifiedOptions = JSON.stringify(options);
+
+    let callback = function shim_signOutCallback() {
+      this._identityDoMethod({method: 'signOut', _internal: options._internal});
+      this._close();
+    }.bind(this);
+
+    BrowserID.internal.signOut(stringifiedOptions, callback);
+  },
+
+  /*
+   * Create user from browser
+   */
+  createAccount: function IdentityShim_createAccount(options) {
+    logger.log("create user with options", options);
+    let stringifiedOptions = JSON.stringify(options);
+    let BrowserID = content.wrappedJSObject.BrowserID;
+
+    let callback = function shim_createAccountCallback(err, assertion, internalParams) {
+      logger.log("got assertion", assertion);
+      this._identityDoMethod({
+        id: options.id,
+        error: err,
+        method: 'createAccount',
+        assertion: assertion,
+        email: options.email,
+        origin: options.origin,
+        _internal: options._internal,
+        _internalParams: internalParams});
+    }.bind(this);
+
+    BrowserID.internal.createAccount(stringifiedOptions, callback);
   }
 };
 
 this.shim = null; 
 
 addEventListener('DOMContentLoaded', function(e) {
   content.addEventListener('load', function(e) {
     logger.log('content loaded');
@@ -138,9 +247,8 @@ addEventListener('DOMContentLoaded', fun
 });
 
 content.addEventListener('beforeunload', function(e) {
   if (this.shim) {
     this.shim.uninit();
   }
 });
 
-
diff --git a/browser/base/jar.mn b/browser/base/jar.mn
--- a/browser/base/jar.mn
+++ b/browser/base/jar.mn
@@ -56,16 +56,18 @@ browser.jar:
 #endif
         content/browser/aboutRobots-icon.png          (content/aboutRobots-icon.png)
         content/browser/aboutRobots-widget-left.png   (content/aboutRobots-widget-left.png)
         content/browser/aboutSocialError.xhtml        (content/aboutSocialError.xhtml)
 *       content/browser/browser.css                   (content/browser.css)
 *       content/browser/browser.js                    (content/browser.js)
 *       content/browser/browser.xul                   (content/browser.xul)
         content/browser/browser-identity.js           (content/browser-identity.js)
+        content/browser/browser-id-signIn.html        (content/browser-id-signIn.html)
+        content/browser/browser-id-createAccount.html (content/browser-id-createAccount.html)
 *       content/browser/browser-tabPreviews.xml       (content/browser-tabPreviews.xml)
         content/browser/content.js                    (content/content.js)
         content/browser/newtab/newTab.xul             (content/newtab/newTab.xul)
 *       content/browser/newtab/newTab.js              (content/newtab/newTab.js)
         content/browser/newtab/newTab.css             (content/newtab/newTab.css)
         content/browser/newtab/preload.xhtml          (content/newtab/preload.xhtml)
 *       content/browser/pageinfo/pageInfo.xul         (content/pageinfo/pageInfo.xul)
 *       content/browser/pageinfo/pageInfo.js          (content/pageinfo/pageInfo.js)
diff --git a/browser/modules/SignInToWebsite.jsm b/browser/modules/SignInToWebsite.jsm
--- a/browser/modules/SignInToWebsite.jsm
+++ b/browser/modules/SignInToWebsite.jsm
@@ -63,25 +63,25 @@ function ResizeWatcher(iframe) {
 }
 
 ResizeWatcher.prototype = {
   start: function ResizeWatcher_start() {
     this.stop(); // just in case...
     let doc = this._iframe.contentDocument;
 
     this._mutationObserver = new this._iframe.contentWindow.MutationObserver(
-      function(mutations) { 
-        sizePanelToContent(this._iframe); 
+      function(mutations) {
+        sizePanelToContent(this._iframe);
       }.bind(this));
 
     // Observe anything that causes the size to change.
     let config = {
-      attributes: true, 
-      characterData: true, 
-      childList: true, 
+      attributes: true,
+      characterData: true,
+      childList: true,
       subtree: true
     };
 
     this._mutationObserver.observe(doc, config);
 
     // and since this may be setup after the load event has fired we do an
     // initial resize now.
     sizePanelToContent(this._iframe);
@@ -184,16 +184,17 @@ HostFrame.prototype = {
   },
 
   /*
    * create an iframe and insert it into aOptions.  If showUI is
    * true, attach the iframe to a xul panel in the popup notification.
    * Otherwise attach to a hidden document.
    */
   _createIframe: function HostFrame_createIframe(aOptions) {
+    logger.log("options:", aOptions);
     let srcURI = aOptions.showUI ? kIdentityScreen : kIdentityFrame;
     logger.log('showUI is', aOptions.showUI, 'so iframe src =', srcURI);
 
     let hiddenDoc = Services.appShell.hiddenDOMWindow.document;
     this._iframe = hiddenDoc.createElementNS('http://www.w3.org/1999/xhtml', 'iframe');
 
     this._iframe.setAttribute('mozbrowser', true);
     this._iframe.setAttribute('mozframetype', 'content');
@@ -204,16 +205,17 @@ HostFrame.prototype = {
 
     // implement a dynamic resize watcher a la Social API
     this._iframe.style.height = "440px";
     this._iframe.style.width = "300px";
 
     aOptions.iframe = this._iframe;
 
     if (aOptions.showUI) {
+      logger.log("show ui");
       // synchronous, so we can call _injectShim below with no race condition
       requestUI(aOptions);
       this._resizeWatcher = new ResizeWatcher(this._iframe);
     } else {
       hiddenDoc.documentElement.appendChild(this._iframe);
     }
     this._injectShim(this._iframe);
   },
@@ -315,23 +317,33 @@ Pipe.prototype = {
 
 this.SignInToWebsiteUX = {
   init: function SignInToWebsiteUX_init() {
     this.contexts = {};
     Services.obs.addObserver(this, 'identity-controller-watch', false);
     Services.obs.addObserver(this, 'identity-controller-request', false);
     Services.obs.addObserver(this, 'identity-controller-logout', false);
     Services.obs.addObserver(this, 'identity-controller-canceled', false);
+
+    Services.obs.addObserver(this, 'identity-controller-getIdentity', false);
+    Services.obs.addObserver(this, 'identity-controller-signIn', false);
+    Services.obs.addObserver(this, 'identity-controller-signOut', false);
+    Services.obs.addObserver(this, 'identity-controller-createAccount', false);
   },
 
   uninit: function SignInToWebsiteUX_uninit() {
     Services.obs.removeObserver(this, 'identity-controller-watch');
     Services.obs.removeObserver(this, 'identity-controller-request');
     Services.obs.removeObserver(this, 'identity-controller-logout');
     Services.obs.removeObserver(this, 'identity-controller-canceled');
+
+    Services.obs.addObserver(this, 'identity-controller-getIdentity');
+    Services.obs.addObserver(this, 'identity-controller-signIn');
+    Services.obs.addObserver(this, 'identity-controller-signOut');
+    Services.obs.addObserver(this, 'identity-controller-createAccount');
   },
 
   observe: function SignInToWebsiteUX_observe(aSubject, aTopic, aData) {
     logger.log('controller observed:', aTopic);
     // XXX need to detect page unload of any of our flows
     // XXX we get strings from xul, and objects from elsewhere
     let rpOptions = {};
     if (aSubject) {
@@ -342,17 +354,17 @@ this.SignInToWebsiteUX = {
       }
     }
     if (!rpOptions.id) {
       logger.error('Got a message with no RP id');
       return;
     }
 
     let rpId = rpOptions.id;
-    let UI = getUIForWindowID(rpId);
+    //let UI = getUIForWindowID(rpId);
 
     let options = {
       id: rpOptions.id,
       rpOptions: rpOptions
     };
 
     switch (aTopic) {
       case 'identity-controller-watch':
@@ -362,16 +374,32 @@ this.SignInToWebsiteUX = {
       case 'identity-controller-request':
         this.doRequest(options);
         break;
 
       case 'identity-controller-logout':
         this.doLogout(options);
         break;
 
+      case 'identity-controller-getIdentity':
+        this.doGetIdentity(options);
+        break;
+
+      case 'identity-controller-signIn':
+        this.doSignIn(options);
+        break;
+
+      case 'identity-controller-signOut':
+        this.doSignOut(options);
+        break;
+
+      case 'identity-controller-createAccount':
+        this.doCreateAccount(options);
+        break;
+
       default:
         logger.error('SignInToWebsiteUX', 'Unknown observer notification:', aTopic);
         break;
     }
   },
 
   serviceDoMethod: function SignInToWebsiteUX_doMethod(aMessage, aId) {
     logger.log('serviceDoMethod received:', aMessage);
@@ -391,16 +419,32 @@ this.SignInToWebsiteUX = {
       case 'logout':
         IdentityService.doLogout(aId);
         break;
 
       case 'cancel':
         IdentityService.doCancel(aId);
         break;
 
+      case 'getIdentity':
+        IdentityService.doGetIdentity(aId);
+        break;
+
+      case 'signIn':
+        IdentityService.doSignIn(aId, aMessage.assertion);
+        break;
+
+      case 'signOut':
+        IdentityService.doSignOut(aId);
+        break;
+
+      case 'createAccount':
+        IdentityService.doCreateAccount(aId, aMessage.assertion);
+        break;
+
       default:
         logger.error('Unknown identity method: ' + aMessage.method);
         break;
     }
   },
 
   cleanUp: function SignInToWebsiteUX_cleanUp(aId) {
     let context = this.contexts[aId];
@@ -448,10 +492,37 @@ this.SignInToWebsiteUX = {
     aOptions.showUI = true;
     this.delegate(aOptions);
   },
 
   doLogout: function SignInToWebsiteUX_doLogout(aOptions) {
     aOptions.message = 'identity-delegate-logout';
     aOptions.showUI = false;
     this.delegate(aOptions);
-  }
+  },
+
+  doGetIdentity: function SignInToWebsiteUX_doGetIdentity(aOptions) {
+    logger.log("delegating getIdentity:" , aOptions);
+    aOptions.message = 'identity-delegate-getIdentity';
+    aOptions.showUI = false;
+    this.delegate(aOptions);
+  },
+
+  doSignIn: function SignInToWebsiteUX_doSignIn(aOptions) {
+    logger.log("delegating signin:" , aOptions);
+    aOptions.message = 'identity-delegate-signIn';
+    aOptions.showUI = false;
+    this.delegate(aOptions);
+  },
+
+  doSignOut: function SignInToWebsiteUX_doSignOut(aOptions) {
+    aOptions.message = 'identity-delegate-signOut';
+    aOptions.showUI = false;
+    this.delegate(aOptions);
+  },
+
+  doCreateAccount: function SignInToWebsiteUX_doCreateAccount(aOptions) {
+    aOptions.message = 'identity-delegate-createAccount';
+    aOptions.showUI = false;
+    this.delegate(aOptions);
+  },
+
 };
diff --git a/toolkit/identity/MinimalIdentity.jsm b/toolkit/identity/MinimalIdentity.jsm
--- a/toolkit/identity/MinimalIdentity.jsm
+++ b/toolkit/identity/MinimalIdentity.jsm
@@ -55,16 +55,45 @@ function makeMessageObject(aRpCaller) {
     let err = "id and origin required in relying-party message";
     logger.error(err);
     throw new Error(err);
   }
 
   return options;
 }
 
+function getWindowInfo() {
+  /*
+  let someWindow = Services.wm.getMostRecentWindow('navigator:browser');
+  let windowUtils = someWindow
+    .QueryInterface(Ci.nsIInterfaceRequestor)
+    .getInterface(Ci.nsIDOMWindowUtils);
+
+  let id = windowUtils.outerWindowID;
+  */
+
+  let wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
+                       .getService(Components.interfaces.nsIWindowMediator);
+  let recentWindow = wm.getMostRecentWindow("navigator:browser");
+
+  //let origin = recentWindow.content.document.location || 'resource://your-agent';
+  //logger.log("found origin:", origin);
+
+  let id = recentWindow
+    .content
+    .QueryInterface(Ci.nsIInterfaceRequestor)
+    .getInterface(Ci.nsIDOMWindowUtils)
+    .outerWindowID;
+
+  return({
+    origin: 'resource://your-agent',
+    id: id
+  });
+}
+
 function IDService() {
   Services.obs.addObserver(this, "quit-application-granted", false);
 
   // simplify, it's one object
   this.RP = this;
   this.IDP = this;
 
   // keep track of flows
@@ -144,16 +173,82 @@ IDService.prototype = {
    */
   logout: function IDService_logout(aRpCallerId) {
     let rp = this._rpFlows[aRpCallerId];
 
     let options = makeMessageObject(rp);
     Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-logout", null);
   },
 
+  /**
+   * Sign In To Browser functions:
+   *   getIdentity()
+   *   signIn()
+   *   signOut()
+   *   createAccount()
+   */
+
+  getIdentity: function IDService_getIdentity(aOptions, aCallback) {
+    let info = getWindowInfo();
+    let rp = {
+      origin: info.origin,
+      id: info.id,
+      onGetIdentity: aCallback
+    };
+    this._rpFlows[info.id] = rp;
+
+    let options = makeMessageObject(rp);
+    objectCopy(aOptions, options);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-getIdentity", null);
+  },
+
+  /**
+   * signIn to browser; callback with assertion on success or null
+   */
+  signIn: function IDService_signIn(aOptions, aCallback) {
+    let info = getWindowInfo();
+    let rp = {
+      id: info.id,
+      origin: info.origin,
+      onSignIn: aCallback
+    };
+    this._rpFlows[info.id] = rp;
+
+    let options = makeMessageObject(rp);
+    objectCopy(aOptions, options);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-signIn", null);
+  },
+
+  signOut: function IDService_signOut(aCallback) {
+    let info = getWindowInfo();
+    let rp = {
+      id: info.id,
+      origin: info.origin,
+      onSignOut: aCallback
+    };
+    this._rpFlows[info.id] = rp;
+
+    let options = makeMessageObject(rp);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-signOut", null);
+  },
+
+  createAccount: function IDService_createAccount(aOptions, aCallback) {
+    let info = getWindowInfo();
+    let rp = {
+      id: info.id,
+      origin: info.origin,
+      onCreateAccount: aCallback
+    };
+    this._rpFlows[info.id] = rp;
+
+    let options = makeMessageObject(rp);
+    objectCopy(aOptions, options);
+    Services.obs.notifyObservers({wrappedJSObject: options}, "identity-controller-createAccount", null);
+  },
+
   /*
    * once the UI-and-display-logic components have received
    * notifications, they call back with direct invocation of the
    * following functions (doLogin, doLogout, or doReady)
    */
 
   doLogin: function IDService_doLogin(aRpCallerId, aAssertion, aInternalParams) {
     let rp = this._rpFlows[aRpCallerId];
@@ -190,16 +285,65 @@ IDService.prototype = {
     if (!rp) {
       logger.error("WARNING: doCancel found no rp for callerId ", aRpCallerId);
       return;
     }
 
     rp.doCancel();
   },
 
+  doGetIdentity: function IDService_doGetIdentity(aRpCallerId, aAssertion, aInternalParams) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (!rp) {
+      logger.error("no flow for id", aRpCallerId);
+    }
+    logger.log("got identity with assertion", aAssertion);
+    if (typeof rp.onGetIdentity === 'function') {
+      rp.onGetIdentity(aAssertion, aInternalParams);
+    }
+  },
+
+  doSignIn: function IDService_doSignIn(aRpCallerId, aAssertion, aInternalParams) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (!rp) {
+      logger.error("no flow for id", aRpCallerId);
+    }
+    logger.log("signed in with assertion", aAssertion);
+    if (typeof rp.onSignIn === 'function') {
+      rp.onSignIn(aAssertion, aInternalParams);
+    }
+  },
+
+  doSignOut: function IDService_doSignOut(aRpCallerId) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (rp) {
+      if (typeof rp.onSignOut === 'function') {
+        rp.onSignOut(true);
+      }
+      delete(this._rpFlows[aRpCallerId]);
+    }
+  },
+
+  doCreateAccount: function IDService_doCreateAccount(aRpCallerId, aAssertion) {
+    let rp = this._rpFlows[aRpCallerId];
+    if (rp) {
+      if (typeof rp.onCreateAccount === 'function') {
+        rp.onCreateAccount(aAssertion);
+      }
+      delete(this._rpFlows[aRpCallerId]);
+    }
+  },
+
+  doFoo: function foFoo() {
+    let wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
+                   .getService(Components.interfaces.nsIWindowMediator);
+    let mainWindow = wm.getMostRecentWindow("navigator:browser");
+    mainWindow.gBrowser.addTab("chrome://browser/components/identity/SignInToBrowser.html");
+  },
+
   /**
    * IDP functions are taken care of by the dialog.  The DOM should never
    * be calling these methods on this service.  So if it does, use the 
    * logger.error function to give a stack trace.
    */
 
   beginProvisioning: function IDService_beginProvisioning(context) {
     logger.error("Not implemented");
